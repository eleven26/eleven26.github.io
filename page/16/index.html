<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eleven26.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="eleven26">
<meta property="og:url" content="https://eleven26.github.io/page/16/index.html">
<meta property="og:site_name" content="eleven26">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="eleven26">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="PHP">
<meta property="article:tag" content="Laravel">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://eleven26.github.io/page/16/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/16/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>eleven26</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">eleven26</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">100</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">346</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eleven26</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eleven26" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eleven26" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/12/20/golang/go%20slice%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/20/golang/go%20slice%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">go slice 基本用法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-20 17:16:30" itemprop="dateCreated datePublished" datetime="2022-12-20T17:16:30+08:00">2022-12-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>slice</code>（切片）是 go
里面非常常用的一种数据结构，它代表了一个变长的序列，序列中的每个元素都有相同的数据类型。
一个 <code>slice</code> 类型一般写作 <code>[]T</code>，其中
<code>T</code> 代表 <code>slice</code> 中元素的类型；<code>slice</code>
的语法和数组很像，但是 <code>slice</code> 没有固定长度。</p>
<h2 id="数组和切片的区别">数组和切片的区别</h2>
<p>数组有确定的长度，而切片的长度不固定，并且可以自动扩容。</p>
<h3 id="数组的定义">数组的定义</h3>
<p>go 中定义数组的方式有如下两种：</p>
<ol type="1">
<li>指定长度：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>不指定长度，由编译器推导出数组的长度：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>上面这两种定义方式都定义了一个长度为 3
的数组。正如我们所见，<strong>长度是数组的一部分，定义数组的时候长度已经确定下来了</strong>。</p>
<h3 id="切片的定义">切片的定义</h3>
<p>切片的定义方式跟数组很像，只不过<strong>定义切片的时候不用指定长度</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在上面定义切片的代码中，我们可以看到其实跟数组唯一的区别就是少了个长度。
那其实我们可以<strong>把切片看作是一个无限长度的数组</strong>。
当然，实际上它并不是无限的，它只是在切片容纳不下新的元素的时候，会自动进行扩容，从而可以容纳更多的元素。</p>
<h2 id="数组和切片的相似之处">数组和切片的相似之处</h2>
<p>正如我们上面看到的那样，数组和切片两者其实非常相似，在实际使用中，它们也是有些类似的。</p>
<p>比如，通过下标来访问元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 通过下标访问</span></span><br><span class="line">fmt.Println(arr[<span class="number">1</span>]) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 通过下标访问</span></span><br><span class="line">fmt.Println(s[<span class="number">1</span>]) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="数组的局限">数组的局限</h2>
<p>我们知道了，数组的长度是固定的，这也就意味着如果我们想往数组里面增加一个元素会比较麻烦，
<strong>我们需要新建一个更大的数组，然后将旧的数据复制过去，然后将新的元素写进去</strong>，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 往数组 arr 增加一个元素：4</span></span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 新建一个更大容量的数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">4</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 复制旧数组的数据</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">    arr1[i] = arr[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加入新的元素：4</span></span><br><span class="line">arr1[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">fmt.Println(arr1)</span><br></pre></td></tr></table></figure>
<p>这样一来就非常的繁琐，如果我们使用切片，就可以省去这些步骤：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个长度为 3 的数组</span></span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组创建一个切片</span></span><br><span class="line">s := arr[:]</span><br><span class="line"><span class="comment">// 增加一个元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></table></figure>
<p><strong>因为数组固定长度的缺点，实际使用中切片会使用得更加普遍。</strong></p>
<h2 id="重新理解-slice">重新理解 slice</h2>
<p>在开始之前，我们来看看 <code>slice</code>
这个单词的意思：作为名词，<code>slice</code> 的意思有
<code>片;部分;(切下的食物)薄片;</code>，作为动词，<code>slice</code>
的意思有 <code>切;把…切成(薄)片;</code> 的意思。
从这个角度出发，我们可以把 <code>slice</code> 理解为从某个数组上
<code>切下来的一部分</code>（从这个角度看，<code>slice</code>
这个命名非常的形象）。我们可以看看下图：</p>
<figure>
<img src="/images/go/slice/slice_1_1.png" alt="slice_1_1" />
<figcaption aria-hidden="true">slice_1_1</figcaption>
</figure>
<p>在这个图中，<code>A</code> 是一个保存了数字 <code>1~7</code> 的
<code>slice</code>，<code>B</code> 是从 <code>A</code> 中
<strong>切下来的一部分</strong>，而 <code>B</code> 只包含了
<code>A</code> 中的一部分数据。 我们可以把 <code>B</code> 理解为
<code>A</code> 的一个 <code>视图</code>，<code>B</code> 中的数据是
<code>A</code> 中的数据的一个 <code>引用</code>，而不是 <code>A</code>
中数据的一个 <code>拷贝</code> （也就是说，我们修改 <code>B</code>
的时候，<code>A</code> 中的数据也会被修改，当然会有例外，那就是
<code>B</code> <strong>发生扩容的时候</strong>，再去修改 <code>B</code>
的话就影响不了 <code>A</code> 了）。</p>
<h2 id="slice-的内存布局">slice 的内存布局</h2>
<p>现在假设我们有如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个切片，长度为 3，容量为 7</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></table></figure>
<p>对应的内存布局如下：</p>
<figure>
<img src="/images/go/slice/slice_2_1.png" alt="slice_2_1" />
<figcaption aria-hidden="true">slice_2_1</figcaption>
</figure>
<p>说明：</p>
<ul>
<li><code>slice</code>
底层其实也是数组，但是除了数组之外，还有两个字段记录切片的长度和容量，分别是
<code>len</code> 和 <code>cap</code>。</li>
<li>上图中，<code>slice</code> 中的 <code>array</code>
就是切片的底层数组，因为它的长度不是固定的，所以使用了指针来保存，指向了另外一片内存区域。</li>
<li><code>len</code>
表明了切片的长度，<strong>切片的长度也就是我们可以操作的下标</strong>，上面的切片长度为
<code>3</code>，这也就意味着我们切片可以操作的下标范围是
<code>0~2</code>。超出这个范围的下标会报错。</li>
<li><code>cap</code>
表明了切片的容量，也就是<strong>切片扩容之前可以容纳的元素个数</strong>。</li>
</ul>
<h2 id="切片容量存在的意义">切片容量存在的意义</h2>
<p>对于我们日常开发来说，<code>slice</code>
的容量其实大多数时候不是我们需要关注的点，而且由于容量的存在，也给开发者带来了一定的困惑。
那么容量存在的意义是什么呢？意义就在于避免内存的频繁分配带来的性能下降（<strong>容量也就是提前分配的内存大小</strong>）。</p>
<p>比如，假如我们有一个切片，然后我们知道需要往它里面存放 1w 个元素，
如果我们不指定容量的话，那么切片就会在它存放不下新的元素的时候进行扩容，
这样一来，可能在我们存放这 1w 个元素的时候需要进行多次扩容，
这也就意味着需要进行多次的内存分配。这样就会影响应用的性能。</p>
<p>我们可以通过下面的例子来简单了解一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Benchmark1-20    	100000000	        11.68 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark2-20    	134283985	         7.482 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">100000000</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个例子中，没有给 <code>slice</code>
设置容量，这样它就只会在切片容纳不下新元素的时候才会进行扩容，这样就会需要进行多次扩容。
而第二个例子中，我们先给 <code>slice</code>
设置了一个足够大的容量，那么它就不需要进行频繁扩容了。</p>
<p>最终我们发现，在给切片提前设置容量的情况下，会有一定的性能提升。</p>
<h2 id="切片常用操作">切片常用操作</h2>
<h3 id="创建切片">创建切片</h3>
<p>我们可以从数组或切片生成新的切片：</p>
<blockquote>
<p>注意：生成的切片不包含 <code>end</code>。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target[start:end]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>target</code> 表示目标数组或者切片</li>
<li><code>start</code> 对应目标对象的起始索引（包含）</li>
<li><code>end</code> 对应目标对象的结束索引（不包含）</li>
</ul>
<p>如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s1 := s[<span class="number">1</span>:<span class="number">2</span>]    <span class="comment">// 包含下标 1，不包含下标 2</span></span><br><span class="line">fmt.Println(s1) <span class="comment">// [2]</span></span><br><span class="line"></span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 := arr[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Println(s2) <span class="comment">// [2]</span></span><br></pre></td></tr></table></figure>
<p>在这种初始化方式中，我们可以省略 <code>start</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr[:<span class="number">2</span>]) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>省略 <code>start</code> 的情况下，就是从 <code>target</code>
的第一个元素开始。</p>
<p>我们也可以省略 <code>end</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr[<span class="number">1</span>:]) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
<p>省略 <code>end</code> 的情况下，就是从 <code>start</code>
索引处的元素开始直到 <code>target</code> 的最后一个元素处。</p>
<p>除此之外，我们还可以指定新的切片的容量，通过如下这种方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target[start:end:<span class="built_in">cap</span>]</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">s := arr[<span class="number">1</span>:<span class="number">4</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// [2 3 4] 3 4</span></span><br></pre></td></tr></table></figure>
<h3 id="往切片中添加元素">往切片中添加元素</h3>
<p>我们前面说过了，如果我们想往数组里面增加元素，那么我们必须开辟新的内存，将旧的数组复制过去，然后才能将新的元素加入进去。</p>
<p>但是切片就相对简单，我们可以使用 <code>append</code>
这个内置函数来往切片中加入新的元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>) <span class="comment">// 追加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 追加多个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;...) <span class="comment">// 追加一个切片</span></span><br></pre></td></tr></table></figure>
<h3 id="切片复制">切片复制</h3>
<p>go 有一个内置函数 <code>copy</code>
可以将一个切片的内容复制到另外一个切片中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(dst, src []<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>第一个参数 <code>dst</code> 是目标切片，第二个参数 <code>src</code>
是源切片，调用 <code>copy</code> 的时候会把 <code>src</code>
的内容复制到 <code>dst</code> 中。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> b []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 的容量为 0，容纳不下任何元素</span></span><br><span class="line"><span class="built_in">copy</span>(a, b)</span><br><span class="line">fmt.Println(a) <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">3</span>) <span class="comment">// 给 a 分配内存</span></span><br><span class="line"><span class="built_in">copy</span>(a, b)</span><br><span class="line">fmt.Println(a) <span class="comment">// [1 2 3]</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果 <code>dst</code> 的长度比 <code>src</code>
的长度小，那么只会截取 <code>src</code> 的前面一部分。</p>
<h3 id="从切片删除元素">从切片删除元素</h3>
<p>虽然我们往切片追加元素的操作挺方便的，但是要从切片删除元素就相对麻烦一些了。go
语言本身没有提供从切片删除元素的方法。
如果我们要删除切片中的元素，只有构建出一个新的切片：</p>
<figure>
<img src="/images/go/slice/slice_3_1.png" alt="slice_3_1" />
<figcaption aria-hidden="true">slice_3_1</figcaption>
</figure>
<p>对应代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;</span><br><span class="line">    a[i] = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b []<span class="type">int</span></span><br><span class="line">b = <span class="built_in">append</span>(b, a[:<span class="number">2</span>]...) <span class="comment">// [1 2]</span></span><br><span class="line">b = <span class="built_in">append</span>(b, a[<span class="number">5</span>:]...) <span class="comment">// [1 2 6 7]</span></span><br><span class="line">fmt.Println(b) <span class="comment">// [1 2 6 7]</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们想从 <code>a</code> 中删除 <code>3、4、5</code>
这三个元素，也就是下标 <code>2~4</code> 的元素，
我们的做法是，新建了一个新的切片，然后将 <code>3</code>
前面的元素加入到这个新的切片中， 再将 <code>5</code>
后面的元素加入到这个新切片中。</p>
<p>最终得到的切片就是删除了 <code>3、4、5</code>
三个元素之后的切片了。</p>
<h2 id="切片的容量到底是多少">切片的容量到底是多少？</h2>
<p>假设我们有如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;</span><br><span class="line">    a[i] = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">s1 := a[:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// [1 2 3] 3 7</span></span><br><span class="line">fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line"></span><br><span class="line">s2 := a[<span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line"><span class="comment">// [5 6] 2 3</span></span><br><span class="line">fmt.Println(s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br></pre></td></tr></table></figure>
<p><code>s1</code> 和 <code>s2</code> 可以用下图表示：</p>
<figure>
<img src="/images/go/slice/slice_3_2.png" alt="slice_3_2" />
<figcaption aria-hidden="true">slice_3_2</figcaption>
</figure>
<ul>
<li><code>s1</code> 只能访问 <code>array</code>
的前三个元素，<code>s2</code> 只能访问 <code>5</code> 和 <code>6</code>
这两个元素。</li>
<li><code>s1</code> 的容量是 7（底层数组的长度）</li>
<li><code>s2</code> 的容量是 3，从 <code>5</code>
所在的索引处直到底层数组的末尾。</li>
</ul>
<p>对于 <code>s1</code> 和
<code>s2</code>，我们都没有指定它的容量，但是我们打印发现它们都有容量，
其实在切片中，我们从切片中生成一个新的切片的时候，如果我们不指定容量，
那新切片的容量就是 <code>s[start:end]</code> 中的 <code>start</code>
直到底层数组的最后一个元素的长度。</p>
<h2 id="切片可以共享底层数组">切片可以共享底层数组</h2>
<p>切片最需要注意的点是，当我们从一个切片中创建新的切片的时候，两者会共享同一个底层数组，
如上图的那样，<code>s1</code> 和 <code>s2</code>
都引用了同一个底层的数组不同的索引， <code>s1</code> 引用了底层数组的
<code>0~2</code> 下标范围，<code>s2</code> 引用了底层数组
<code>4~5</code> 下标范围。</p>
<p>这意味着，当我们修改 <code>s1</code> 或 <code>s2</code>
的时候，原来的切片 <code>a</code> 也会发生改变：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;</span><br><span class="line">    a[i] = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">s1 := a[:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// [1 2 3]</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line">s1[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// [1 100 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="comment">// [1 100 3]</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>s1</code> 这个切片引用了和 <code>a</code>
一样的底层数组， 然后在我们修改 <code>s1</code> 的时候，<code>a</code>
也发生了改变。</p>
<h2 id="切片扩容不会影响原切片">切片扩容不会影响原切片</h2>
<p>上一小节我们说了，切片可以共享底层数组。但是<strong>如果切片扩容的话，那就是一个全新的切片了</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// [1 2 3] 3 3</span></span><br><span class="line">fmt.Println(a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 容纳不下新的元素了，会进行扩容</span></span><br><span class="line">b := <span class="built_in">append</span>(a, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [1 2 3 4] 4 6</span></span><br><span class="line">fmt.Println(b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// [1 2 3]</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="comment">// [1 100 3 4]</span></span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>a</code> 是一个长度和容量都是 <code>3</code>
的切片，这也就意味着，这个切片已经满了。
在这种情况下，<strong>我们再往其中追加元素的时候，就会进行扩容，生成一个新的切片</strong>。
因此，我们可以看到，我们修改了 <code>b</code> 的时候，并没有影响到
<code>a</code>。</p>
<p>下面的例子就不一样了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度为 2，容量为 3</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"><span class="comment">// [1 2] 2 3</span></span><br><span class="line">fmt.Println(a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 还可以容纳新的元素，不用扩容</span></span><br><span class="line">b := <span class="built_in">append</span>(a, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [1 2 4] 3 3</span></span><br><span class="line">fmt.Println(b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// [1 100]</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="comment">// [1 100 4]</span></span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure>
<p>在后面这个例子中，我们只是简单地改了一下 <code>a</code>
初始化的方式，改成了只放入两个元素，但是容量还是 <code>3</code>，
在这种情况下，<code>a</code> 可以再容纳一个元素，这样在
<code>b := append(a, 4)</code> 的时候，创建的 <code>b</code>
底层的数组其实跟 <code>a</code> 的底层数组依然是一样的。</p>
<p>所以，<strong>我们需要尤其注意代码中作为切片的函数参数，如果我们希望在被调函数中修改了切片之后，在
caller 里面也能看到效果的话，最好是传递指针</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(s *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	*s = <span class="built_in">append</span>(*s, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSlice</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="comment">// [1 2 3] 3 3</span></span><br><span class="line">	fmt.Println(a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line">	test1(a)</span><br><span class="line">	<span class="comment">// [1 2 3] 3 3</span></span><br><span class="line">	fmt.Println(a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="comment">// [1 2 3] 3 3</span></span><br><span class="line">	fmt.Println(b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">	test2(&amp;b)</span><br><span class="line">	<span class="comment">// [1 2 3 4] 4 6</span></span><br><span class="line">	fmt.Println(b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>test1</code> 接收的是值参数，所以在
<code>test1</code> 中切片发生扩容的时候，<code>TestSlice</code> 里面的
<code>a</code> 还是没有发生改变。 而 <code>test2</code>
接收的是指针参数，所以在 <code>test2</code>
中发生切片扩容的时候，<code>TestSlice</code> 里面的 <code>b</code>
也发生了改变。</p>
<h2 id="总结">总结</h2>
<ul>
<li>数组跟切片的使用上有点类似，但是数组代表的是有固定长度的数据序列，而切片代表的是没有固定长度的数据序列。</li>
<li>数组的长度是类型的一部分，有两种定义数组的方式：<code>[2]int&#123;1, 2&#125;</code>、<code>[...]int&#123;1, 2&#125;</code>。</li>
<li>数组跟切片都可以通过下标来访问其中的元素，可以访问的下标范围都是
<code>0 ~ len(x)-1</code>，<code>x</code> 表示的是数组或者切片。</li>
<li>数组无法追加新的元素，切片可以追加任意数量的元素。</li>
<li><code>slice</code> 的数据结构里面包含了：<code>array</code>
底层数组指针、<code>len</code> 切片长度、<code>cap</code>
切片容量。</li>
<li>创建切片的时候，指定一个合适的容量可以减少内存分配的次数，从而在一定程度上提高程序性能。</li>
<li>我们可以从数组或者切片创建一个新的切片：<code>array[1:3]</code> 或者
<code>slice[1:3]</code>。</li>
<li>使用 <code>append</code> 内置函数可以往切片中添加新的元素。</li>
<li>使用 <code>copy</code>
内置函数可以将一个切片的内容复制到另外一个切片中。</li>
<li>切片删除元素没有好的办法，只能截取被删除元素前后的数据，然后复制到一个新的切片中。</li>
<li>假设我们通过 <code>slice[start:end]</code>
的方式从切片中创建一个新的切片，那么这个新的切片的容量是
<code>cap(slice) - start</code>，也就是，从 <code>start</code>
到底层数组最后一个元素的长度。</li>
<li>使用切片的时候需要注意：切片之间会共享底层数组，其中一个切片修改了切片的元素的时候，也会反映到其他切片上。</li>
<li>函数调用的时候，如果被调函数内发生扩容，调用者是无法知道的。如果我们不想错过在被调函数内切片的变化，我们可以传递指针作为参数。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/12/16/golang/go%20map%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/16/golang/go%20map%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">go map 设计与实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-16 11:52:30" itemprop="dateCreated datePublished" datetime="2022-12-16T11:52:30+08:00">2022-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文基于 go 1.19</p>
</blockquote>
<p>哈希表作为一种非常常用的数据结构，存在于各种编程语言中，它可以让我们保存<strong>键值对</strong>数据，而且有着非常高的查找效率。
本文就以 go 语言中的 <code>map</code> 为例子，讲述一下哈希表在 go
中的实现。</p>
<h2 id="哈希表基本操作">哈希表基本操作</h2>
<p>在开始之前，需要大概讲解一下哈希表这种数据结构，哈希表会预先在内存中分配一段比较大的内存，这段内存用在将来往里面写入数据的时候使用。
哈希表有点类似数组，都是一段连续的内存，但是我们往哈希表读写数据的时候不同于数组，数组的时候是<strong>直接通过下标访问</strong>的，
而哈希表的读写需要先计算 <code>key</code>
的哈希值，根据这个哈希值对哈希表长度取模得到 <code>key</code>
对应的哈希表的下标，然后对哈希表这个下标进行读写操作。</p>
<p>对于哈希表有以下几种常见的操作：</p>
<ol type="1">
<li>写入：根据 <code>key</code> 计算 <code>hash</code>
值，对哈希表长度取模得到 <code>key</code>
在内存中的地址，然后往这个地址写入数据。</li>
<li>读取：根据 <code>key</code> 计算 <code>hash</code>
值，对哈希表长度取模得到 <code>key</code>
在内存中的地址，然后读取这个地址中的数据。</li>
<li>修改：根据 <code>key</code> 计算 <code>hash</code>
值，对哈希表长度取模得到 <code>key</code>
在内存中的地址，然后修改这个内存地址里面的数据。</li>
<li>删除：根据 <code>key</code> 计算 <code>hash</code>
值，对哈希表长度取模得到 <code>key</code>
在内存中的地址，然后清空保存这个 <code>key</code> 的那一小块内存。</li>
</ol>
<p>注意：计算出的 <code>hash</code>
值可能比分配的内存大小要大，所以才需要对其取模（<code>hash</code> 值 /
哈希表长度 =&gt; <code>key</code> 在哈希表的索引）， 保证计算出的
<code>hash</code> 最终落到哈希表的内存范围之内。比如，<code>keyn</code>
计算出来的哈希值为 <code>100</code>，但是我们的哈希表长度只有
<code>8</code>， 那么 <code>keyn</code> 最终会落在哈希表中下标为
<code>2</code> 的地方（<code>100 % 7 = 2</code>，下标是从 <code>0</code>
开始的，所以这里是 <code>7</code>）</p>
<h3 id="哈希表的写入">哈希表的写入</h3>
<p>假设我们现在要有一个长度为 8 的哈希表（下图左），我们有数据
<code>&#123;"a": 1, "b": 2&#125;</code>
需要存入这个哈希表，存入之后的哈希表为下图右：</p>
<figure>
<img src="/images/go/map/map_1_1.png" alt="哈希表的写入" />
<figcaption aria-hidden="true">哈希表的写入</figcaption>
</figure>
<p>说明：<code>hash(a) = 5</code>，计算 <code>a</code> 的哈希值得到
<code>5</code>，所以将 <code>a:1</code> 存入了哈希表中下标为
<code>5</code> 的地址处。<code>b</code> 同理。</p>
<blockquote>
<p>注意：键值都会存储。</p>
</blockquote>
<h3 id="哈希表的读取">哈希表的读取</h3>
<p>从哈希表中读取 <code>key</code> 为 <code>b</code> 的键值对：</p>
<figure>
<img src="/images/go/map/map_1_2.png" alt="哈希表的读取" />
<figcaption aria-hidden="true">哈希表的读取</figcaption>
</figure>
<h3 id="哈希表的修改">哈希表的修改</h3>
<p>现在，我们需要将 <code>a</code> 的值修改为
<code>3</code>，同样的，计算其 <code>hash</code> 值，得到
<code>5</code>，然后将哈希表中 <code>5</code> 这个下标的内存修改成
<code>3</code>：</p>
<figure>
<img src="/images/go/map/map_1_3.png" alt="哈希表的修改" />
<figcaption aria-hidden="true">哈希表的修改</figcaption>
</figure>
<h3 id="哈希表的删除">哈希表的删除</h3>
<p>假设要将哈希表中 <code>b</code> 这个键删除，会先计算其
<code>hash</code> 值，得到 <code>0</code>，然后将哈希表中 <code>0</code>
这个下标的内存清空：</p>
<figure>
<img src="/images/go/map/map_1_4.png" alt="哈希表的删除" />
<figcaption aria-hidden="true">哈希表的删除</figcaption>
</figure>
<h3 id="哈希表的高效之处">哈希表的高效之处</h3>
<p>通过上面的分析，我们可以知道，哈希表的内存布局跟数组类似，但是哈希表的存储要通过计算
<code>key</code>
的哈希值来得到其在哈希表中的索引，最后对这个索引的内存进行 CRUD
操作。这样一来，如果我们需要频繁的根据键查找其对应值的话，使用哈希表无疑会大大提高效率。相比之下，如果使用数组来存储，那么每次搜索都需要将整个数组遍历一次，效率非常低下。</p>
<p>比如下图，假设我们一个数组内存布局如下，那么在我们查找
<code>a:1</code>
的时候，需要从数组的第一个元素开始遍历，每一个元素读取出来看看它的键是不是
<code>a</code>， 取到第 <code>6</code> 个元素（下标
<code>5</code>）的时候，发现它的键是 <code>a</code>，然后取出对应的值
<code>1</code>。</p>
<figure>
<img src="/images/go/map/map_1_5.png" alt="哈希表的高效之处" />
<figcaption aria-hidden="true">哈希表的高效之处</figcaption>
</figure>
<p>在数组的元素个数少的时候，这种查找效率其实影响不大，但如果我们有上万个元素的时候，每次查找都要从第一个元素开始遍历，效率无疑会非常低。
相比之下，不管数据再怎么多，使用哈希表的方式，我们直接通过哈希算法计算一下就可以知道键保存到了哪个槽中。</p>
<h2 id="哈希冲突解决方法">哈希冲突解决方法</h2>
<p>在上一节中，我们的图将哈希表的每一个槽（<code>slot</code>，又或者叫
<code>cell</code>，都是同一个东西）都表示成只有一个元素了。
但在实际中，往往会出现计算出来的哈希值对哈希表长度取模后是相等的，也就是不同的
<code>key</code> 会落到同一个槽中（这就是
<strong>哈希冲突</strong>），</p>
<p>这种情况下，一个槽存放不下的话，有两种办法可以处理：<strong>开放地址法</strong>和<strong>链表法</strong>。go
里面的 <code>map</code> 使用的是<strong>链表法</strong>，
具体来说，就是在 <code>hash</code> 冲突的地方，建立一个链表来保存相同
<code>hash</code> 值的 <code>key</code>。</p>
<p>这样一来，我们通过 <code>hash</code>
算法计算出哈希值的时候，并不能唯一确定对应的值了，因为有可能两个
<code>key</code> 经过哈希算法计算之后，得到的哈希值是一样的。
这种情况怎么办呢？很简单，因为虽然哈希值是一样的，但是它们的
<code>key</code> 是不一样的，再比较一下 <code>key</code>
就可以确定了。具体可以参考下图：</p>
<figure>
<img src="/images/go/map/map_1_6.png" alt="哈希冲突" />
<figcaption aria-hidden="true">哈希冲突</figcaption>
</figure>
<p>有哈希冲突的情况下，读取哈希表数据的过程：</p>
<ul>
<li>计算 <code>c</code> 的 <code>hash</code> 值，得到
<code>0</code>，就是哈希表的索引</li>
<li>获取哈希表中地址 <code>0</code>
上的数据，这会遍历冲突产生的链表</li>
<li>比较 <code>c</code> 跟
<code>b</code>，不相等，继续比较链表下一个元素</li>
<li>比较 <code>c</code> 跟 <code>c</code>，相等，返回
<code>3</code></li>
</ul>
<h2 id="哈希扩容">哈希扩容</h2>
<p>go 里面 <code>map</code>
扩容有两种方式：<strong>增量扩容</strong>和<strong>等量扩容</strong>。</p>
<h3
id="哈希表总元素个数过多导致的扩容">哈希表总元素个数过多导致的扩容</h3>
<p>这种扩容方式也叫<strong>增量扩容</strong>。</p>
<p>我们在上面说过了，其实哈希表的内存布局跟数组类似，都是先分配一段连续的内存。然后在哈希冲突的时候，对于冲突的
<code>key</code> 建立一个链表来保存。
这样就会出现一种情况，在链表中存在很多冲突的键，这样一来，在查找冲突
<code>key</code> 的时候，需要在这一堆冲突的 <code>key</code>
中进行查找，这个查找类似数组的查找，效率较低。</p>
<p>为了避免这种情况的出现，一般的哈希表设计会在元素个数总数超过一定数量的时候，对哈希表进行扩容，
这样一来，那些哈希冲突的键就可以相对均匀地分布在哈希表中，从而避免了很多哈希冲突情况下导致的查找效率低下的问题。</p>
<blockquote>
<p>扩容之后的容量为原来容量的 2 倍。</p>
</blockquote>
<figure>
<img src="/images/go/map/map_1_7.png" alt="增量扩容" />
<figcaption aria-hidden="true">增量扩容</figcaption>
</figure>
<h4 id="go-map-的负载因子">go map 的负载因子</h4>
<p>在 go 中，<code>map</code> 在实际存储的元素数量超过 <code>map</code>
里 <code>bucket</code> 总数量的 <code>6.5</code>
倍的时候（也就是平均每个 <code>bucket</code> 中的元素个数大于
<code>6.5</code> 的时候），会进行扩容， 这个 <code>6.5</code> 是实现
<code>map</code> 的那个开发者经过实验计算出来的比较合适的数，这个
<code>6.5</code> 被称为负载因子。</p>
<p>为什么负载因子是 <code>6.5</code> 呢，在 go 的 <code>map</code>
源码中有相关的说明：</p>
<p><strong>选择负载因子，如果太大，会有很多溢出桶，太小，则会浪费很多空间</strong>。
我编写了一个简单的程序来检查不同负载的一些统计数据:（64位、8字节 key
和元素）</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">loadFactor</th>
<th style="text-align: right;">%overflow</th>
<th style="text-align: right;">bytes/entry</th>
<th style="text-align: right;">hitprobe</th>
<th style="text-align: right;">missprobe</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">4.00</td>
<td style="text-align: right;">2.13</td>
<td style="text-align: right;">20.77</td>
<td style="text-align: right;">3.00</td>
<td style="text-align: right;">4.00</td>
</tr>
<tr class="even">
<td style="text-align: right;">4.50</td>
<td style="text-align: right;">4.05</td>
<td style="text-align: right;">17.30</td>
<td style="text-align: right;">3.25</td>
<td style="text-align: right;">4.50</td>
</tr>
<tr class="odd">
<td style="text-align: right;">5.00</td>
<td style="text-align: right;">6.85</td>
<td style="text-align: right;">14.77</td>
<td style="text-align: right;">3.50</td>
<td style="text-align: right;">5.00</td>
</tr>
<tr class="even">
<td style="text-align: right;">5.50</td>
<td style="text-align: right;">10.55</td>
<td style="text-align: right;">12.94</td>
<td style="text-align: right;">3.75</td>
<td style="text-align: right;">5.50</td>
</tr>
<tr class="odd">
<td style="text-align: right;">6.00</td>
<td style="text-align: right;">15.27</td>
<td style="text-align: right;">11.67</td>
<td style="text-align: right;">4.00</td>
<td style="text-align: right;">6.00</td>
</tr>
<tr class="even">
<td style="text-align: right;">6.50</td>
<td style="text-align: right;">20.90</td>
<td style="text-align: right;">10.79</td>
<td style="text-align: right;">4.25</td>
<td style="text-align: right;">6.50</td>
</tr>
<tr class="odd">
<td style="text-align: right;">7.00</td>
<td style="text-align: right;">27.14</td>
<td style="text-align: right;">10.15</td>
<td style="text-align: right;">4.50</td>
<td style="text-align: right;">7.00</td>
</tr>
<tr class="even">
<td style="text-align: right;">7.50</td>
<td style="text-align: right;">34.03</td>
<td style="text-align: right;">9.73</td>
<td style="text-align: right;">4.75</td>
<td style="text-align: right;">7.50</td>
</tr>
<tr class="odd">
<td style="text-align: right;">8.00</td>
<td style="text-align: right;">41.10</td>
<td style="text-align: right;">9.40</td>
<td style="text-align: right;">5.00</td>
<td style="text-align: right;">8.00</td>
</tr>
</tbody>
</table>
<p>列说明：</p>
<ul>
<li><code>%overflow</code>: 具有溢出桶的桶的百分比</li>
<li><code>bytes/entry</code>: 每个 key/elem 对使用的开销字节</li>
<li><code>hitprobe</code>: 查找当前 key 时要检查的条目数</li>
<li><code>missprobe</code>: 查找缺少的 key 时要检查的条目数</li>
</ul>
<h3
id="哈希冲突链上元素太少导致的扩容">哈希冲突链上元素太少导致的扩容</h3>
<p>这种扩容方式也叫<strong>等量扩容</strong>。</p>
<p>我们知道，在哈希冲突的时候，会建立链表来保存键冲突的元素，但是我们删除那些哈希冲突的键的时候，并不会对删除元素的内存进行释放，
如果每次删除都释放的话，在我们频繁插入跟删除的时候，效率就非常低下了。
因为插入一个元素就分配内存，删除一个元素就释放内存（分配内存和释放内存都是相对耗时的操作）。
而这样的结果是，保存冲突键的链表上，有很多空的元素，这样就会导致冲突的时候，查找键的效率降低，因为要遍历很多空的键。</p>
<p>删除的时候不释放，那什么时候会释放呢？哈希冲突的元素很多都被删除的时候，在
go 里面，<code>map</code> 会判断就算没有超过负载因子的情况下，
如果冲突链表占用的空间过大的话，也会进行扩容。但这里说的扩容其实并不是真正意义上的扩容，只是
<code>map</code> 的实现里面，使用的函数是同一个函数。</p>
<p>具体实现方式是，分配跟原哈希表相同大小的空间，然后将旧哈希表的数据迁移到新的哈希表。
这样迁移之后，对于哈希冲突链表上的那些元素，只会迁移非空的元素，最终结果就是，扩容之后，哈希冲突链表上的元素更加紧凑，在查找冲突的键的时候会更加高效。</p>
<blockquote>
<p>虽然哈希表的总容量没变，但是数据分布更加紧凑了，省去了遍历空元素的时间。</p>
</blockquote>
<figure>
<img src="/images/go/map/map_1_8.png" alt="等量扩容" />
<figcaption aria-hidden="true">等量扩容</figcaption>
</figure>
<h2 id="go-map-概述">go map 概述</h2>
<ul>
<li><code>map</code> 只是一个哈希表。数据被排列成一组
<code>bucket</code>。</li>
<li>每个 <code>bucket</code> 最多包含 <code>8</code> 个
<code>键/值</code> 对。</li>
<li>哈希值的低位字节位用于选择 <code>bucket</code>。</li>
<li>每个 <code>bucket</code>
包含每个哈希的几个高位字节位(<code>tophash</code>)，以区分单个桶中的条目。</li>
<li>如果超过 <code>8</code> 个 <code>key</code>
哈希到同一个桶，我们将额外的桶以链表的方式起来。（解决哈希冲突，链表法）</li>
<li>当哈希表扩容时，我们会分配一个两倍大的新 <code>bucket</code>
数组。然后 <code>bucket</code> 从旧 <code>bucket</code> 数组增量复制到新
<code>bucket</code> 数组。</li>
<li><code>map</code> 迭代器遍历 <code>bucket</code>
数组，并按遍历顺序返回键（遍历完普通桶之后，遍历溢出桶）。</li>
<li>为了保持迭代语义，我们永远不会在它们的桶中移动键（<code>bucket</code>
内键的顺序在扩容的时候不变。如果改变了桶内键的相对顺序，键可能会返回 0
或 2 次）。</li>
<li>在扩容哈希表时，迭代器仍在旧的桶中迭代，并且必须检查新桶，检查正在迭代的
<code>bucket</code> 是否已经被迁移到新桶。</li>
</ul>
<h2 id="go-map-的整体模型">go map 的整体模型</h2>
<p>上面讲了哈希表的基本设计思路，接下来就要开始讲 go 里面
<code>map</code>
的设计与实现了。大体上其实就是上面说的样子，但是有下面几个不一样的地方：</p>
<blockquote>
<p>下文的 <code>bucket</code> 和 <code>bmap</code> 都是指的 "桶"。</p>
</blockquote>
<ul>
<li>go <code>map</code> 里面存储数据的地方是
<code>bucket</code>（桶），一个 <code>bucket</code> 可以存储
<code>8</code> 个元素，也就是说哈希冲突的时候还是会在同一个
<code>bucket</code> 中先存储。</li>
<li>如果 <code>bucket</code>
也存放不下冲突的元素了，那么会新建另外一个桶（叫做溢出桶），旧的
<code>bucket</code> 记录这个新桶的指针，旧的 <code>bucket</code>
存放不下的元素，会存放到这个溢出桶中。</li>
<li>如果溢出桶还是存放不下，那么再新建一个溢出桶，链接到上一个溢出桶中。</li>
</ul>
<p>也就是说，在 go 的 <code>map</code> 实现中，哈希计算出来的值决定了
<code>key</code> 应该存放在哪一个 <code>bucket</code> 中。</p>
<p>go <code>map</code> 的整体结构如下图：</p>
<figure>
<img src="/images/go/map/map_2_1.png" alt="go map 整体模型" />
<figcaption aria-hidden="true">go map 整体模型</figcaption>
</figure>
<ul>
<li><code>buckets</code> 记录了保存 <code>map</code> 数据的所有
<code>bucket</code>（这种下文统一称为<strong>普通桶</strong>），go
中使用 <code>bmap</code> 这个结构体来表示
<code>bucket</code>，溢出桶也是使用 <code>bmap</code> 结构体表示。</li>
<li>如果
<code>bucket</code>（普通桶）哈希冲突太多导致存放不下，会新建一个
<code>bucket</code>，在原来的 <code>bucket</code> 上会有一个指针记录新建
<code>bucket</code> 的地址，这个新 <code>bucket</code>
下文统一称为<strong>溢出桶</strong>。</li>
<li>在创建 <code>map</code>
的时候，如果我们指定的容量比较大（<code>B &gt;= 4</code>
的时候），那么会预创建一个溢出桶。</li>
</ul>
<p>也就是说，go 中解决哈希冲突的链表法，链表上的每一个元素是一个
<code>bucket</code>。go <code>map</code> 的实现里面，<strong>一个
<code>bucket</code> 可以存放 <code>8</code> 个键值对</strong>。</p>
<p>上面的 <code>bmap</code> 的数据结构如下图：</p>
<figure>
<img src="/images/go/map/map_2_2.png" alt="bmap" />
<figcaption aria-hidden="true">bmap</figcaption>
</figure>
<ul>
<li><code>bmap</code> 就是
<code>bucket</code>（桶），不管是普通的桶还是溢出的桶，都是使用
<code>bmap</code> 结构体表示。</li>
<li><code>bmap</code> 中存储数据的方式有点特别，它先存储了
<code>8</code> 个 <code>tophash</code> 值，一个 <code>tophash</code>
的大小为 1 个字节，每一个 <code>tophash</code> 记录的是
<code>bmap</code> 中每一个元素的哈希值的最高的 8 bit。</li>
<li>接下来是 <code>bmap</code> 存储的 8 个元素的 <code>key</code>，在 8
个 <code>key</code> 之后是 8 个 <code>bmap</code> 存储的值。我们会发现
<code>key</code> 和 <code>value</code> 的存储是分开的，而不是
<code>key/value</code>、<code>key/value</code> 这种方式。go
中这种分开存储的方式有一个好处是可以减少内存对齐的开销，从而更省内存。</li>
<li>最后是 <code>overflow</code>（溢出桶），如果 <code>bmap</code>
存满了，那就会新建一个溢出桶来保存新的数据，通过在旧的 <code>bmap</code>
上记录指针来记录溢出桶。</li>
</ul>
<p><code>tophash</code> 的作用是，在哈希冲突的时候，在
<code>bucket</code> 内进行查找的时候，是需要在 <code>bucket</code>
内从第一个元素遍历到最后一个元素来查找的。 如果 <code>key</code>
太大，直接比较 <code>key</code> 的话效率会比较低下，通过记录哈希值的高 8
位，我们就可以在 <code>buckeet</code> 内查找的时候，先比较哈希值的 前 8
位，这样一来，<code>map</code> 的效率受到 <code>key</code>
大小的影响就会比较小。当然哈希值的高 8
位有可能相同，在这种情况下，我们再比较一下 <code>key</code> 本身
就可以确定 <code>bucket</code>
的那个槽（<code>slot</code>/<code>cell</code>）是否是我们正在查找的那一个
<code>key</code>。</p>
<h2 id="go-map-相关数据结构">go map 相关数据结构</h2>
<p>我们大部分内容是跟下面两个结构体打交道：</p>
<ul>
<li><code>hmap</code>: <code>map</code> 的数据结构，包含了
<code>bucket</code> 的指针、<code>bucket</code>
的数量、键值对的数量等信息。</li>
<li><code>bmap</code>: 桶，存储 <code>key/value</code> 的地方</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go map 数据结构</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="type">int</span>            <span class="comment">// map 的元素数量。调用 len(map) 的时候返回此值</span></span><br><span class="line">	flags     <span class="type">uint8</span>          <span class="comment">// map 标记：iterator/oldIterator/hashWriting/sameSizeGrow</span></span><br><span class="line">	B         <span class="type">uint8</span>          <span class="comment">// 指示了当前哈希表持有的 buckets 的数量（2^B 是 bucket 的数量）</span></span><br><span class="line">	noverflow <span class="type">uint16</span>         <span class="comment">// 溢出桶的数量</span></span><br><span class="line">	hash0     <span class="type">uint32</span>         <span class="comment">// 哈希种子，计算 key 的哈希的时候会传入哈希函数</span></span><br><span class="line">	buckets   unsafe.Pointer <span class="comment">// 指向 buckets 的数组，大小为 2^B。 如果元素个数为 0 则为 nil。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 哈希表扩容的时候记录 buckets 字段。</span></span><br><span class="line">	<span class="comment">// 增量扩容时，oldbuckets 的长度是 buckets 的一半。</span></span><br><span class="line">	oldbuckets unsafe.Pointer</span><br><span class="line"></span><br><span class="line">	nevacuate <span class="type">uintptr</span>   <span class="comment">// 指示扩容进度，小于此地址的 buckets 完成迁移</span></span><br><span class="line">	extra     *mapextra <span class="comment">// 可选字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapextra 包含并非在所有 map 上都存在的字段。</span></span><br><span class="line"><span class="comment">// 下面 mapextra 注释是原文的翻译（看完了 map 的全部源码也还不是很懂这个结构体的作用，除了 nextOverflow 字段）。</span></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 如果 key 和 elem 都不包含指针并且是内联的，那么我们将 bucket type 标记为不包含指针。这避免了扫描此类 map。</span></span><br><span class="line">	<span class="comment">// 但是，bmap.overflow 是一个指针。 为了让溢出桶保持活动状态，</span></span><br><span class="line">	<span class="comment">// 我们将指向所有溢出桶的指针存储在 hmap.extra.overflow 和 hmap.extra.oldoverflow 中。</span></span><br><span class="line">	<span class="comment">// overflow 和 oldoverflow 仅在 key 和 elem 不包含指针时使用。</span></span><br><span class="line">	<span class="comment">// overflow 包含 hmap.buckets 的溢出桶。</span></span><br><span class="line">	<span class="comment">// oldoverflow 包含 hmap.oldbuckets 的溢出桶。</span></span><br><span class="line">	<span class="comment">// 间接允许在 hiter 中存储指向切片的指针。</span></span><br><span class="line">	overflow    *[]*bmap</span><br><span class="line">	oldoverflow *[]*bmap</span><br><span class="line"></span><br><span class="line">	<span class="comment">// nextOverflow 持有指向空闲溢出桶的指针。</span></span><br><span class="line">	nextOverflow *bmap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// go map 中的 bucket 结构体（实际保存 key/value 的地方）</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// tophash 通常包含此 bucket 中每个键的哈希值的最高的 8 位（1 字节）。</span></span><br><span class="line">	<span class="comment">// 如果 tophash[0] ＜ minTopHash，则 tophash[0] 为桶已迁移状态。</span></span><br><span class="line">	<span class="comment">// 这是一个长度为 8 的数组，因为一个 bucket 只能存储 8 个元素。</span></span><br><span class="line">	<span class="comment">// tophash 存储的是每一个元素的键的哈希的高 8 位。</span></span><br><span class="line">	<span class="comment">//（通过比较不同键的哈希的高 8 位可以提高 bucket 内的查找性能，因为键可能很大）</span></span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 然后是 8 个键，然后是 8 个值。（这里的 8 是代码写死的）</span></span><br><span class="line">	<span class="comment">// 注意：将所有键放在在一起，然后将所有值放在一起使代码比交替的 key/elem/key/elem/… 复杂一些，</span></span><br><span class="line">	<span class="comment">// 但它允许我们消除填充（减少内存对齐导致的内存浪费），例如 map[int64]int8，</span></span><br><span class="line">	<span class="comment">// 这种如果使用 key/elem 的方式存储则需要浪费几个字节用来对齐。</span></span><br><span class="line">	keys [bucketCnt]keytype <span class="comment">// 8 个键</span></span><br><span class="line">	values [bucketCnt]valuetype <span class="comment">// 8 个值</span></span><br><span class="line">	overflow *bmap <span class="comment">// 指向溢出桶的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>map</code> 的数据结构，需要特别说明的是，<code>bmap</code>
的源码中实际只包含了 <code>tophash</code> 字段，而后面的三个字段
<code>keys/values/overflow</code> 都是在编译期间动态添加的。这是因为
<code>map</code>
中可能存储不同类型的键值对，所以键值对占据的内存空间大小只能在编译时进行推导。
这样一来，最终的结果是，我们在 <code>map</code> 的源码中，访问
<code>key</code> 和 <code>value</code> 的时候都需要通过
<code>bmap</code> 的首地址加上偏移量来进行访问的。</p>
<p>比如获取 <code>bucket</code> 中第 <code>i</code> 个 <code>key</code>
的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br></pre></td></tr></table></figure>
<p>这行代码中，<code>add</code>
是做指针加法运算的函数，具体来说就是第一个参数的地址加上第二个参数（偏移量），得到一个我们想要的指针。
<code>dataOffset</code> 代表了 <code>bmap</code> 的 <code>keys</code>
第一个元素的偏移量，<code>i</code> 代表了我们想要获取的 <code>key</code>
在 <code>keys</code> 中的索引：</p>
<figure>
<img src="/images/go/map/map_2_3.png" alt="bmap 结构" />
<figcaption aria-hidden="true">bmap 结构</figcaption>
</figure>
<p>这样一来，我们就可以通过 <code>k</code> 这个指针来访问
<code>bucket</code> 中的 <code>key</code> 了。同样的，要访问
<code>value</code> 的方式也是类似的， 只要将
<code>dataOffset + i * uintptr(t.keysize)</code> 替换成
<code>dataOffset + bucketCnt * uintptr(t.keysize)</code> 即可。</p>
<blockquote>
<p>这种方式虽然不太优雅，但是在性能上可以达到最优。</p>
</blockquote>
<h2 id="bmap桶源码剖析">bmap（桶）源码剖析</h2>
<p><code>bmap</code> 就是保存键值对的地方，但是它本身的方法并不多：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bucket 是否已经完成迁移</span></span><br><span class="line"><span class="comment">// b 是 bucket 的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuated</span><span class="params">(b *bmap)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	h := b.tophash[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> h &gt; emptyOne &amp;&amp; h &lt; minTopHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 b 的溢出桶</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span></span> overflow(t *maptype) *bmap &#123;</span><br><span class="line">	<span class="comment">// bmap 数据结构的最后一个指针就是指向溢出桶的指针</span></span><br><span class="line">	<span class="keyword">return</span> *(**bmap)(add(unsafe.Pointer(b), <span class="type">uintptr</span>(t.bucketsize)-goarch.PtrSize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 b 的溢出桶</span></span><br><span class="line"><span class="comment">// bmap 数据结构的最后一个指针指向溢出桶</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span></span> setoverflow(t *maptype, ovf *bmap) &#123;</span><br><span class="line">	*(**bmap)(add(unsafe.Pointer(b), <span class="type">uintptr</span>(t.bucketsize)-goarch.PtrSize)) = ovf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 b 中保存 keys 的指针（指向了桶内的第一个 key）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span></span> keys() unsafe.Pointer &#123;</span><br><span class="line">	<span class="keyword">return</span> add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>ev</code> 中用到了两个常量，在 <code>bucket</code> 的
<code>tophash</code> 里面，会通过下面几个标志来记录桶里面槽的状态：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个 cell 是空的，并且在更高的索引或溢出处没有更多的非空 cell。</span></span><br><span class="line">emptyRest = <span class="number">0</span></span><br><span class="line"><span class="comment">// 这个 cell 是空的</span></span><br><span class="line">emptyOne = <span class="number">1</span></span><br><span class="line"><span class="comment">// key/elem 有效。 entry 已被迁移到较大的哈希表的前半部分（扩容了）。</span></span><br><span class="line">evacuatedX = <span class="number">2</span></span><br><span class="line"><span class="comment">// 同上，但迁移到大的哈希表的后半部分（扩容了）。</span></span><br><span class="line">evacuatedY = <span class="number">3</span></span><br><span class="line"><span class="comment">// cell 是空的，bucket 已经被迁移了</span></span><br><span class="line">evacuatedEmpty = <span class="number">4</span></span><br><span class="line"><span class="comment">// 正常填充单元格的最小 tophash。</span></span><br><span class="line">minTopHash = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>为了跟正常的 <code>tophash</code> 区分开来，如果计算出来的
<code>tophash</code> 小于 <code>minTopHash</code>，会将计算出来的
<code>tophash</code> 加上 <code>minTopHash</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tophash 计算 hash 的 tophash 值。</span></span><br><span class="line"><span class="comment">// 这是一个字节的大小的。（hash 最高的 8 位）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tophash</span><span class="params">(hash <span class="type">uintptr</span>)</span></span> <span class="type">uint8</span> &#123;</span><br><span class="line">	<span class="comment">// top 本质上就是 hash 的前面 8 个字节（goarch.PtrSize*8 - 8，左移位数：指针的字节大小 - 8 字节）</span></span><br><span class="line">	top := <span class="type">uint8</span>(hash &gt;&gt; (goarch.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">	<span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">		top += minTopHash</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，<strong>通过 <code>tophash</code>
这一个字节就可以记录桶里面槽的状态了，非常节省空间。</strong></p>
<h2 id="map-的创建的实现">map 的创建的实现</h2>
<p>我们已经了解了哈希表的基本工作机制了，现在就让我们来深入了解一下 go
里 <code>map</code> 的实现，先是 <code>map</code> 的创建，
<code>map</code> 的创建是通过 <code>makemap()</code>
函数实现的（对应我们写的代码是
<code>make(map[int]int, 10)</code>），<code>map</code>
的创建步骤如下：</p>
<ol type="1">
<li>计算 <code>map</code> 所需内存，判断是否在一个合理范围之内。</li>
<li>使用 <code>new</code> 初始化 <code>hmap</code> 结构体。</li>
<li>生成随机哈希种子。</li>
<li>计算出一个最小的 <code>B</code>，也就是根据用户传递给
<code>make</code> 的第二个参数算出一个最小的 <code>B</code>
的值，最终桶的数量为 <code>2^B</code> 个。</li>
<li>如果 <code>B</code> 大于 <code>0</code>，则给哈希表的
<code>buckets</code> 分配内存。</li>
<li>最后，返回新创建好的 <code>hmap</code>。</li>
</ol>
<p>下文在寻址过程中，大量使用了指针的运算，所以如果对
<code>unsafe.Pointer</code>
比较熟悉的话，看起来会比较轻松，如果不熟悉也没关系，可以看看我另外一篇文章《深入理解
go unsafe》。</p>
<h3 id="makemap-实现">makemap 实现</h3>
<p><code>makemap</code> 具体源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makemap 是 make(map[k]v, hint) 的实现，创建一个 map。</span></span><br><span class="line"><span class="comment">// 如果编译器可以确定 map 或者第一个 bucket 可以在栈上创建，h 和/或 bucket 可能为 non-nil。</span></span><br><span class="line"><span class="comment">// 如果 h != nil，map 可以直接在 h 中创建。</span></span><br><span class="line"><span class="comment">// 如果 h.buckets != nil，buckets 指针指向的那个元素可以作为第一个 bucket。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">	<span class="comment">// 计算所需要的内存大小</span></span><br><span class="line">	mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">	<span class="comment">// 如果溢出或者超出最大分配内存，则设置 hint = 0；</span></span><br><span class="line">	<span class="comment">// 这样的话，B 也会等于 0；</span></span><br><span class="line">	<span class="comment">// 则最终的 map 只会有一个 bucket（2^B = 1）</span></span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">		hint = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化 hmap（分配 hmap 结构体本身所需要的内存）</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = <span class="built_in">new</span>(hmap)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 生成一个随机的哈希种子</span></span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据传入的 hint，计算出需要的最小桶数量。</span></span><br><span class="line">	<span class="comment">// 实际上是计算 B 的大小，桶的数量都是运行时通过 2^B 计算的。</span></span><br><span class="line">	B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 如果 hint 导致超过了负载因子，则将 B 加 1，一直加到小于负载因子。</span></span><br><span class="line">	<span class="comment">// 简单来说就是：hint / (2^B) &gt; 负载因子，也就是 hint 个键值对放到所有桶中，</span></span><br><span class="line">	<span class="comment">// 每个桶中元素数量大于负载因子（6.5）的时候，则将 B 加 1。</span></span><br><span class="line">	<span class="comment">// 注：map 扩容的时候也是这个判断标准。</span></span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配初始哈希表。</span></span><br><span class="line">	<span class="comment">// 如果 B==0，则稍后（在mapassign中）延迟分配桶字段。</span></span><br><span class="line">	<span class="comment">// 若 hint 较大，则清零此内存可能需要一段时间。</span></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">		<span class="comment">// 初始化 buckets（分配 buckets 所需要的内存）</span></span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="comment">// 如果 hint 比较大，则会预先分配溢出桶，记录到 extra 字段中。</span></span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="overloadfactor-实现">overLoadFactor 实现</h3>
<p>这里面有一个比较重要的函数，那就是
<code>overLoadFactor</code>，这个函数用来判断某一个数量是否超过
<code>map</code> 的负载因子，如果超过，那就需要扩容了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overLoadFactor 报告放置在 2^B 个桶中的键值对数量是否超过负载因子。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>count &gt; bucketCnt</code>，前半部分判断很简单，就是判断数量一个桶能不能放得下。一个桶就能装下所有数据的话，根本就不用计算了，肯定没超过负载因子。</li>
<li>后半部分判断翻译过来是：<code>桶数量 * 负载因子(6.5) &lt; 总键值对数量</code>，意味着平均每个桶存储的元素个数大于
<code>6.5</code> 了，也就是说超过了负载因子了。</li>
<li>在其他函数中，<strong>判断是否超过负载因子的时候都是使用上面这个函数</strong>。</li>
<li><code>loadFactorNum</code> 和 <code>loadFactorDen</code>
是预定义的变量，它们相除就是负载因子 <code>6.5</code>。</li>
<li><code>bucketShift(B)</code> 很简单，就是 <code>2^B</code>。</li>
</ul>
<h3 id="makebucketarray-实现">makeBucketArray 实现</h3>
<p>在创建 <code>map</code> 的时候，使用了 <code>makeBucketArray</code>
来给 <code>map</code> 的桶分配内存，<code>makeBucketArray</code>
实现步骤如下：</p>
<ol type="1">
<li>如果判断到
<code>B &gt;= 4</code>，也就是初始化时需要分配的桶数量大于等于
<code>2^4 = 16</code> 的时候，则会预先分配溢出桶，分配的溢出桶个数为
<code>2^(b-4)</code> 个。</li>
<li>接着，给 <code>map</code> 的桶（<code>buckets</code>
字段）分配内存（包含了普通桶和溢出桶，普通桶和溢出桶的内存一次性分配，溢出桶的内存在普通桶后面）。</li>
<li>最后，判断到需要分配溢出桶的话（<code>B &gt;= 4</code>），则将溢出桶的指针写入到最后一个普通桶的
<code>overflow</code> 字段。</li>
</ol>
<p>分配 <code>buckets</code> 内存的两种情况：</p>
<ol type="1">
<li>如果 <code>B &lt; 4</code>，那么分配内存的过程很简单，就是分配
<code>buckets</code>
所需要的内存，也就是分配普通桶所需要的内存就足够了，如下图：</li>
</ol>
<figure>
<img src="/images/go/map/map_3_1.png" alt="makeBucketArray 1" />
<figcaption aria-hidden="true">makeBucketArray 1</figcaption>
</figure>
<ol start="2" type="1">
<li>如果
<code>B &gt;= 4</code>，那么分配内存的过程就相对复杂，会预先分配一部分溢出桶。在后面需要创建溢出桶的时候，就会先使用这时候创建的溢出桶，而不是直接新建，如下图：</li>
</ol>
<figure>
<img src="/images/go/map/map_3_2.png" alt="makeBucketArray 2" />
<figcaption aria-hidden="true">makeBucketArray 2</figcaption>
</figure>
<p>说明：</p>
<ul>
<li>分配 <code>buckets</code>
所需要的内存的时候，会分配一部分溢出桶所需要的内存，普通桶和溢出桶的内存是连续的，分配给溢出桶的内存就在普通桶的后面。</li>
<li>在 <code>makemap</code> 中会新建 <code>mapextra</code> 结构体，用
<code>nextOverflow</code>
字段来保存溢出桶的指针，指向第一个溢出桶的位置。</li>
<li>最后一个溢出桶的 <code>overflow</code>
指针（指向溢出桶的指针），指向了 <code>buckets</code>
入口，这里并不是说将第一个普通桶作为最后一个溢出桶的溢出桶，而是一个标记作用。因为前面的溢出桶的
<code>overflow</code> 字段都是 <code>nil</code>，而最后一个溢出桶的
<code>overflow</code> 不是
<code>nil</code>，这样一来，我们通过判断溢出桶的 <code>overflow</code>
是否为 <code>nil</code>
就可以知道是否是最后一个溢出桶。如果是最后一个溢出桶，那么将
<code>map</code> 里面的 <code>extra.nextOverflow</code> 字段设置为
<code>nil</code>，表示预分配的溢出桶用完了，后面如果再需要溢出桶的时候，就只能直接
<code>new</code> 一个了。</li>
<li><code>buckets</code> 指针下面的普通桶和溢出桶所需要的内存大小都是
<code>t.bucketsize</code>，也就是 <code>bmap</code>
所需要的内存大小（当然是内存对齐之后的）。</li>
</ul>
<p>具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makeBucketArray 初始化 map bucket 底层的数组（分配 buckets 的内存）。</span></span><br><span class="line"><span class="comment">// 1&lt;&lt;b 是要分配的最小存储桶数。</span></span><br><span class="line"><span class="comment">// dirtyalloc 应该是 nil（不为 nil，表示清空 map），或者是 makeBucketArray 之前使用相同的 t 和 b 参数分配的桶数组。</span></span><br><span class="line"><span class="comment">// 如果 dirtyalloc 为 nil，将分配一段新的内存；否则将清除 dirtyalloc 指向的内存，将其作为新分配的内存。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// t：底层表示 map 的类型</span></span><br><span class="line"><span class="comment">// b：bucket 的大小为 2^b</span></span><br><span class="line"><span class="comment">// dirtyalloc: 不为 nil 表示要清空，用于 mapclear 函数。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// buckets：正常桶数组入口</span></span><br><span class="line"><span class="comment">// nextOverflow：溢出桶数组入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;</span><br><span class="line">	<span class="comment">// bucket 数量 = 1 &lt;&lt; b</span></span><br><span class="line">	base := bucketShift(b)</span><br><span class="line">	nbuckets := base</span><br><span class="line">	<span class="comment">// 对于小的 b，溢出桶不太可能。避免计算开销。</span></span><br><span class="line">	<span class="comment">// 桶的数量小于 2^4 时候，由于数据较少、使用溢出桶的可能性较低，</span></span><br><span class="line">	<span class="comment">// 会省略创建溢出桶的过程以减少额外开销。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 但是大于等于 2^4 的时候，使用到溢出桶的可能性就会比较大，所以需要预先分配溢出桶。</span></span><br><span class="line">	<span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">		<span class="comment">// 大于等于 2^4 的时候，额外创建 2^(B-4) 个溢出桶。</span></span><br><span class="line">		nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">		sz := t.bucket.size * nbuckets <span class="comment">// 溢出桶所需要的内存大小</span></span><br><span class="line">		up := roundupsize(sz)          <span class="comment">// 计算需要的内存大小</span></span><br><span class="line">		<span class="keyword">if</span> up != sz &#123;</span><br><span class="line">			<span class="comment">// 分配的内存与实际需要的内存不一样，</span></span><br><span class="line">			<span class="comment">// 可能会比 sz 大一点，重新计算 nbuckets。</span></span><br><span class="line">			<span class="comment">// 下面的 nbuckets 才是最终的 bucket 数量（普通桶 + 溢出桶的数量）</span></span><br><span class="line">			nbuckets = up / t.bucket.size</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// buckets 所在的内存初始化/清空（mapclear）</span></span><br><span class="line">	<span class="keyword">if</span> dirtyalloc == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 创建新的 bucket 数组</span></span><br><span class="line">		buckets = newarray(t.bucket, <span class="type">int</span>(nbuckets))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 清空原有的内存</span></span><br><span class="line">		buckets = dirtyalloc</span><br><span class="line">		<span class="comment">// buckets 所需要的总内存大小（单位：字节）</span></span><br><span class="line">		size := t.bucket.size * nbuckets</span><br><span class="line">		<span class="comment">// 清空 buckets 开始的 size 字节大小的内存</span></span><br><span class="line">		<span class="keyword">if</span> t.bucket.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 有指针</span></span><br><span class="line">			memclrHasPointers(buckets, size)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			memclrNoHeapPointers(buckets, size)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上面 b &gt;= 4 的情况</span></span><br><span class="line">	<span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">		<span class="comment">// 处理一下预先分配的溢出桶。</span></span><br><span class="line">		nextOverflow = (*bmap)(add(buckets, base*<span class="type">uintptr</span>(t.bucketsize)))  <span class="comment">// buckets 和溢出桶内存是相邻的，计算第一个溢出桶的指针</span></span><br><span class="line">		last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="type">uintptr</span>(t.bucketsize))) <span class="comment">// 最后一个溢出桶</span></span><br><span class="line">		last.setoverflow(t, (*bmap)(buckets))                             <span class="comment">// 最后一个溢出桶的 overflow 指针链接到第一个普通桶</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回普通桶、溢出桶的指针</span></span><br><span class="line">	<span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map-定位-key-的实现">map 定位 key 的实现</h2>
<p>我们从上面的讲解中应该很清楚 <code>map</code> 中 <code>bucket</code>
这个数据结构了（上面的 <code>bmap</code>
那个图），在做查找、修改、删除操作的时候， 都需要先根据 <code>key</code>
找到具体的键值对保存在哪一个 <code>bucket</code> 以及
<code>bucket</code> 中的哪一个位置，所以这个操作其实是非常关键的。
在开始下文之前，就先来讲讲 <code>map</code> 中是如何定位一个
<code>key</code> 的。</p>
<p>其实定位的过程比较简单，假设现在要查找一个 <code>key</code>，那定位
<code>key</code> 的大概步骤如下：</p>
<ol type="1">
<li>计算 <code>hash</code>: 根据 <code>key</code> 计算出其哈希值
<code>hash</code>。</li>
<li>计算 <code>bucket</code>: 哈希值对 <code>buckets</code>
长度取模（<code>hash % len(buckets)</code>），不过实际实现的时候使用了一种优化的方式，位运算（<code>hash &amp; (2^B - 1)</code>），也就是由哈希值的最低
<code>B</code> 位来决定 <code>key</code> 最终使用哪一个
<code>bucket</code>（结果跟直接取模不一样，但是思想一样，都能保证得出的结果落在
<code>len(buckets)</code> 范围内）。</li>
<li>遍历 <code>bucket</code>（先是普通桶）里面的每一个槽（有 8
个），比较哈希值的最高 8 位（8 bit，也就是
<code>tophash</code>）是否相等，如果相等，则获取存储在
<code>bucket</code> 里面的 <code>key</code>，跟我们需要定位的
<code>key</code> 做比较，如果相等，则说明已经找到了
<code>key</code>，如果 <code>key</code> 不相等，则继续遍历下一个槽，直到
<code>bucket</code> 中所有的槽都被遍历完毕。</li>
<li>如果 <code>bucket</code> 里面的 8
个槽都遍历完了，仍然没有找到我们需要找的 <code>key</code>。那么会从
<code>bucket</code>
的溢出桶去查找，溢出桶内的查找过程跟普通桶内的查找过程是一样的。</li>
<li>如此遍历，直到所有溢出桶都遍历完（在找不到的情况下才会遍历
<code>bucket</code> （普通桶）所有的溢出桶）。</li>
</ol>
<p>这个查找过程可以表示为下图：</p>
<figure>
<img src="/images/go/map/map_4_1.png" alt="key 定位" />
<figcaption aria-hidden="true">key 定位</figcaption>
</figure>
<p>注意：<strong>确定一个 <code>key</code> 需要 <code>tophash</code> 和
<code>key</code> 都相等，如果 <code>tophash</code> 相等而
<code>key</code> 不相等，则需要继续比较 <code>bucket</code>
中其他的槽。</strong></p>
<h2 id="map-读取数据的实现">map 读取数据的实现</h2>
<p>从 <code>map</code>
中读取某一个键的方法主要有三个：<code>mapaccess1</code>、<code>mapaccess2</code>、<code>mapaccessK</code>，这三个方法的代码其实是大同小异的，所以这里只拿
<code>mapaccessK</code> 来讲解。</p>
<p>这三个方法的不同之处在于：</p>
<ul>
<li><code>mapaccess1</code> 只返回 <code>key</code> 对应的值，对应
<code>v := map["k"]</code> 这种写法。</li>
<li><code>mapaccess2</code> 返回 <code>key</code>
对应的值，以及是否存在的标志，对应 <code>v, ok := map["k"]</code>
这种写法。</li>
<li><code>mapaccessK</code> 用于遍历 <code>map</code> 的时候，返回
<code>key</code> 和 <code>value</code>，对应
<code>for k, v := range map &#123;&#125;</code> 这种写法（在迭代的时候在
<code>mapiternext</code> 里面调用）。</li>
</ul>
<h3 id="mapaccessk-的查找步骤"><code>mapaccessK</code> 的查找步骤</h3>
<p><code>mapaccessK</code>
的查找步骤大概就是上一个图说的，只不过下面的描述更加详细一点（em...
有点重复了）：</p>
<ul>
<li>判断 <code>map</code> 是否为空，为空直接返回</li>
<li>计算 <code>key</code> 对应的哈希值 =&gt; <code>hash</code></li>
<li>计算桶的掩码 =&gt; <code>m</code>，<code>hash &amp; m</code> 得到
<code>bucket</code> 的索引</li>
<li>判断是否正在扩容，如果是，需要判断 key
对应的桶的数据是否已经被迁移到新的桶里面：
<ul>
<li>如果是，则需要从新的桶里面查找。</li>
<li>如果还没有被迁移，则需要从旧桶中读取。</li>
</ul></li>
<li>计算 <code>tophash</code> =&gt; <code>top</code>（也就是
<code>hash</code> 的最高 8 位）</li>
<li>遍历找到的桶的每一个槽（<code>slot/cell</code>）
<ul>
<li>比较 <code>tophash</code> 是否相等</li>
<li>如果不等，判断桶后面是否都没有数据了（<code>b.tophash[i] == emptyRest</code>）</li>
<li>如果没有数据了，跳出循环 =&gt; 找不到 <code>key</code> 对应的值</li>
<li>如果还有数据，则继续遍历下一个槽</li>
</ul></li>
<li>如果找到一个槽的 <code>tophash</code> 跟上面计算的
<code>tophash</code> 相等，则比较 <code>key</code> 是否相等
<ul>
<li>是，则返回对应的值（<strong><code>tophash</code> 和 <code>key</code>
都相等，则表明找到了相应的
<code>key</code>，返回对应的值</strong>）。</li>
<li>否，继续遍历下一个槽（依然是先比较
<code>tophash</code>，<code>tophash</code> 相等则再比较 <code>key</code>
是否相等）</li>
</ul></li>
<li>溢出桶也找不到，则返回零值（及是否找到的标志）。</li>
</ul>
<h3 id="mapaccessk-的实现"><code>mapaccessK</code> 的实现</h3>
<p>对于整型的键值的 <code>map</code>，go
里面有针对优化的实现，但其实代码逻辑上都是差不多的，所以不细说了。下面来看看
<code>mapaccessK</code> 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在迭代 map 的时候，返回键值对。</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// t: map 类型元信息（记录了 map 中的 key/value 的类型等信息，比如 key 的大小，可用于计算内存偏移）</span></span><br><span class="line"><span class="comment">// h: map 结构体类型（也就是实际的哈希表类型）</span></span><br><span class="line"><span class="comment">// key: 需要查找的 key</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 第一个返回值：当前遍历到的 key 的指针</span></span><br><span class="line"><span class="comment">// 第二个返回值：当前遍历到的 key 对应的值的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccessK</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, unsafe.Pointer) &#123;</span><br><span class="line">	<span class="comment">// map 是空的</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据 key 和 hash0 计算 hash</span></span><br><span class="line">	hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">	<span class="comment">// hash 的掩码，类似 IP 的掩码</span></span><br><span class="line">	<span class="comment">//（比如，假设 B = 3，一共有 8 个元素，索引为 0～7，那么掩码 m 表示为二进制就是 111）。</span></span><br><span class="line">	<span class="comment">// 用于跟 hash 值做 &amp; 运算（hash &amp; m），得到 hash 对应 bucket 的索引（0～m）</span></span><br><span class="line">	m := bucketMask(h.B)</span><br><span class="line">	<span class="comment">// 根据 hash 计算 bucket 地址，b 是 hash 匹配到的 bucket</span></span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	<span class="comment">// 正在扩容，如果 bucket 还没迁移到新的地址，则需要从 oldbuckets 中访问</span></span><br><span class="line">	<span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 不是等量扩容，需要从旧桶中读取，所以 m 要移除最高位（右移一位）</span></span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			<span class="comment">// 不是等量扩容，则将 m 除以 2，因为是 2 倍扩容，</span></span><br><span class="line">			<span class="comment">// 所以 buckets 的大小为 oldbuckets 长度的 2 倍，</span></span><br><span class="line">			<span class="comment">// 除以 2 才是旧的桶数量</span></span><br><span class="line">			m &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// key 在 oldbuckets 中的地址</span></span><br><span class="line">		oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">		<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">			<span class="comment">// b 尚未迁移到新的 buckets 中，还在 oldbuckets 中</span></span><br><span class="line">			<span class="comment">// 则需要从旧桶中查找</span></span><br><span class="line">			b = oldb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算 tophash</span></span><br><span class="line">	top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="comment">// 从 bucket 中查找，一个 bucket 可以存储的元素个数是 bucketCnt，也就是 8</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="comment">// tophash 不匹配，肯定不是这个槽</span></span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="comment">// bucket 剩余的槽是空的，不用再找了，跳出循环</span></span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 继续比较下一个槽</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// tophash 匹配</span></span><br><span class="line">			<span class="comment">// 接下来将这个槽的 key 取出来</span></span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="comment">// key 是指针类型</span></span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 比较 key 跟 k 是否相等</span></span><br><span class="line">			<span class="keyword">if</span> t.key.equal(key, k) &#123;</span><br><span class="line">				<span class="comment">// 相等则读取对应的值（表示找到了匹配的 key 了）</span></span><br><span class="line">				e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">				<span class="comment">// 值是指针类型</span></span><br><span class="line">				<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">					e = *((*unsafe.Pointer)(e))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 找到了，返回键值对</span></span><br><span class="line">				<span class="keyword">return</span> k, e</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 注意：执行到这里，说明 tophash 相等，</span></span><br><span class="line">			<span class="comment">// 但是 key 不匹配，仍然需要继续遍历。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 普通桶和溢出桶的所有槽都找不到，返回 nil</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，如果在扩容的过程中查找，会先判断数据是否已经被迁移到新桶，如果还没有被迁移，则需要从旧的桶中查找。</p>
<h3 id="mapaccessk-关键代码"><code>mapaccessK</code> 关键代码</h3>
<ol type="1">
<li><code>bucket</code> 的定位代码</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := bucketMask(h.B)</span><br><span class="line"><span class="comment">// b 就是定位到的 bucket 所在的内存地址</span></span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br></pre></td></tr></table></figure>
<p><code>bucket</code>
索引（<code>hash &amp; m</code>）的定位方式如下：</p>
<figure>
<img src="/images/go/map/map_4_2.png" alt="bucket 定位1" />
<figcaption aria-hidden="true">bucket 定位1</figcaption>
</figure>
<p>因为 <code>buckets</code> 是指向 <code>bmap</code>
的指针数组，所以我们可以通过 <code>buckets</code> 加上
<code>bucket</code> 的索引，就可以定位到 <code>bucket</code>
的内存地址。 因为每一个 <code>bmap</code> 的大小是
<code>t.bucketsize</code>，所以 <code>bucket</code> 的索引乘以
<code>t.bucketsize</code>，也即
<code>(hash&amp;m)*uintptr(t.bucketsize)</code>，就是
<code>bucket</code> 的相对偏移量。 然后 <code>buckets</code> 的地址加上
<code>bucket</code> 的相对偏移量，就可以定位到 <code>bucket</code>
的内存地址。</p>
<figure>
<img src="/images/go/map/map_4_3.png" alt="bucket 定位2" />
<figcaption aria-hidden="true">bucket 定位2</figcaption>
</figure>
<p>我们需要注意的是，我们计算得到 <code>bucket</code>
的指针后，需要将其转换为 <code>bmap</code>
类型的指针，才能进行后续的操作。</p>
<p>然后 <code>key</code> 和 <code>value</code>
也是通过类似的指针运算来定位的。需要说明的是：</p>
<ul>
<li><code>add</code> 函数是做指针算术运算的函数，具体来说就是
<code>add(a, b)</code> 就是 <code>a</code> 地址加上 <code>b</code>
的偏移量，返回的是 <code>unsafe.Pointer</code> 类型的指针。</li>
<li><code>unsafe.Pointer(b)</code> 是 <code>bucket</code>
的内存地址</li>
<li><code>dataOffset</code> 是 <code>bucket</code> 中第一个
<code>key</code> 的地址偏移量，</li>
<li><code>t.keysize</code> 是 <code>key</code> 的大小</li>
<li><code>t.elemsize</code> 是 <code>map</code> 值的大小</li>
<li><code>bucketCnt</code> 是 <code>bucket</code> 中槽的数量（8
个，预定义的常量）。</li>
</ul>
<p>然后大家可以结合上面的 <code>bmap</code>
内存布局图来理解上面指针计算的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 bucket 中的第 i 个 key。</span></span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"><span class="comment">// 读取 bucket 中的第 i 个 value</span></span><br><span class="line">e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><code>b.tophash[i] == emptyRest</code> 判断的理解</li>
</ol>
<figure>
<img src="/images/go/map/map_4_4.png" alt="emptyRest" />
<figcaption aria-hidden="true">emptyRest</figcaption>
</figure>
<p><code>emptyRest</code> 是一个比较特殊的标记，它表示
<code>bucket</code> 中的后续槽都是空的。 在 <code>map</code>
删除元素的时候，会判断后面还有没有元素，如果没有元素的话，就会将
<code>b.tophash[i]</code> 设置为 <code>emptyRest</code>。
这样在查找的时候，就可以通过 <code>b.tophash[i] == emptyRest</code>
来判断后面的槽都是空的，就不需要继续遍历了。</p>
<ol start="3" type="1">
<li><code>indirectkey</code> 和 <code>indirectelem</code> 的理解</li>
</ol>
<p>我们发现上面读取 <code>key</code> 和 <code>value</code>
的时候有一个比较特别的操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">    k = *((*unsafe.Pointer)(k))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">    e = *((*unsafe.Pointer)(e))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信不少读者第一次看到这几行代码的时候会跟我一样有点懵逼，从
<code>maptype</code> 的定义我们可以看出一点端倪：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mt *maptype)</span></span> indirectkey() <span class="type">bool</span> &#123; <span class="comment">// store ptr to key instead of key itself</span></span><br><span class="line">	<span class="keyword">return</span> mt.flags&amp;<span class="number">1</span> != <span class="number">0</span> <span class="comment">// 存储了 key 的指针，而不是 key 本身</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mt *maptype)</span></span> indirectelem() <span class="type">bool</span> &#123; <span class="comment">// store ptr to elem instead of elem itself</span></span><br><span class="line">	<span class="keyword">return</span> mt.flags&amp;<span class="number">2</span> != <span class="number">0</span> <span class="comment">// 存储了 elem 的指针，而不是 elem 本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，就是 go 底层在有时候会将 <code>key</code> 和
<code>value</code> 保存为指针，而不是直接保存 <code>key</code> 和
<code>value</code> 本身。 这样一来，go 里面的 <code>map</code>
操作就需要根据 <code>key</code> 和 <code>value</code>
的类型来判断是否需要进行指针解引用，也就是取出实际的 <code>key</code> 和
<code>value</code>。</p>
<h2 id="map-写入和修改的设计与实现">map 写入和修改的设计与实现</h2>
<p>在 go 中，<code>map</code> 的写入和修改都是通过
<code>mapassign</code>
函数来实现的，因为写入和修改本质上是同一个操作，都是找到对应的
<code>key</code>，然后修改对应的值。</p>
<h3 id="mapassign-的实现步骤"><code>mapassign</code> 的实现步骤</h3>
<ol type="1">
<li>计算 <code>key</code> 的 <code>hash</code> 值。</li>
<li>如果 <code>buckets</code> 还没有初始化，则进行分配内存。</li>
<li>计算出 <code>bucket</code> 的索引。</li>
<li>如果正在扩容，则迁移当前即将要操作的
<code>bucket</code>（也就是上一步计算出来的索引对应的
<code>bucket</code>）。</li>
<li>计算 <code>tophash</code>。</li>
<li>遍历 <code>bucket</code> 中的槽，记录下第一个空的槽的
<code>tophash</code> 索引指针、<code>key</code> 指针，<code>value</code>
指针。如果最后找不到 <code>key</code> 的时候，会插入到这里。</li>
<li>如果 <code>bucket</code> 的所有桶都找不到
<code>key</code>，则判断是否需要扩容，需要的话就进行扩容，然后再执行 6
的操作。</li>
<li>另外一种情况，不需要扩容，而且 <code>bucket</code>
以及它的溢出桶也满了，则需要新建溢出桶来保存 <code>key</code></li>
<li>最后，将 <code>tophash/key/value</code> 插入到需要
<code>bucket</code> 第一个空的槽。又或者如果已经存在，对
<code>value</code> 进行更新。</li>
</ol>
<h3 id="mapassign-图解"><code>mapassign</code> 图解</h3>
<p>可以分两种情况：</p>
<ol type="1">
<li>普通桶和溢出桶都找不到 <code>key</code> 的情况下，将
<code>key</code> 插入桶中第一个空的槽</li>
</ol>
<figure>
<img src="/images/go/map/map_5_1.png" alt="map_5_1" />
<figcaption aria-hidden="true">map_5_1</figcaption>
</figure>
<ol start="2" type="1">
<li>在 <code>bucket</code> 中找到了
<code>key</code>，则会对其进行更新</li>
</ol>
<figure>
<img src="/images/go/map/map_5_2.png" alt="map_5_2" />
<figcaption aria-hidden="true">map_5_2</figcaption>
</figure>
<p>对于 <code>key</code> 和 <code>value</code>
的存储，有以下两种情况：</p>
<ol type="1">
<li>直接保存在 <code>bucket</code> 中：</li>
</ol>
<p>这样在我们需要修改 <code>key</code>/<code>value</code> 的时候，通过
<code>bucket</code> 加上 <code>索引 * keysize/valuesize</code>
就可以得到对应键值存储的实际内存。</p>
<figure>
<img src="/images/go/map/map_5_4.png" alt="map_5_4" />
<figcaption aria-hidden="true">map_5_4</figcaption>
</figure>
<ol start="2" type="1">
<li>在 <code>bucket</code> 中保存的是 <code>key/value</code>
的内存地址（<code>unsafe.Pointer</code>）类型</li>
</ol>
<p>这样如果我们需要修改/读取实际的键值的时候，就需要先从
<code>bucket</code>
中获取这个指针，然后解引用得到实际存储键值的内存指针。</p>
<figure>
<img src="/images/go/map/map_5_3.png" alt="map_5_3" />
<figcaption aria-hidden="true">map_5_3</figcaption>
</figure>
<p>注意：在我们做如下运算的时候（假设 <code>bucket</code> 没有存储实际的
<code>key</code>，而是存储了 <code>key</code> 的指针）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br></pre></td></tr></table></figure>
<p>得到的结果是，指向 <code>keys[i]</code>（也就是第 <code>i</code> 个
<code>key</code>）的指针（<code>unsafe.Pointer</code> 类型）。 如果
<code>key</code> 保存在 <code>bucket</code>
中，通过这个指针我们就可以读写 <code>key</code> 了。
否则，表示这个指针指向的内存存储的只是一个指针，如果我们需要修改实际的
<code>key</code>， 就需要通过 <code>key</code>
指针（<code>A</code>）拿到这里存储的指针（<code>B</code>），然后再通过
<code>B</code> 来修改实际的 <code>key</code>。</p>
<figure>
<img src="/images/go/map/map_5_5.png" alt="map_5_5" />
<figcaption aria-hidden="true">map_5_5</figcaption>
</figure>
<blockquote>
<p>对 <code>value</code> 的读写同理。</p>
</blockquote>
<h3 id="mapassign-源码剖析"><code>mapassign</code> 源码剖析</h3>
<blockquote>
<p>扩容的操作后面会有解析，这一节就先不细说了。</p>
</blockquote>
<p>这个函数的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 功能：插入 key 或者修改 map 中的 key</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// t：map 类型元信息</span></span><br><span class="line"><span class="comment">// h：map 结构体（实际保存键值对的地方）</span></span><br><span class="line"><span class="comment">// key：我们要修改或者插入的 key</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 只有一个，那就是我们插入或者修改之后的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;assignment to entry in nil map&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 并发写，直接报错</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算 key 的哈希值（是一个无符号整数）</span></span><br><span class="line">	hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在调用 t.hasher 之后设置 hashWriting，</span></span><br><span class="line">	<span class="comment">// 因为 t.hasher 可能会 panic，在这种情况下，我们实际上还没有进行写操作。</span></span><br><span class="line">	<span class="comment">// 写标记。（如果读操作发现有写标志则会报错）</span></span><br><span class="line">	h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 buckets 是空，则新建一个 bucket</span></span><br><span class="line">	<span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">		h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="comment">// bucket 指示第几个 bucket（命名貌似有点不合适）</span></span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">	<span class="comment">// 正在扩容的话，则将 bucket 迁移到新桶</span></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		growWork(t, h, bucket)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// b 为即将要写入的 bucket</span></span><br><span class="line">	b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	<span class="comment">// 计算 key 的 tophash</span></span><br><span class="line">	top := tophash(hash)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> inserti *<span class="type">uint8</span>         <span class="comment">// 要插入的 tophash 地址</span></span><br><span class="line">	<span class="keyword">var</span> insertk unsafe.Pointer <span class="comment">// 要插入的键地址</span></span><br><span class="line">	<span class="keyword">var</span> elem unsafe.Pointer    <span class="comment">// 要插入的值地址</span></span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 循环 bucket 的槽</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="comment">// tophash 不匹配，并且当前槽为空，则记录要插入的位置（找不到 key 的时候，最后会插入到这里）</span></span><br><span class="line">				<span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">					inserti = &amp;b.tophash[i]</span><br><span class="line">					insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">					elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">					<span class="comment">// 为什么找到了可以插入的地方，不中断循环？</span></span><br><span class="line">					<span class="comment">// 原因是，这个函数是寻找已经存在的 key 的（插入和修改都是用这个函数），</span></span><br><span class="line">					<span class="comment">// 如果对应的 key 保存到了后面的槽里面的话，这里直接中断循环就是不对的。</span></span><br><span class="line">					<span class="comment">// 因为在这种情况下，理应更新后面的那个槽。</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// bucket 没有找到对应的 key，同时 bucket 中剩余的槽都是空的。</span></span><br><span class="line">				<span class="comment">// （这意味着 map 中找不到 key，需要插入这个 key 了）</span></span><br><span class="line">				<span class="comment">// 中止对 bucket 里面槽的遍历。</span></span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 虽然找到了空闲的槽，但还是要查看 bucket 中的其他槽，看 key 是否已经存在。</span></span><br><span class="line">				<span class="comment">// （如果存在的话，修改 key 对应的值就可以了，当然这个函数里面不会修改，而是返回值的地址，从函数外部修改）</span></span><br><span class="line">				<span class="comment">// 这个很好理解，保存值的指针都拿到了，想修改就很简单了。</span></span><br><span class="line">				<span class="comment">// 如果 key 已经存在，则返回已存在 key 的对应的 elem 的地址。</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// tophash 相等，依然需要比较 key 是否相等。</span></span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 但是 key 不想等，继续比较下一个槽</span></span><br><span class="line">			<span class="keyword">if</span> !t.key.equal(key, k) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// tophash 相等、key 也相等，说明已经存在，更新它即可</span></span><br><span class="line">			<span class="comment">// 用 key 更新 k</span></span><br><span class="line">			<span class="keyword">if</span> t.needkeyupdate() &#123;</span><br><span class="line">				typedmemmove(t.key, k, key)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 计算 value 所在的地址</span></span><br><span class="line">			elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">			<span class="comment">// 找到了 key，直接跳转到 done</span></span><br><span class="line">			<span class="keyword">goto</span> done</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当前的桶里面所有槽都找不到。</span></span><br><span class="line">		<span class="comment">// 继续遍历溢出桶（在溢出桶中查找 key 是否存在/有没有空余的槽）</span></span><br><span class="line">		ovf := b.overflow(t)</span><br><span class="line">		<span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 溢出桶也找不到，跳出循环</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// b 指向下一个溢出桶，下次循环遍历这个溢出桶</span></span><br><span class="line">		b = ovf</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未找到 key，需要插入这个新的 key。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果我们达到了最大负载系数或者我们有太多的溢出桶，</span></span><br><span class="line">	<span class="comment">// 同时，如果还没有开始扩容，那么现在开始扩容。</span></span><br><span class="line">	<span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">		hashGrow(t, h)</span><br><span class="line">		<span class="comment">// 扩容哈希表会使所有内容无效，因此需要再次尝试插入。</span></span><br><span class="line">		<span class="comment">// （上面循环获取到的插入位置的指针已经失效了，扩容之后插入的位置改变了，所以需要再次计算要插入的 bucket，以及要插入的槽中的位置）</span></span><br><span class="line">		<span class="keyword">goto</span> again</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 表明没有找到可以插入的地方，则新建一个溢出桶来保存，</span></span><br><span class="line">	<span class="comment">// 溢出桶的第一个元素就用来保存 key，返回溢出桶第一个元素 elem 的地址</span></span><br><span class="line">    <span class="comment">// （这意味着，我们要插入的桶，所有的槽都有数据了，并且也不是我们要找的 key，所需要溢出桶了）</span></span><br><span class="line">    <span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 当前存储桶及其连接的所有溢出存储桶已满，分配一个新的溢出桶。</span></span><br><span class="line">		newb := h.newoverflow(t, b)</span><br><span class="line">		<span class="comment">// 溢出桶的第一个 tophash 的指针</span></span><br><span class="line">		inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">		<span class="comment">// 溢出桶的第一个 key 的指针</span></span><br><span class="line">		insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">		<span class="comment">// 溢出桶的第一个 value 的指针</span></span><br><span class="line">		elem = add(insertk, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在插入位置存储新 key/elem</span></span><br><span class="line">	<span class="keyword">if</span> t.indirectkey() &#123;                   <span class="comment">// 这意味着需要给 key 分配内存来保存它</span></span><br><span class="line">		kmem := newobject(t.key)           <span class="comment">// 给 key 分配内存（kmem 是保存 key 的内存指针）</span></span><br><span class="line">		*(*unsafe.Pointer)(insertk) = kmem <span class="comment">// bucket 里面的 key 保存新分配的内存指针</span></span><br><span class="line">		insertk = kmem                     <span class="comment">// insertk 指向新分配的地址（跟上一行并不重复）</span></span><br><span class="line">		<span class="comment">// 最终效果是，insertk 和 kmem 指向了新分配的保存 key 的内存地址。</span></span><br><span class="line">		<span class="comment">// 当然，insertk = kmem 不需要也可以，但这样一来下面也要改成：</span></span><br><span class="line">		<span class="comment">// if t.indirectkey() &#123;</span></span><br><span class="line">		<span class="comment">//     typedmemmove(t.key, kmem, key)</span></span><br><span class="line">		<span class="comment">// &#125; else &#123;</span></span><br><span class="line">		<span class="comment">//     typedmemmove(t.key, insertk, key)</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">		vmem := newobject(t.elem)       <span class="comment">// 给 elem 分配内存</span></span><br><span class="line">		*(*unsafe.Pointer)(elem) = vmem <span class="comment">// bucket 里面 elem 的槽保存新分配的地址</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 移动 key 到 insertK（保存新的 key）</span></span><br><span class="line">	typedmemmove(t.key, insertk, key)</span><br><span class="line">	<span class="comment">// 保存 tophash</span></span><br><span class="line">	*inserti = top</span><br><span class="line">	<span class="comment">// map 元素个数 +1</span></span><br><span class="line">	h.count++</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	<span class="comment">// 并发写则报错（多个协程同时写 map）</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123; <span class="comment">// 写标志被清除了</span></span><br><span class="line">		fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 清除写标志</span></span><br><span class="line">	h.flags &amp;^= hashWriting</span><br><span class="line">    <span class="comment">// bucket 中的值保存的是指针，这个时候就不能返回 bucket 中值的地址了，而是返回 bucket 中值指向的另外一个地址的指针。</span></span><br><span class="line">	<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">		<span class="comment">// 获取指向 elem 实际存储地址的指针</span></span><br><span class="line">		elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回存储值的指针</span></span><br><span class="line">	<span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有几点要注意的：</p>
<ol type="1">
<li>go 中 <code>map</code> 是不允许并发读写的，如果有，直接报错。</li>
<li>这里面我们看到了有扩容的操作，<strong>在 go 中，<code>map</code>
的扩容发生在插入、修改和删除的时候，是一种渐进式扩容的方式，每次扩容会迁移两个
<code>bucket</code></strong>，详细的后面讲到扩容的时候会细说。</li>
<li>在 <code>bucketloop</code>
这个循环中，会记录下第一个空的槽，在找不到 <code>key</code>
的时候会进行插入操作。</li>
<li>如果找到，则返回保存值的地址的指针。如果没找到，则将
<code>key</code>
插入到上一步找到的空的槽中，如果也没有空的槽，则会新建溢出桶来保存新插入的
<code>key</code>。</li>
<li>在这个函数中，会判断插入之后是否超过负载因子，又或者溢出桶是否太多，来决定是否扩容。</li>
</ol>
<blockquote>
<p>关于 <code>key</code> 匹配的过程，其实跟上面的 <code>mapaccess</code>
是一样的过程，先找普通桶，然后查找溢出桶。</p>
</blockquote>
<h2 id="map-删除-key-的实现">map 删除 key 的实现</h2>
<p>对于删除操作，其实有一些操作上面已经说过了，如如何定位一个
<code>key</code>。所以下面的讲述会侧重讲解跟删除操作密切相关的操作。</p>
<h3 id="map-删除-key-的步骤">map 删除 key 的步骤</h3>
<ol type="1">
<li>定位 <code>key</code> 所在 <code>bucket</code>，计算
<code>tophash</code>。</li>
<li>遍历 <code>bucket</code> 的每一个槽，比较 <code>tophash</code> 以及
<code>key</code>，普通桶中查找不到会继续查找溢出桶。</li>
<li>如果查找到 <code>key</code> 的话，会清空对应 <code>key</code> 在
<code>bucket</code> 内存中的 <code>tophash</code>、<code>key</code> 和
<code>value</code>。</li>
<li>如果后面的槽没有元素了，则设置 <code>emptyRest</code>
标记。<strong>这样在后续查找的时候就可以避免不必要的搜索了。</strong></li>
</ol>
<h3 id="map-删除过程图解">map 删除过程图解</h3>
<p>删除的过程比较简单，定位 <code>key</code>
的过程上面有过详细的讲解了，这里只详细画图阐述一下
<code>emptyRest</code> 的标记设置：</p>
<figure>
<img src="/images/go/map/map_6_1.png" alt="map_6_1" />
<figcaption aria-hidden="true">map_6_1</figcaption>
</figure>
<h3 id="map-删除源码剖析">map 删除源码剖析</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 map 中删除 key（以及对应的 elem）</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// t：map 类型元数据的结构体</span></span><br><span class="line"><span class="comment">// h：实际保存键值对的桶</span></span><br><span class="line"><span class="comment">// key：需要删除的 key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// map 是空的</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果 key 的类型不可哈希则 panic</span></span><br><span class="line">		<span class="keyword">if</span> t.hashMightPanic() &#123;</span><br><span class="line">			t.hasher(key, <span class="number">0</span>) <span class="comment">// see issue 23734</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 并发写则抛出 fatal 错误</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算 key 的 hash</span></span><br><span class="line">	hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在调用 t.hasher 之后设置 hashWriting，</span></span><br><span class="line">	<span class="comment">// 因为 t.hasher 可能会 panic ，在这种情况下，我们实际上没有执行 write（delete）。</span></span><br><span class="line">	h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算 key 落在哪一个 bucket 中</span></span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">	<span class="comment">// 如果正在扩容，则迁移 bucket 到新的内存地址中（迁移到新的桶）</span></span><br><span class="line">	<span class="comment">// (迁移当前正在访问的 bucket)</span></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		growWork(t, h, bucket)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取 bucket 实例（key 所在的 bucket）</span></span><br><span class="line">	b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	<span class="comment">// 记录原始的 bucket 实例</span></span><br><span class="line">	<span class="comment">//（目的是为了方便加 emptyRest 标记）</span></span><br><span class="line">	bOrig := b</span><br><span class="line">	<span class="comment">// 计算 tophash</span></span><br><span class="line">	top := tophash(hash)</span><br><span class="line">search:</span><br><span class="line">	<span class="comment">// 在 bucket 内进行搜索</span></span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="comment">// 遍历 bucket 的每一个槽</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="comment">// tophash 不想等的时候，需要判断后面是否还有元素</span></span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="comment">// 从 i 开始 bucket 后面都是空的了，</span></span><br><span class="line">				<span class="comment">// 中止搜索过程（去除写标记，函数执行完毕）</span></span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> search</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 还有元素，继续搜索</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// tophash 相等</span></span><br><span class="line">			<span class="comment">// 获取 key 在 bucket 中的内存地址</span></span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			k2 := k <span class="comment">// k2 代表的是指向实际存储 key 的指针（unsafe.Pointer） </span></span><br><span class="line">			<span class="comment">// k2 指向原始的地址</span></span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// key 不想等，继续检查下一个 slot（continue）</span></span><br><span class="line">			<span class="keyword">if</span> !t.key.equal(key, k2) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 只有在键中有指针时才清除键。</span></span><br><span class="line">			<span class="comment">// 清空 key 的内存</span></span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				<span class="comment">// 清除 bucket 里面保存 key 的内存</span></span><br><span class="line">				<span class="comment">//（bucket 只是存储了 key 的指针）</span></span><br><span class="line">				*(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.key.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 清除包含指针的 key</span></span><br><span class="line">				memclrHasPointers(k, t.key.size)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 值的地址</span></span><br><span class="line">			e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">			<span class="comment">// 清空值</span></span><br><span class="line">			<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">				<span class="comment">// 清除 bucket 里面保存 elem 的内存</span></span><br><span class="line">				*(*unsafe.Pointer)(e) = <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.elem.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 清除包含指针的 elem（值）</span></span><br><span class="line">				memclrHasPointers(e, t.elem.size)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 清除不包含指针的 elem 的内存</span></span><br><span class="line">				memclrNoHeapPointers(e, t.elem.size)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// tophash 设置为空标记</span></span><br><span class="line">			b.tophash[i] = emptyOne</span><br><span class="line">			<span class="comment">// 如果 bucket 现在以一堆 emptyOne 状态结束，</span></span><br><span class="line">			<span class="comment">// 将这些状态更改为 emptyRest 状态。</span></span><br><span class="line">			<span class="comment">// 最好将其作为一个单独的函数，但 for 循环当前不可内联。（所以用 goto）</span></span><br><span class="line">			<span class="keyword">if</span> i == bucketCnt<span class="number">-1</span> &#123;</span><br><span class="line">				<span class="comment">// 要删除的 key 是 bucket 里面的最后一个元素。</span></span><br><span class="line">				<span class="comment">// 同时还有溢出桶，并且溢出桶里面还有元素 =&gt; 表明当前删除的 key 不是 bucket 以及溢出桶里面的最后一个元素。</span></span><br><span class="line">				<span class="keyword">if</span> b.overflow(t) != <span class="literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="number">0</span>] != emptyRest &#123;</span><br><span class="line">					<span class="comment">// 不是最后一个元素</span></span><br><span class="line">					<span class="keyword">goto</span> notLast</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 要删除的 key 不是 bucket 的最后一个元素。</span></span><br><span class="line">				<span class="comment">// 并且后面还有元素。</span></span><br><span class="line">				<span class="keyword">if</span> b.tophash[i+<span class="number">1</span>] != emptyRest &#123;</span><br><span class="line">					<span class="keyword">goto</span> notLast</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 执行到这里的时候，表明刚刚删除的 key 是 bucket 以及溢出桶中的最后一个元素。</span></span><br><span class="line">			<span class="comment">// 如果不是最后一个元素的话，上面的 if 判断已经跳转了。</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 下面的 for 循环做的事情是：</span></span><br><span class="line">			<span class="comment">// 1. 将当前 key 的标志设置为：emptyRest，表示后面没有元素了。</span></span><br><span class="line">			<span class="comment">// 2. 从 bucket 的第一个 key 出发遍历所有的槽（包含溢出桶），</span></span><br><span class="line">			<span class="comment">//    将最后一个元素以后一直到被删除的 key 的中间的所有槽标记为 emptyRest</span></span><br><span class="line">			<span class="comment">// 目的是，在后续遍历的时候可以避免一些不必要的查找操作，见到 emptyRest 就可以直接中断循环了。</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 例子，bucket 里 key 的内存布局为 | nil | a | nil | nil | b | nil |</span></span><br><span class="line">			<span class="comment">// b 被删除的时候，b 以及 a 后面的两个元素都要标记为 emptyRest（溢出桶同理）</span></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// 给当前遍历到的 bucket 槽打上 emptyRest 标记</span></span><br><span class="line">				b.tophash[i] = emptyRest</span><br><span class="line">				<span class="keyword">if</span> i == <span class="number">0</span> &#123; <span class="comment">// 当前的桶遍历完了（因为是从后往前遍历）</span></span><br><span class="line">					<span class="comment">// b 是普通桶（不是溢出桶）</span></span><br><span class="line">					<span class="keyword">if</span> b == bOrig &#123;</span><br><span class="line">						<span class="comment">// 所有空的槽都处理完了</span></span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// b 是上一次循环处理的桶</span></span><br><span class="line">					c := b <span class="comment">// c 是上一个 b </span></span><br><span class="line">					<span class="comment">// 查找上一个存储桶，在其最后一个条目处继续。 </span></span><br><span class="line">					<span class="comment">// 如：bucket &lt;- overflow1 &lt;- overflow2 &lt;- ... &lt;- overflowN</span></span><br><span class="line">					<span class="comment">// 假设 c 是 overflow2，那么下面的循环过后，b 就是 overflow1</span></span><br><span class="line">					<span class="comment">// prevB.overflow = b  =&gt; 找 prevB，也即：遍历完当前的桶，找前一个桶。</span></span><br><span class="line">					<span class="keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// b 指向了前一个 bucket（前一个桶）</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">// 处理前一个 bucket 的最后一个槽</span></span><br><span class="line">					i = bucketCnt - <span class="number">1</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 继续处理前一个槽</span></span><br><span class="line">					i--</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 找到了一个不是空的槽，表示有数据了，不需要再打 emptyRest 标记了。</span></span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 被删除的元素如果不是最后一个元素，直接跳转到这里。</span></span><br><span class="line">		notLast:</span><br><span class="line">			<span class="comment">// 找到了元素，并且删除了。</span></span><br><span class="line">			<span class="comment">// map 的元素个数减 1</span></span><br><span class="line">			h.count--</span><br><span class="line">			<span class="comment">// 重置哈希种子，使攻击者更难重复触发哈希冲突。见 issue 25237。</span></span><br><span class="line">			<span class="keyword">if</span> h.count == <span class="number">0</span> &#123;</span><br><span class="line">				h.hash0 = fastrand()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 在 bucket 内找到了对应的元素，并且删除了。</span></span><br><span class="line">			<span class="comment">// 退出循环。</span></span><br><span class="line">			<span class="keyword">break</span> search</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前没有写标记，则抛出 fatal 错误（不能并发读写 map）</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 清除写标记</span></span><br><span class="line">	h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol type="1">
<li>go <code>map</code> 不允许并发写，所以如果发现有并发读写，则抛出
fatal 错误。</li>
<li>如果删除的是最后一个元素，则需要往前遍历，将每一个空的槽设置为
<code>emptyRest</code> 状态。</li>
<li>如果是
<code>indirectkey</code>、<code>indirectelem</code>，在删除的时候，只会将
<code>bucket</code> 中的指针置为 <code>nil</code>，对于实际的
<code>key</code> 和 <code>value</code> 不会进行处理。（无所谓，GC
会出手）。</li>
</ol>
<h2 id="map-的扩容实现">map 的扩容实现</h2>
<p>从上面的讲解中，我们知道，底层存储 <code>key/value</code> 的是
<code>bucket</code>，而 <code>bucekt</code>
的大小是一段有一定大小的连续内存。
如果我们插入的元素过多，我们初始化时分配的 <code>bucket</code>
的内存就会放不下了，这个时候 go 的 <code>map</code>
会有两种方式解决这个问题：</p>
<ol type="1">
<li>使用溢出桶（在 <code>bmap</code> 的上再链接一个
<code>bmap</code>，也就是溢出桶，普通桶放不下的时候，就放溢出桶中）</li>
<li>分配新的更大的空间来存放现有的这些键值对。在 go
里面新分配的内存空间将会是原来的 2 倍。</li>
</ol>
<h3 id="map-扩容的条件">map 扩容的条件</h3>
<p><code>map</code> 的扩容发生在插入或者修改或者删除 <code>key</code>
的时候，扩容的条件在 <code>mapassign</code> 中写了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件：</span></span><br><span class="line"><span class="comment">// 1. 没有在扩容</span></span><br><span class="line"><span class="comment">// 2. 超过负载因子</span></span><br><span class="line"><span class="comment">// 3. 太多溢出桶</span></span><br><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">    hashGrow(t, h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否超过负载因子。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否有太多的溢出桶了</span></span><br><span class="line"><span class="comment">// 多的标准是：</span></span><br><span class="line"><span class="comment">// B &lt;= 15 的时候，溢出桶数量大于 2^B 的时候</span></span><br><span class="line"><span class="comment">// B &gt; 15 的时候，溢出桶的数量大于 2^15 的时候</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="type">uint16</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 如果阈值太低，我们会做额外的工作。</span></span><br><span class="line">	<span class="comment">// 如果阈值太高，则增长和收缩的 map 会保留大量未使用的内存。</span></span><br><span class="line">	<span class="comment">// “太多” 意味着（大约）与常规桶一样多的溢出桶。</span></span><br><span class="line">	<span class="comment">// 有关详细信息，请参见incrnoverflow。</span></span><br><span class="line">	<span class="comment">// B &gt; 15 =&gt; 2 ^ 15，B &lt;= 15 =&gt; 2 ^ B</span></span><br><span class="line">	<span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">		B = <span class="number">15</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> noverflow &gt;= <span class="type">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashgrow-实现">hashGrow 实现</h3>
<p><code>hashGrow</code>
是被用来分配新的内存空间的，新的内存空间将被用来保存旧的
<code>buckets</code>。<strong>需要注意的是，这个函数里面并没有做数据迁移的操作。</strong>
go 的 <code>map</code>
扩容的时候，数据迁移的方式是渐进式扩容，在我们插入/修改/删除
<code>key</code> 的时候会迁移 2 个
<code>bucket</code>，这样可以避免性能的瞬时抖动。 我们熟知的
<code>redis</code> 的扩容过程也是渐进式扩容的。</p>
<p>下面是 <code>hashGrow</code> 的实现源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash 扩容（这个方法只是分配了空间，实际上还没有做数据复制的操作）</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// t：map 类型元信息</span></span><br><span class="line"><span class="comment">// h：实际保存键值对的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 扩容的两种情况：</span></span><br><span class="line">	<span class="comment">// 1、如果我们达到了负载系数，就要进行 2 倍扩容。</span></span><br><span class="line">	<span class="comment">// 2、否则，如果溢出桶太多，进行等量扩容。</span></span><br><span class="line">	bigger := <span class="type">uint8</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 尚未超过负载因子，进行等量扩容</span></span><br><span class="line">	<span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">		bigger = <span class="number">0</span> <span class="comment">// 等量扩容</span></span><br><span class="line">		h.flags |= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 记录旧的 buckets</span></span><br><span class="line">	oldbuckets := h.buckets</span><br><span class="line">	<span class="comment">// 分配新的内存空间，oldbuckets 将会被渐进式迁移到 newbuckets 中</span></span><br><span class="line">	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// flags 标记有使用旧桶</span></span><br><span class="line">	<span class="comment">// 正在迭代的时候扩容</span></span><br><span class="line">	<span class="comment">// 先把 h.flags 中的迭代标记位清除。</span></span><br><span class="line">	<span class="comment">// 最后如果发现 h.flags 中还有迭代标记位，说明在扩容的过程中有新的迭代操作，</span></span><br><span class="line">	<span class="comment">// 那就把它转移到 oldIterator 中。</span></span><br><span class="line">	flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">		flags |= oldIterator</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 提交扩容操作</span></span><br><span class="line">	h.B += bigger <span class="comment">// 加上扩容的数量</span></span><br><span class="line">	h.flags = flags</span><br><span class="line">	h.oldbuckets = oldbuckets <span class="comment">// 记录旧桶</span></span><br><span class="line">	h.buckets = newbuckets    <span class="comment">// 指向新的桶数组</span></span><br><span class="line">	h.nevacuate = <span class="number">0</span>           <span class="comment">// 0 个桶已完成迁移（当前函数只是分配空间，不做迁移）</span></span><br><span class="line">	h.noverflow = <span class="number">0</span>           <span class="comment">// 所有溢出桶没有了（移动到了 oldoverflow）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录扩容前的溢出桶</span></span><br><span class="line">	<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;oldoverflow is not nil&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">		h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扩容之后，h.B+bigger &gt;= 4 了，预分配了溢出桶（扩容前没有溢出桶）</span></span><br><span class="line">	<span class="comment">// 所以这里要记录溢出桶</span></span><br><span class="line">	<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">		&#125;</span><br><span class="line">		h.extra.nextOverflow = nextOverflow</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 哈希表数据的实际迁移过程是通过 growWork() 和 evacuate() 增量完成的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据迁移的两条线">数据迁移的两条线</h3>
<p>go <code>map</code> 在扩容的时候，数据迁移会有两条线进行：</p>
<ol type="1">
<li>从第一个 <code>bucket</code> 开始迁移。</li>
<li>插入、修改、删除的时候，<code>key</code> 的哈希值定位到的
<code>bucket</code> 会被迁移。</li>
</ol>
<p>具体如下图：</p>
<figure>
<img src="/images/go/map/map_7_1.png" alt="map_7_1" />
<figcaption aria-hidden="true">map_7_1</figcaption>
</figure>
<blockquote>
<p>如果已经被迁移，则不再需要迁移。</p>
</blockquote>
<p>这样一来就可以保证在一定的操作次数之后，全部 <code>bucket</code>
都被迁移。就算你每次插入、修改、删除都是同一个
<code>key</code>（也就是同一个 <code>bucket</code>），
我们第一条线的迁移都会在每次写操作的时候，迁移一个
<code>bucket</code>。这样无论如何，写操作到了一定次数之后，所有的
<code>bucket</code> 都会被迁移了。</p>
<h3 id="什么时候-bucket-迁移之后下标会改变">什么时候 bucket
迁移之后下标会改变？</h3>
<p>当然这里说的是增量扩容，如果是等量扩容，<code>bucket</code>
的下标不会改变。</p>
<p>先说答案：<code>hash &amp; m</code> 的最高位是 1 的时候。</p>
<p>我们知道，在定位 <code>bucket</code> 的时候是通过
<code>hash &amp; m</code> 的方式来定位 <code>bucket</code>
的索引的（具体可以看上面定位 <code>key</code> 的那一节）， 而 2
倍扩容之后，<code>bucket</code> 的长度是原来的 2
倍，转换为二进制的时候，就是在原来的基础上多了一位，所以
<code>hash &amp; m</code> 的结果就会多一位， 而最高的那个二进制位如果是
1，说明 <code>hash &amp; m</code> 的结果是大于新的 <code>bucket</code>
数组长度的一半的（<strong>也就是比原来的索引都要大</strong>）。
那么会最高位是 1 会比原来的索引会大多少呢？答案是 <code>bucket</code>
数组的长度的一半（也就是 <code>2^(B-1)</code>）：</p>
<figure>
<img src="/images/go/map/map_7_2.png" alt="map_7_2" />
<figcaption aria-hidden="true">map_7_2</figcaption>
</figure>
<p>我们可以再看看之前的那个计算 <code>bucket</code> 索引的图：</p>
<figure>
<img src="/images/go/map/map_7_3.png" alt="map_7_3" />
<figcaption aria-hidden="true">map_7_3</figcaption>
</figure>
<p>我们会发现，当 <code>B = 3</code> 的时候，不管 <code>hash</code>
是什么，<code>hash &amp; m</code> 的结果都是 <code>0~7</code>。 而只有当
<code>B = 4</code> 的时候，<code>hash &amp; m</code> 的结果才有可能落入
<code>8~15</code> 范围内，而且只有 <code>hash &amp; m</code> 的最高位是
1 的时候才有可能。</p>
<p><strong>所以结论是，当 <code>hash &amp; m</code> 的最高位是 1
的时候，<code>bucket</code> 的下标就会改变。</strong> 而
<code>hash % m</code> 的其他位跟之前是一样的，所以下标增加的范围其实就是
<code>2^(B - 1)</code>，也就是旧的 <code>buckets</code> 的个数。</p>
<h3 id="bucket-迁移图解">bucket 迁移图解</h3>
<figure>
<img src="/images/go/map/map_7_4.png" alt="map_7_4" />
<figcaption aria-hidden="true">map_7_4</figcaption>
</figure>
<p>说明：</p>
<ul>
<li><code>oldbuckets</code> 是迁移前的桶，<code>buckets</code>
是迁移后的桶（也就是当前的 <code>h.buckets</code>）。</li>
<li><code>hash &amp; m</code> 为 <code>0xxx</code> 的时候，会迁移到
<code>x</code> 这个 <code>bucket</code> 中。</li>
<li><code>hash &amp; m</code> 为 <code>1xxx</code> 的时候，会迁移到
<code>x + 2^(B-1)</code> 这个 <code>bucket</code> 中（也就是
<code>y</code> 中），因为 <code>1000</code> 就是
<code>2^(4 - 1)</code>。</li>
</ul>
<p>假设需要迁移的是 <code>oldbucket</code>，下标为 <code>3</code>，那么
<code>oldbucket</code> 里面的 <code>key</code>
可能迁移的位置只可能是右边的 <code>x</code> 和 <code>y</code> 指向的
<code>bucket</code>。 这取决于 <code>oldbucket</code> 里面的
<code>key</code> 哈希值的倒数第 <code>4</code> 位； 如果是
<code>0</code>，那么就迁移到 <code>x</code> 指向的
<code>bucket</code>，如果是 <code>1</code>，那么就迁移到 <code>y</code>
指向的 <code>bucket</code>。</p>
<p><code>oldbucket</code> 中所有的 <code>key</code> 只会迁移到
<code>x</code> 或 <code>y</code> 中。同时 <code>x</code> 和
<code>y</code> 也只可能有 <code>oldbucket</code> 的
<code>key</code>，不可能有其他旧的 <code>bucket</code> 的
<code>key</code>。这是由 <code>hash &amp; m</code> 可以推断出来的。</p>
<h3 id="bucket-迁移源码剖析">bucket 迁移源码剖析</h3>
<p><strong>开始之前，我们要记住 <code>x</code> 和 <code>y</code>
是怎么来的。</strong></p>
<p>在开始看代码之前，我们需要明确一点：<strong>虽然整个哈希表是渐进式迁移的，但是单个
<code>bucket</code> 的迁移不是渐进式的。</strong></p>
<ol type="1">
<li>我们先看看 <code>growWork</code> 函数：</li>
</ol>
<p>这是迁移桶的函数，一次会迁移两个桶。不过实际上并不是严格的两个，因为迁移的函数会先判断桶是否已经被迁移，
如果桶还没有被迁移，才会进行迁移，如果桶已经被迁移则不做任何操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 桶迁移</span></span><br><span class="line"><span class="comment">// 参数：h 需要扩容的 map，t map 类型信息，bucket 旧桶的索引</span></span><br><span class="line"><span class="comment">// 1、迁移当前访问到的桶（mapassign、mapdelete 的时候）</span></span><br><span class="line"><span class="comment">// 2、继续逐个迁移 bucket，直到迁移完成（这个是从第一个桶开始迁移的）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 迁移当前访问到的桶</span></span><br><span class="line">	evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续逐个迁移 bucket，直到迁移完成</span></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		evacuate(t, h, h.nevacuate)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>然后看看 <code>evacuate</code> 函数：</li>
</ol>
<p>这个就是实际做迁移操作的函数。它会根据 <code>hash &amp; m</code>
的倒数第 <code>B</code> 位是否为 1 来决定将 <code>key</code> 迁移到
<code>h.buckets</code> 的前半部分还是后半部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迁移的目的地（旧桶 -&gt; 目标桶）</span></span><br><span class="line"><span class="comment">// evacuate 中会定义两个这个 evacDst 变量，</span></span><br><span class="line"><span class="comment">// 一个指向 h.buckets 的前半部分，一个指向后半部分。（对应前一个图的 x，y）</span></span><br><span class="line"><span class="comment">// 迁移的时候，会根据 key 的哈希值的倒数第 4 位来决定迁移到哪个 evacDst 中。</span></span><br><span class="line"><span class="keyword">type</span> evacDst <span class="keyword">struct</span> &#123;</span><br><span class="line">	b *bmap          <span class="comment">// 迁移目的地 bucket</span></span><br><span class="line">	i <span class="type">int</span>            <span class="comment">// key/elem 在迁移目标 bucket 里面对应的下标</span></span><br><span class="line">	k unsafe.Pointer <span class="comment">// 目标 bucket 下一个保存 key 的地址指针</span></span><br><span class="line">	e unsafe.Pointer <span class="comment">// 目标 bucket 下一个保存 elem 的地址指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容的时候，bucket 迁移的实现</span></span><br><span class="line"><span class="comment">// oldbucket 需要迁移的旧桶索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// b 指向旧桶</span></span><br><span class="line">	b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	<span class="comment">// 扩容之前的桶的数量</span></span><br><span class="line">	<span class="comment">// oldbucket+newbit 对应 y，oldbucket 对应 x</span></span><br><span class="line">	newbit := h.noldbuckets()</span><br><span class="line">	<span class="comment">// 如果 b 尚未迁移，则进行迁移</span></span><br><span class="line">	<span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">		<span class="comment">// xy 包含 x 和 y（低和高）迁移目的地。</span></span><br><span class="line">		<span class="comment">// 迁移的时候，在 h.buckets 中，前 noldbuckets 个桶就是 x，后 noldbuckets 个桶就是代表 y。</span></span><br><span class="line">		<span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">		<span class="comment">// x 存储了新桶的地址</span></span><br><span class="line">		x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">		<span class="comment">// x 指向 oldbucket 可能迁移到的新桶（h.buckets 的前半部分）</span></span><br><span class="line">		x.b = (*bmap)(add(h.buckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">		<span class="comment">// x 桶中下一个用来保存旧桶的 key 的地址</span></span><br><span class="line">		x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">		<span class="comment">// x 桶中下一个用来保存旧桶的 elem 的地址</span></span><br><span class="line">		x.e = add(x.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果不是等量扩容（有可能会迁移到 oldbucket+newbit 的位置上）</span></span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">			<span class="comment">// y 指向增量空间上的第 oldbucket+newbit 个位置</span></span><br><span class="line">			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">			<span class="comment">// y 桶中下一个保存旧桶 key 的地址</span></span><br><span class="line">			y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">			<span class="comment">// y 桶中下一个保存旧桶 elem 的地址</span></span><br><span class="line">			y.e = add(y.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开始迁移旧桶（同时也会迁移溢出桶）</span></span><br><span class="line">		<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">			<span class="comment">// 旧 bucket 上第一个 key</span></span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">			<span class="comment">// 旧 bucket 上第一个 value</span></span><br><span class="line">			e := add(k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="comment">// 遍历 bucket 的槽</span></span><br><span class="line">			<span class="comment">// 获取需要迁移的 key/elem(k/e) 对，迁移到新桶上(&amp;xy[useY])</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, e = i+<span class="number">1</span>, add(k, <span class="type">uintptr</span>(t.keysize)), add(e, <span class="type">uintptr</span>(t.elemsize)) &#123;</span><br><span class="line">				<span class="comment">// 获取旧的 tophash</span></span><br><span class="line">				top := b.tophash[i]</span><br><span class="line">				<span class="comment">// bucket 的这个槽是空的</span></span><br><span class="line">				<span class="keyword">if</span> isEmpty(top) &#123;</span><br><span class="line">					<span class="comment">// 写入已迁移标记</span></span><br><span class="line">					b.tophash[i] = evacuatedEmpty</span><br><span class="line">					<span class="comment">// 处理下一个 key/elem</span></span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// tophash 错误</span></span><br><span class="line">				<span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">					throw(<span class="string">&quot;bad map state&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 复制一份 k</span></span><br><span class="line">				k2 := k</span><br><span class="line">				<span class="comment">// k2 指向实际的 key</span></span><br><span class="line">				<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">					k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// useY 决定了是迁移到 x 还是 y，如果是等量扩容，那么就是迁移到 x</span></span><br><span class="line">				<span class="keyword">var</span> useY <span class="type">uint8</span></span><br><span class="line">				<span class="comment">// 如果不是等量扩容</span></span><br><span class="line">				<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">					<span class="comment">// 计算哈希以做出迁移决定（是否需要将此 key/elem 迁移到桶 x 或桶 y）。</span></span><br><span class="line">					hash := t.hasher(k2, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">					<span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &amp;&amp; !t.reflexivekey() &amp;&amp; !t.key.equal(k2, k2) &#123;</span><br><span class="line">						<span class="comment">// 下面这段是原英文注释的翻译（可能不太准确）：</span></span><br><span class="line">						<span class="comment">// 如果 key != key（不是一个数字），则散列可能（并且可能）与旧散列完全不同。</span></span><br><span class="line">						<span class="comment">// 此外，它是不可再现的。</span></span><br><span class="line">						<span class="comment">// 在迭代器存在的情况下，再现性是必需的，因为我们的迁移决策必须与迭代器所做的任何决策相匹配。</span></span><br><span class="line">						<span class="comment">// 幸运的是，我们可以任意发送这些 key。</span></span><br><span class="line">						<span class="comment">// 此外，tophash 对于这些类型的 key 没有意义。我们让 tophash 的最低位的决定如何迁移。</span></span><br><span class="line">						<span class="comment">// 我们为下一个级别重新计算一个新的随机 tophash，这样在多次扩容后，这些 key 将均匀分布在所有桶中。</span></span><br><span class="line">						useY = top &amp; <span class="number">1</span></span><br><span class="line">						top = tophash(hash)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 原理参考上面那个图。</span></span><br><span class="line">						<span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123; <span class="comment">// 取决于 oldB + 1 位是 0 还是 1</span></span><br><span class="line">							useY = <span class="number">1</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> evacuatedX+<span class="number">1</span> != evacuatedY || evacuatedX^<span class="number">1</span> != evacuatedY &#123;</span><br><span class="line">					throw(<span class="string">&quot;bad evacuatedN&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 记录旧桶的迁移状态</span></span><br><span class="line">				b.tophash[i] = evacuatedX + useY <span class="comment">// evacuatedX + 1 == evacuatedY</span></span><br><span class="line">				<span class="comment">// dst 是迁移的目标 bucket</span></span><br><span class="line">				dst := &amp;xy[useY]</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 目标 bucket 装不下了，使用溢出桶</span></span><br><span class="line">				<span class="keyword">if</span> dst.i == bucketCnt &#123;</span><br><span class="line">					<span class="comment">// 创建溢出桶</span></span><br><span class="line">					dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">					dst.i = <span class="number">0</span></span><br><span class="line">					<span class="comment">// dst.k 指向溢出桶的第一个 key 的地址</span></span><br><span class="line">					dst.k = add(unsafe.Pointer(dst.b), dataOffset) </span><br><span class="line">					<span class="comment">// dst.e 指向溢出桶的第一个 elem 的地址</span></span><br><span class="line">					dst.e = add(dst.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 使用 &amp; 运算优化，不用进行边界检查</span></span><br><span class="line">				<span class="comment">// 记录 tophash</span></span><br><span class="line">				dst.b.tophash[dst.i&amp;(bucketCnt<span class="number">-1</span>)] = top <span class="comment">// mask dst.i as an optimization, to avoid a bounds check</span></span><br><span class="line">				<span class="comment">// 将旧的 key/elem 复制到 dst 指向的槽</span></span><br><span class="line">				<span class="keyword">if</span> t.indirectkey() &#123; <span class="comment">// bucket 的 key 保存的是指针</span></span><br><span class="line">					<span class="comment">// 修改实际存储 key 的内存</span></span><br><span class="line">					*(*unsafe.Pointer)(dst.k) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 修改 bucket 中保存 key 的内存</span></span><br><span class="line">					typedmemmove(t.key, dst.k, k) <span class="comment">// copy elem</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> t.indirectelem() &#123; <span class="comment">// bucket 的 elem 保存的是指针</span></span><br><span class="line">					<span class="comment">// 修改实际存储 elem 的内存</span></span><br><span class="line">					*(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 修改 bucket 中保存 elem 的内存</span></span><br><span class="line">					typedmemmove(t.elem, dst.e, e)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 目标桶的元素个数 +1</span></span><br><span class="line">				<span class="comment">// dst 指向下一个空的槽（slot/cell）</span></span><br><span class="line">				dst.i++</span><br><span class="line">				<span class="comment">// 这些更新可能会将这些指针推到 key 或 elem 数组的末尾。</span></span><br><span class="line">				<span class="comment">// 这没关系，因为我们在桶的末端有溢出桶指针，以防止指针指向桶的末端。</span></span><br><span class="line">				<span class="comment">// 如果指向数组末尾，在下次迁移的时候，会创建溢出桶。</span></span><br><span class="line">				dst.k = add(dst.k, <span class="type">uintptr</span>(t.keysize))</span><br><span class="line">				dst.e = add(dst.e, <span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">				<span class="comment">// 上面有判断 dst.i == bucketCnt，所以这里不会溢出</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 取消链接溢出桶并清除 key/elem 以帮助 GC。（清除旧桶的内存）</span></span><br><span class="line">		<span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.bucket.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">			b := add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize))</span><br><span class="line">			<span class="comment">// tophash 状态不能清除。</span></span><br><span class="line">			<span class="comment">// 但是 key/elem 都可以清除。</span></span><br><span class="line">			ptr := add(b, dataOffset)</span><br><span class="line">			n := <span class="type">uintptr</span>(t.bucketsize) - dataOffset</span><br><span class="line">			memclrHasPointers(ptr, n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 刚刚迁移的桶，就是顺序迁移的下一个桶，</span></span><br><span class="line">	<span class="comment">// 则需要更新 nevacuate 字段，表示已经迁移了多少个桶</span></span><br><span class="line">	<span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">		advanceEvacuationMark(h, t, newbit)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><code>advanceEvacuationMark</code> 的作用是更新
<code>nevacuate</code> 字段，表示已经迁移了多少个桶。</li>
</ol>
<p>我们上面说了，哈希表扩容的时候，会有两条线，<code>advanceEvacuationMark</code>
就是处理顺序迁移的那条线，让 <code>nevacuate</code>
指向下一个未迁移的桶。
为什么需要做这个处理呢？这是因为另外一条线的迁移是随机的，访问到哪个桶就迁移哪个桶，这就导致了，顺序迁移的那条线，在将
<code>nevacuate</code>
指向下一个桶的时候，其实下一个桶是已经迁移了的，我们下次顺序迁移的时候肯定不需要迁移这个桶。
那么解决办法就是，继续向后查找，找到第一个未迁移的桶。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录迁移进度（从顺序迁移的位置往后遍历，保证 nevacuate 指向下一个尚未迁移的桶）</span></span><br><span class="line"><span class="comment">// 参数：h 需要扩容的 map，t map 类型信息，newbit 是旧桶的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceEvacuationMark</span><span class="params">(h *hmap, t *maptype, newbit <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// nevacuate 索引加 1</span></span><br><span class="line">	h.nevacuate++</span><br><span class="line">	<span class="comment">// 往后找一个未迁移的桶（最多遍历 1024 个桶）。</span></span><br><span class="line">	stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line">	<span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">		stop = newbit</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 向后遍历，找到第一个未迁移的桶。</span></span><br><span class="line">	<span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">		h.nevacuate++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这意味着所有旧桶都迁移完了</span></span><br><span class="line">	<span class="keyword">if</span> h.nevacuate == newbit &#123;</span><br><span class="line">		<span class="comment">// 扩容已经完成。释放旧的普通桶数组。</span></span><br><span class="line">		h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">		<span class="comment">// 也可以丢弃旧的溢出桶。</span></span><br><span class="line">		<span class="comment">// 如果它们仍然被迭代器引用，那么迭代器将保存指向切片的指针。</span></span><br><span class="line">		<span class="comment">//（但是 h 不再需要保存指向切片的指针）</span></span><br><span class="line">		<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra.oldoverflow = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 移除等量扩容标志</span></span><br><span class="line">		h.flags &amp;^= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是下面几行代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line"><span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">    stop = newbit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在将 <code>nevacuate</code> 加上 1 之后，还会继续往后遍历 1024 个
bucket，如果 bucket 已迁移，则将 <code>nevacuate</code> 加 1。</p>
<p>如果没有这个操作会怎样？那就意味着可能有很多的 bucket
都已经迁移了，但是顺序迁移的位置（<code>nevacuate</code>）还没有更新，
这样可能会导致顺序迁移的位置每次都指向了已迁移的 <code>bucket</code>。
最终导致，迁移的时候，只迁移了访问到的
<code>bucket</code>，而没有迁移顺序迁移位置上的那个
<code>bucket</code>。</p>
<p><strong>也就是说，每次迁移的时候只会迁移 1 个
<code>bucket</code>，而不是 2 个，这样一来 <code>growWork</code>
需要调用的次数比原来更多，也就是说，需要写操作次数更多才能完成全部
<code>bucket</code> 的迁移</strong>。</p>
<p>这个函数做的事情可以表示成下图：</p>
<figure>
<img src="/images/go/map/map_7_5.png" alt="map_7_5" />
<figcaption aria-hidden="true">map_7_5</figcaption>
</figure>
<p>在这个图中，<code>nevacuate</code> 一开始是 <code>1</code>，然后因为
<code>3</code> 这个 <code>bucket</code> 在这次 <code>growWork</code>
中已经迁移了， <code>nevacuate</code> 如果要指向下一个未迁移的
<code>bucket</code> 的话，就要跳过之前已经迁移的
<code>2</code>，以及本次 <code>growWork</code> 中已经迁移的
<code>3</code>， 所以最终 <code>nevacuate</code> 指向了
<code>4</code>，也就是下一个未迁移的 <code>bucket</code>。</p>
<h3 id="等量扩容的效果">等量扩容的效果</h3>
<p>在上面我们讲解的时候，其实已经假设了扩容是增量扩容（2
倍扩容），但实际上还有一种扩容方式，就是等量扩容。
等量扩容的时候，扩容前后的 <code>bucket</code>
其实数量是一样的，那么为什么还要进行扩容呢？</p>
<p>这是因为，溢出桶太多了，数据非常零散地分布在了很多的溢出桶中，这样会导致
<code>bucket</code> 中很多槽都是空的，
这样一来，进行查找、修改、删除的时候，需要遍历很多的溢出桶，这样会导致性能下降。如下图：</p>
<figure>
<img src="/images/go/map/map_7_6.png" alt="map_7_6" />
<figcaption aria-hidden="true">map_7_6</figcaption>
</figure>
<p>这个图中，我们假设要查找的 <code>key</code>
所在的普通桶以及前两个溢出桶都是空的，又或者 <code>key</code>
不在前面三个桶中，那只有遍历到最后一个溢出桶的时候才能找到我们要查找的
<code>key</code>。为了针对这种键值对数量没有达到扩容的阈值，但是溢出桶太多的情况，Go
语言提供了等量扩容的方式。</p>
<p>在等量扩容的时候，会将所有的溢出桶都迁移到新的 <code>bucket</code>
中，这样一来，<code>bucket</code>
中的槽就会被填满，而溢出桶也可能不再需要。</p>
<p>最后，针对上图的情况，<code>key = foo</code>
会被迁移到普通桶中，这样在查找的时候，只需要遍历普通桶就可以找到了。
当然，实际中的情况是，对于零散分布在多个溢出桶中的键值对，会被逐个往前挪，最终效果就是，桶中没有空的槽，除了最后一个
<code>key</code> 以后的槽。</p>
<p>大家可以结合下图想象一下：</p>
<p>当然下图只是描述了一下部分 <code>key</code>，如果 <code>key</code>
分布。实际上 <code>key</code>
在触发等量扩容的情况下，是零散地分布在不同的 <code>bucket</code>
中的（包括溢出桶）。</p>
<figure>
<img src="/images/go/map/map_7_7.png" alt="map_7_7" />
<figcaption aria-hidden="true">map_7_7</figcaption>
</figure>
<h2 id="map-的迭代实现">map 的迭代实现</h2>
<p>go 的 <code>map</code>
迭代的时候，我们会发现，返回结果的顺序并不固定，这是因为
<code>map</code> 的迭代是无序的。 在 <code>map</code>
遍历的时候，每次都会从一个随机的 <code>bucket</code>
开始遍历，而且选了一个 <code>bucket</code> 之后， 还会从
<code>bucket</code>
中随机选择一个槽开始遍历，这样一来，每次遍历的结果都是不一样的。</p>
<h3 id="map-迭代器数据结构">map 迭代器数据结构</h3>
<p>迭代器的功能：记录要遍历的 <code>map</code>，以及当前遍历到的
<code>bucket</code> 以及槽的索引，以便进行下一次遍历。</p>
<p>go 的 <code>map</code> 迭代器的数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希迭代结构。</span></span><br><span class="line"><span class="keyword">type</span> hiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 必须排在第一位。 写入 nil 表示迭代结束</span></span><br><span class="line">	key unsafe.Pointer</span><br><span class="line">	<span class="comment">// 必须在第二个位置（参见 cmd/compile/internal/walk/range.go）。</span></span><br><span class="line">	elem unsafe.Pointer</span><br><span class="line">	t    *maptype       <span class="comment">// map 的类型信息，包括 key、elem 的类型等信息</span></span><br><span class="line">	h    *hmap          <span class="comment">// 需要迭代的 hmap</span></span><br><span class="line">	<span class="comment">// hash_iter 初始化时的 bucket 指针</span></span><br><span class="line">	buckets unsafe.Pointer</span><br><span class="line">	<span class="comment">// 当前正在遍历的 bucket</span></span><br><span class="line">	bptr *bmap</span><br><span class="line">	<span class="comment">// 保持 hmap.buckets 的溢出桶存活</span></span><br><span class="line">	overflow *[]*bmap</span><br><span class="line">	<span class="comment">// 保持 hmap.oldbuckets 的溢出桶存活</span></span><br><span class="line">	oldoverflow *[]*bmap</span><br><span class="line">	<span class="comment">// bucket 迭代开始位置（随机选择的 bucket）</span></span><br><span class="line">	startBucket <span class="type">uintptr</span></span><br><span class="line">	<span class="comment">// 在迭代期间开始的桶内偏移量（应该足够大以容纳 bucketCnt-1）</span></span><br><span class="line">	offset <span class="type">uint8</span></span><br><span class="line">	<span class="comment">// 已经从桶数组的末尾环绕到开始</span></span><br><span class="line">	wrapped     <span class="type">bool</span></span><br><span class="line">	B           <span class="type">uint8</span>   <span class="comment">// 就是当前遍历的 hmap 的那个 B</span></span><br><span class="line">	i           <span class="type">uint8</span>   <span class="comment">// 当前遍历的 bucket 内 key 的索引</span></span><br><span class="line">	bucket      <span class="type">uintptr</span> <span class="comment">// 当前遍历的 bucket</span></span><br><span class="line">	checkBucket <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几点注意的：</p>
<ol type="1">
<li>全部键值对遍历完的时候，<code>key</code> 会被置为
<code>nil</code>，这样一来，我们就可以通过 <code>key</code> 是否为
<code>nil</code>
来判断是否遍历完了。（当然这个不用开发者来判断，<code>for...range</code>
底层已经帮我们做了这个判断）。</li>
<li><code>hiter</code> 结构体保存了当前正在迭代的
<code>bucket</code>（<code>bptr</code>）、<code>bucket</code> 中的
<code>key</code>
的索引（<code>i</code>）等信息，这样一来，我们就可以通过这些信息来确定下一个
<code>key</code> 的位置。</li>
</ol>
<h3 id="迭代器的初始化实现">迭代器的初始化实现</h3>
<p>go 的 <code>map</code> 初始化是通过 <code>runtime.mapiterinit</code>
来实现的，这个函数的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapiterinit 初始化用于 range 遍历 map 的 hiter 结构。（初始化 hiter）</span></span><br><span class="line"><span class="comment">// &#x27;it&#x27; 指向的 hiter 结构由编译器顺序传递在堆栈上分配，或由 reflect_mapiterinit 在堆上分配。</span></span><br><span class="line"><span class="comment">// 两者都需要将 hiter 置零，因为结构包含指针。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">	<span class="comment">// hiter 记录 map 的类型信息</span></span><br><span class="line">	it.t = t</span><br><span class="line">	<span class="comment">// 如果 map 是空的直接返回</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 个人猜测：内存对齐判断，这个由编译器决定的</span></span><br><span class="line">	<span class="keyword">if</span> unsafe.Sizeof(hiter&#123;&#125;)/goarch.PtrSize != <span class="number">12</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;hash_iter size incorrect&quot;</span>) <span class="comment">// see cmd/compile/internal/reflectdata/reflect.go</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// it 关联上 map</span></span><br><span class="line">	it.h = h</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取桶状态的快照</span></span><br><span class="line">	it.B = h.B</span><br><span class="line">	<span class="comment">// 当前的 buckets</span></span><br><span class="line">	it.buckets = h.buckets</span><br><span class="line">	<span class="comment">// bucket 里面没有包含指针</span></span><br><span class="line">	<span class="keyword">if</span> t.bucket.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 分配当前切片并记住指向当前切片和旧切片的指针。</span></span><br><span class="line">		<span class="comment">// 这将保持所有相关的溢出桶处于活动状态，即使在迭代时表增长和/或溢出桶添加到表中。</span></span><br><span class="line">		h.createOverflow()</span><br><span class="line">		it.overflow = h.extra.overflow</span><br><span class="line">		it.oldoverflow = h.extra.oldoverflow</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 决定从哪里开始遍历。</span></span><br><span class="line">	<span class="comment">// 策略：随机选定一个 bucket，然后从该 bucket 开始遍历。</span></span><br><span class="line">	<span class="comment">// 生成随机数</span></span><br><span class="line">	<span class="keyword">var</span> r <span class="type">uintptr</span></span><br><span class="line">	<span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">		r = <span class="type">uintptr</span>(fastrand64())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		r = <span class="type">uintptr</span>(fastrand())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// r =&gt; 扫描的入口（随机选的 bucket）</span></span><br><span class="line">	it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">	<span class="comment">// 随机定位的 bucket 中的槽。</span></span><br><span class="line">	it.offset = <span class="type">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录当前扫描的 bucket</span></span><br><span class="line">	it.bucket = it.startBucket</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记住我们有一个迭代器。</span></span><br><span class="line">	<span class="comment">// 可以与另一个 mapiteinit() 同时运行。</span></span><br><span class="line">	<span class="keyword">if</span> old := h.flags; old&amp;(iterator|oldIterator) != iterator|oldIterator &#123;</span><br><span class="line">		atomic.Or8(&amp;h.flags, iterator|oldIterator)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始遍历</span></span><br><span class="line">	mapiternext(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要功能是初始化迭代器，我们最需要关心的是，这个函数里面会生成一个随机数，然后通过这个随机数来决定从哪一个
<code>bucket</code> 开始遍历， 以及从 <code>bucket</code>
中的哪一个槽开始遍历（也是随机的）。</p>
<h3 id="map-遍历图解">map 遍历图解</h3>
<p>那为什么从随机定位的 <code>bucket</code> 以及随机定位的
<code>key</code> 就可以实现遍历呢？其实很简单，如果看过我之前写的 《go
chan 设计与实现》的话， 就会知道 <code>chan</code>
的实现中是通过数组来实现环形队列的。而我们可以借助环形队列的特性来理解
<code>map</code> 的遍历。遍历到最后一个 <code>bucket</code> 之后，
下一个 <code>bucket</code> 就是第一个
<code>bucket</code>，这样就实现了环形遍历。同样的，遍历到最后一个
<code>key</code> 之后，下一个 <code>key</code> 就是第一个
<code>key</code>，这样也实现了环形遍历。</p>
<p>我们需要做的就是，在遍历开始的时候，记录第一个
<code>bucket</code>，然后每次遍历 <code>bucket</code> 的时候，
比较当前的 <code>bucket</code> 是否是第一个
<code>bucket</code>，是的话，意味着遍历结束了。 同样的，对于
<code>bucket</code> 内 <code>key</code> 的遍历也是。</p>
<p>不过，在实际实现中，<code>key</code> 有点不一样，<code>key</code>
的遍历是通过将 <code>i</code> 从 <code>0</code> 遍历到
<code>7</code>，对于每一个 <code>i</code>，加上
<code>it.offset</code>，然后对 <code>8</code> 取模，
这样就可以实现环形遍历了，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ; i &lt; bucketCnt; i++ &#123;</span><br><span class="line">	<span class="comment">// 桶内第 i 个元素</span></span><br><span class="line">	offi := (i + it.offset) &amp; (bucketCnt - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体遍历过程如下图：</p>
<figure>
<img src="/images/go/map/map_8_1.png" alt="map_8_1" />
<figcaption aria-hidden="true">map_8_1</figcaption>
</figure>
<h3 id="发生在扩容期间的遍历">发生在扩容期间的遍历</h3>
<p>go 的 <code>map</code>
设计中，是不允许在迭代的时候进行插入、修改、删除的，但只是在获取下一个键值对的时候不允许，
在迭代器获取了键值对之后，就算还没有全部遍历完 <code>map</code>
的所有元素，还是可以允许做插入、修改、删除操作的。
这样一来，有可能会出现一些奇怪的现象，比如插入的 <code>key</code>
遍历不出来，或者遍历出来的 <code>key</code>
有重复等等。这是需要开发者注意的地方。</p>
<p>另外，迭代可以发生在扩容的过程中，但是扩容其实对迭代其实是没有什么影响的。因为迭代的时候会做一些判断尽量保证所有
<code>key</code> 都能被遍历到。 但不能保证我们对 <code>map</code>
做了写操作后依然可以全部 <code>key</code> 都遍历。</p>
<p>在遍历的过程中，如果 <code>map</code>
发生了扩容，那么遍历的过程就会变得复杂一些。因为在扩容的过程中，<code>map</code>
会新建一个 <code>bucket</code>， 然后将原来的 <code>bucket</code> 中的
<code>key</code> 重新散列到新的 <code>bucket</code>
中。所以在遍历的过程中，如果发现当前的 <code>bucket</code>
已经发生了扩容， 需要做一些判断，比如：</p>
<ol type="1">
<li>如果发现 <code>bucket</code> 还没有迁移，则从
<code>oldbuckets</code> 中遍历。</li>
<li>如果发现 <code>bucket</code>
在迁移之后索引跟原来的不一样，则跳过。</li>
</ol>
<p>具体可以参考下图：</p>
<figure>
<img src="/images/go/map/map_8_2.png" alt="map_8_2" />
<figcaption aria-hidden="true">map_8_2</figcaption>
</figure>
<p>这里假设的条件是：旧桶个数为 <code>4</code>，增量扩容后，新桶个数为
<code>8</code>。<code>hiter</code> 当前迭代的是新桶。</p>
<p>说明：</p>
<ol type="1">
<li><code>h.oldbuckets</code>
指向了还没迁移完的桶，<code>h.buckets</code> 是当前的桶。</li>
<li><code>hiter</code>
迭代器要迭代的是新的桶。迭代器初始化的时候正在进行 2 倍扩容。</li>
<li><code>checkBucket</code> 是下一个要遍历的桶（索引为
<code>1</code>），图中的情况是，这个桶还没有被迁移。所以需要从
<code>h.oldbuckets</code> 中读取。</li>
<li><code>checkBucket</code> 中的 <code>key</code> 有可能会迁移到
<code>h.buckets</code> 中的 <code>1</code> 或者 <code>5</code>
位置。（具体可以看上面桶迁移的实现那一节）</li>
<li>如果 <code>key</code> 是要被迁移到 <code>5</code>
中的话，那么遍历的时候会跳过，因为后面会遍历到 <code>5</code> 中的
<code>key</code>。</li>
<li>对于第 5 点，在遍历 <code>5</code> 这个 <code>bucket</code>
的时候，由于我们是使用当前遍历的 <code>bucket</code>
的下标结合旧桶的长度计算在旧桶中的下标的，所以还是可以取得到旧桶，然后遍历的时候取出那些应该迁移到
<code>5</code> 这个 <code>bucket</code> 的
<code>key</code>，对于那些应该要迁移到 <code>1</code> 的
<code>key</code> 则跳过。</li>
<li>下一个要遍历的桶的索引为 <code>2</code>。</li>
</ol>
<p>对于第 6 点桶索引计算的特别说明，如果是增量扩容，计算
<code>bucket</code> 的下标方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bucket 是当前要遍历的 bucket 的下标</span></span><br><span class="line"><span class="comment">// it.h.oldbucketmask() 是旧桶的 B 的掩码</span></span><br><span class="line">oldbucket := bucket &amp; it.h.oldbucketmask()</span><br></pre></td></tr></table></figure>
<p>当然如果这个桶已经迁移，那么还是会从新桶遍历（也就是
<code>bucket &amp; it.h.oldbucketmask()</code> 里的 <code>bucket</code>
本身）。</p>
<h3 id="键值对遍历源码剖析">键值对遍历源码剖析</h3>
<p><code>map</code> 中实现遍历的函数是
<code>mapiternext</code>，这个函数做的事情，也就是上面两个图描述的遍历过程，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：迭代器实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取底层的 hmap 实例</span></span><br><span class="line">	h := it.h</span><br><span class="line">	<span class="comment">// 正在插入、修改、删除 key 但时候，不能获取下一个 key，</span></span><br><span class="line">	<span class="comment">// 注意：这不能保证插入、修改、删除之后，进行迭代。</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t := it.t           <span class="comment">// *maptype</span></span><br><span class="line">	bucket := it.bucket <span class="comment">// 当前遍历到的 bucket 下标（int 类型）</span></span><br><span class="line">	b := it.bptr        <span class="comment">// 当前 bucket 的指针（实际的 bucket，bmap 指针类型）</span></span><br><span class="line">	i := it.i           <span class="comment">// 迭代器当前遍历到的位置（bucket 内 key 的位置）</span></span><br><span class="line">	checkBucket := it.checkBucket <span class="comment">// 这个用来判断是否是增量扩容的</span></span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">	<span class="comment">// 注意：下面的 if 的功能是，获取下一个桶。</span></span><br><span class="line">	<span class="comment">// 如果 b 是 nil，有以下两种情况：</span></span><br><span class="line">	<span class="comment">// a. 第一次遍历，还没有遍历到任何 bucket。</span></span><br><span class="line">	<span class="comment">// b. 遍历完最后一个 bucket 了。</span></span><br><span class="line">	<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 已经迭代完了，直接退出函数</span></span><br><span class="line">		<span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123;</span><br><span class="line">			<span class="comment">// for...range 查看到 key 是 nil 会中止迭代</span></span><br><span class="line">			it.key = <span class="literal">nil</span></span><br><span class="line">			it.elem = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果正在扩容</span></span><br><span class="line">		<span class="keyword">if</span> h.growing() &amp;&amp; it.B == h.B &#123;</span><br><span class="line">			<span class="comment">// 迭代器是在扩容过程中启动的，扩容尚未完成。</span></span><br><span class="line">			<span class="comment">// 如果我们正在查看的存储桶尚未迁移，</span></span><br><span class="line">			<span class="comment">// 那么我们需要遍历旧存储桶，同时只返回将迁移到此存储桶的数据。</span></span><br><span class="line">			<span class="comment">// 那些需要迁移到另一个下标的桶则跳过。</span></span><br><span class="line">			oldbucket := bucket &amp; it.h.oldbucketmask()</span><br><span class="line">			<span class="comment">// 获取旧桶</span></span><br><span class="line">			b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">			<span class="keyword">if</span> !evacuated(b) &#123; <span class="comment">// 旧桶还没有迁移</span></span><br><span class="line">				checkBucket = bucket</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 已经迁移了，获取新桶</span></span><br><span class="line">				b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">				checkBucket = noCheck</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 并没有在扩容，获取新的桶</span></span><br><span class="line">			b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">			checkBucket = noCheck</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// bucket 指向了下一个要迭代的桶的下标</span></span><br><span class="line">		bucket++</span><br><span class="line">		<span class="comment">// 判断当前遍历的桶是否到最后一个桶了</span></span><br><span class="line">		<span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">			bucket = <span class="number">0</span></span><br><span class="line">			it.wrapped = <span class="literal">true</span> <span class="comment">// 已经从第一个随机定位的 bucket 遍历到最后一个 bucket 了，下一个应该是第一个 bucket 了</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 开始遍历新的 bucket 的时候，重置 i</span></span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始遍历桶内的键值对</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; bucketCnt; i++ &#123;</span><br><span class="line">		<span class="comment">// 计算桶内键值对的下标（从随机的 it.offset 下标开始遍历）</span></span><br><span class="line">		offi := (i + it.offset) &amp; (bucketCnt - <span class="number">1</span>)</span><br><span class="line">		<span class="comment">// 如果槽是空的，或者 key 已经迁移，则跳过。</span></span><br><span class="line">		<span class="keyword">if</span> isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 桶内第 i 个元素的 key 的指针</span></span><br><span class="line">		<span class="comment">// 获取 key 或 elem 的解析前面的小节有详细的解释了，不再赘述。</span></span><br><span class="line">		k := add(unsafe.Pointer(b), dataOffset+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">		<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">			k = *((*unsafe.Pointer)(k))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 桶内第 i 个元素的 elem 的指针</span></span><br><span class="line">		e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 增量扩容的 key 判断</span></span><br><span class="line">		<span class="comment">// 需要判断迁移之后的 key 落入的是 h.buckets 的前半部分还是后半部分（x 还是 y）</span></span><br><span class="line">		<span class="comment">// 具体看上面的迁移实现。</span></span><br><span class="line">		<span class="keyword">if</span> checkBucket != noCheck &amp;&amp; !h.sameSizeGrow() &#123;</span><br><span class="line">			<span class="keyword">if</span> t.reflexivekey() || t.key.equal(k, k) &#123;</span><br><span class="line">				<span class="comment">// key 是可比较的</span></span><br><span class="line">				<span class="comment">// 如果这个 key 将会被迁移到 h.buckets 的后半部分，跳过它</span></span><br><span class="line">				hash := t.hasher(k, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">				<span class="keyword">if</span> hash&amp;bucketMask(it.B) != checkBucket &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 对于不可比较的 key，</span></span><br><span class="line">				<span class="comment">// 是由 tophash 的最低位来决定迁移到前半部分还是后半部分的。</span></span><br><span class="line">				<span class="comment">// 取 checkBucket 的最高位来比较，因为 checkBucket 的最高位决定了</span></span><br><span class="line">				<span class="comment">// 当前遍历的 bucket 是上半部分还是后半部分的 bucket。</span></span><br><span class="line">				<span class="keyword">if</span> checkBucket&gt;&gt;(it.B<span class="number">-1</span>) != <span class="type">uintptr</span>(b.tophash[offi]&amp;<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// 如果当前的 key 没有落入当前遍历的 bucket，则跳过它</span></span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) ||</span><br><span class="line">			!(t.reflexivekey() || t.key.equal(k, k)) &#123;</span><br><span class="line">			<span class="comment">// 上面的判断：</span></span><br><span class="line">			<span class="comment">// 1、表示 key 还没有迁移。</span></span><br><span class="line">			<span class="comment">// 2、或者，key 是不可比较的。</span></span><br><span class="line">			<span class="comment">// 则直接返回</span></span><br><span class="line">			it.key = k</span><br><span class="line">			<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">				e = *((*unsafe.Pointer)(e))</span><br><span class="line">			&#125;</span><br><span class="line">			it.elem = e</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 自迭代器启动以来，哈希表已扩容。</span></span><br><span class="line">			<span class="comment">// key 已经被迁移到其他地方。</span></span><br><span class="line">			<span class="comment">// 检查当前哈希表中的数据。</span></span><br><span class="line">			<span class="comment">// 此代码处理已删除、更新或删除并重新插入 key 的情况。</span></span><br><span class="line">			<span class="comment">// 注意：我们需要重新标记 key，因为它可能已更新为 equal() 但不是相同的 key（例如 +0.0 vs -0.0）。</span></span><br><span class="line">			<span class="comment">// 获取当前遍历到的 key/elem。</span></span><br><span class="line">			rk, re := mapaccessK(t, h, k)</span><br><span class="line">			<span class="keyword">if</span> rk == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// key 已经被删除了，继续遍历下一个 key</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 外部是通过 it 的 key/elem 来获取当前遍历到的键值对的</span></span><br><span class="line">			it.key = rk</span><br><span class="line">			it.elem = re</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 记录当前迭代的 bucket</span></span><br><span class="line">		it.bucket = bucket</span><br><span class="line">		<span class="comment">// 遍历到下一个 bucket 了，更新 bptr</span></span><br><span class="line">		<span class="keyword">if</span> it.bptr != b &#123; <span class="comment">// avoid unnecessary write barrier; see issue 14921</span></span><br><span class="line">			it.bptr = b</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 迭代器的 i 指向 bucket 内的下一个 key</span></span><br><span class="line">		it.i = i + <span class="number">1</span></span><br><span class="line">		<span class="comment">// 记录是否需要检查 key 的标记</span></span><br><span class="line">		it.checkBucket = checkBucket</span><br><span class="line">		<span class="comment">// 找到了键值对（保存在 it.key/it.elem 中了），返回。</span></span><br><span class="line">		<span class="comment">// mapiternext 外部可以通过 hiter 的 key/elem 属性来获取当前遍历到的 key/val。</span></span><br><span class="line">		<span class="comment">// 遍历下一个元素的时候，再次调用 mapiternext 函数。</span></span><br><span class="line">		<span class="comment">//（无所谓，hiter 会记住迭代到哪里的）</span></span><br><span class="line">		<span class="comment">// 也即：每遍历一个元素，调用一次 mapiternext 函数。</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当前的 bucket 遍历完了，那么继续从溢出桶中查找下一个元素。</span></span><br><span class="line">	<span class="comment">// b 指向溢出桶，迭代溢出桶</span></span><br><span class="line">	b = b.overflow(t)</span><br><span class="line">	<span class="comment">// 遍历下一个桶了，key 从 0 开始遍历</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 遍历当前 bucket 的溢出桶</span></span><br><span class="line">	<span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<ul>
<li>哈希表相比数组，可以很快速地查找，所以常见的编程语言都会有对应的实现。</li>
<li>哈希冲突有两种解决方法：<strong>开放地址法</strong>和<strong>链表法</strong>，go
里的 <code>map</code> 使用的是<strong>链表法</strong>。</li>
<li>哈希表初始化分配的是比较小的内存，只能存放少量键值对，但是随着我们插入的数据越来越多，哈希表会进行扩容，防止哈希表的读写性能下降。</li>
<li>go 的 <code>map</code> 扩容有两种方式：键值对太多的时候会进行 2
倍扩容，溢出桶太多会进行等量扩容。</li>
<li><code>map</code> 中使用 <code>buckets</code>
来存储桶，一个桶里面可以存储 <code>8</code>
个键值对，一个桶满了的时候，会创建溢出桶来保存多出来的
<code>key</code>。</li>
<li><code>map</code> 中桶的结构体是 <code>bmap</code>，它里面的会将所有
<code>key</code> 连续存储，所有的 <code>value</code> 也会连续存储。</li>
<li><code>map</code> 定位 <code>key</code> 的时候，会使用哈希值与
<code>B</code> 的掩码做 <code>&amp;</code>
运算（我们可以将其理解为一种模运算的另外一种实现），从而得到
<code>bucket</code> 的下标，然后遍历这个 <code>bucket</code>
中的每一个槽。先比较 <code>tophash</code>，如果 <code>tophash</code>
相等再比较 <code>key</code>，如果 <code>tophash</code> 和
<code>key</code> 都相等，则表明找到了我们要找的
<code>key</code>。如果这两者有一个不等，继续比较下一个
<code>key</code>。</li>
<li>如果一个 <code>bucket</code> 中的所有 <code>key</code>
被遍历完了也没有找到，那么继续从溢出桶中查找。</li>
<li><code>map</code> 读取数据是通过
<code>mapaccess1</code>、<code>mapaccess2</code>、<code>mapaccessK</code>
实现的，对于整型键值的 <code>map</code> 有优化的 <code>mapaccess</code>
实现（对于 <code>bmap</code> 里键值的访问更加高效）。</li>
<li><code>map</code> 写入和修改数据都是通过 <code>mapassign</code>
函数实现的，这个函数在找不到 <code>key</code>
的时候会进行插入操作。</li>
<li><code>map</code> 删除数据是通过 <code>mapdelete</code>
函数实现的。删除的时候会需要将 <code>bucket</code>
末尾的所有空的槽的标记更新为 <code>emptyRest</code>。</li>
<li><code>map</code>
扩容的条件有两个：超过负载因子、溢出桶太多。只有在增量扩容的时候，<code>key</code>
所对应的 <code>bucket</code> 的下标才有可能发生变化。</li>
<li><code>map</code> 扩容的时候，会迁移当前正在写入、删除的
<code>bucket</code>，同时也会从第一个 <code>bucket</code>
开始迁移，一次写操作会迁移两个
<code>bucket</code>。这样可以保证在一定的写操作以后，所有
<code>bucket</code> 都能迁移完成。</li>
<li>等量扩容的时候，<code>key</code> 在新桶中的 <code>bucket</code>
下标不变，但是 <code>key</code>
在桶内的分布会更加地紧凑，从而会提高查找效率。</li>
<li><code>map</code> 的迭代是通过 <code>hiter</code>
结构体来实现的，迭代的过程中 <code>hiter</code> 会记录当前的
<code>bucket</code>、<code>key</code>，普通桶迭代完后，迭代溢出桶。<code>map</code>
的迭代是通过 <code>mapiternext</code>
函数实现的，每次获取键值对都是通过这个 <code>mapiternext</code>
函数。</li>
<li><code>map</code> 迭代如果发生在增量扩容的时候，对于未迁移的
<code>bucket</code>，会判断 <code>key</code> 的 <code>bucket</code>
是否会发生变化，如果 <code>key</code> 对应的 <code>bucket</code>
已经改变，则迭代的时候会跳过。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/12/06/golang/go%20interface%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/06/golang/go%20interface%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">go interface 设计与实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-06 20:08:30" itemprop="dateCreated datePublished" datetime="2022-12-06T20:08:30+08:00">2022-12-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在上一篇文章<a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyMTI0MzA4OQ==&amp;mid=2650072023&amp;idx=1&amp;sn=512aa1f0d31a83d400f282744989d605&amp;chksm=f03ff069c748797f2c2187ac1bd4fb5112dd95e25ed15f5e0d5de5b13300397435db10acfa3c#rd">《go
interface 基本用法》</a>中，我们了解了 go 中 <code>interface</code>
的一些基本用法，其中提到过
<code>接口本质是一种自定义类型</code>，本文就来详细说说为什么说
<code>接口本质是一种自定义类型</code>，以及这种自定义类型是如何构建起 go
的 <code>interface</code> 系统的。</p>
<blockquote>
<p>本文使用的源码版本： go 1.19。另外本文中提到的 <code>interface</code>
和 <code>接口</code> 是同一个东西。</p>
</blockquote>
<h2 id="前言">前言</h2>
<p>在了解 go <code>interface</code>
的设计过程中，看了不少资料，但是大多数资料都有生成汇编的操作，但是在我的电脑上指向生成汇编的操作的时候，
生成的汇编代码却不太一样，所以有很多的东西无法验证正确性，这部分内容不会出现在本文中。本文只写那些经过本机验证正确的内容，但也不用担心，因为涵盖了
go <code>interface</code>
设计与实现的核心部分内容，但由于水平有限，所以只能尽可能地传达我所知道的关于
<code>interface</code>
的一切东西。对于有疑问的部分，有兴趣的读者可以自行探索。</p>
<p>如果想详细地了解，建议还是去看看
<code>iface.go</code>，里面有接口实现的一些关键的细节。但是还是有一些东西被隐藏了起来，
导致我们无法知道我们 go 代码会是 <code>iface.go</code>
里面的哪一段代码实现的。</p>
<h2 id="接口是什么">接口是什么？</h2>
<blockquote>
<p>接口（<code>interface</code>）本质上是一种结构体。</p>
</blockquote>
<p>我们先来看看下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Flyable <span class="keyword">interface</span> &#123;</span><br><span class="line">	Fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// go tool compile -N -S -l main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f1 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="built_in">println</span>(f1) <span class="comment">// CALL    runtime.printeface(SB)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> f2 Flyable</span><br><span class="line">	<span class="built_in">println</span>(f2) <span class="comment">// CALL    runtime.printiface(SB)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过 <code>go tool compile -N -S -l main.go</code> 命令来生成
<code>main.go</code>
的伪汇编代码，生成的代码会很长，下面省略所有跟本文主题无关的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// main.go:10 =&gt; println(f1)</span><br><span class="line">0x0029 00041 (main.go:10)  CALL  runtime.printeface(SB)</span><br><span class="line">// main.go:13 =&gt; println(f2)</span><br><span class="line">0x004f 00079 (main.go:13)  CALL  runtime.printiface(SB)</span><br></pre></td></tr></table></figure>
<p>我们从这段汇编代码中可以看到，我们 <code>println(f1)</code>
实际上是对 <code>runtime.printeface</code> 的调用，我们看看这个
<code>printeface</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printeface</span><span class="params">(e eface)</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;(&quot;</span>, e._type, <span class="string">&quot;,&quot;</span>, e.data, <span class="string">&quot;)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到了，这个 <code>printeface</code> 接收的参数实际上是
<code>eface</code> 类型，而不是 <code>interface&#123;&#125;</code>
类型，我们再来看看 <code>println(f2)</code> 实际调用的
<code>runtime.printiface</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printiface</span><span class="params">(i iface)</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;(&quot;</span>, i.tab, <span class="string">&quot;,&quot;</span>, i.data, <span class="string">&quot;)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>也就是说 <code>interface&#123;&#125;</code> 类型在底层实际上是
<code>eface</code> 类型，而 <code>Flyable</code> 类型在底层实际上是
<code>iface</code> 类型。</strong></p>
<p>这就是本文要讲述的内容，go 中的接口变量其实是用 <code>iface</code> 和
<code>eface</code> 这两个结构体来表示的：</p>
<ul>
<li><code>iface</code> 表示某一个具体的接口（含有方法的接口）。</li>
<li><code>eface</code> 表示一个空接口（<code>interface&#123;&#125;</code>）</li>
</ul>
<p><img src="/images/go/interface/interface_5.png" /></p>
<h2 id="iface-和-eface-结构体">iface 和 eface 结构体</h2>
<p><code>iface</code> 和 <code>eface</code>
的结构体定义（<code>runtime/iface.go</code>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非空接口（如：io.Reader）</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	tab  *itab          <span class="comment">// 方法表</span></span><br><span class="line">	data unsafe.Pointer <span class="comment">// 指向变量本身的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空接口（interface&#123;&#125;）</span></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">	_type *_type         <span class="comment">// 接口变量的类型</span></span><br><span class="line">	data  unsafe.Pointer <span class="comment">// 指向变量本身的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>go 底层的类型信息是使用 <code>_type</code> 结构体来存储的。</p>
</blockquote>
<p>比如，我们有下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bird)</span></span> Fly() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Flyable <span class="keyword">interface</span> &#123;</span><br><span class="line">	Fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bird := Bird&#123;name: <span class="string">&quot;b1&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> efc <span class="keyword">interface</span>&#123;&#125; = bird <span class="comment">// efc 是 eface</span></span><br><span class="line">	<span class="keyword">var</span> ifc Flyable = bird <span class="comment">// ifc 是 iface</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(efc) <span class="comment">// runtime.printeface</span></span><br><span class="line">	<span class="built_in">println</span>(ifc) <span class="comment">// runtime.printiface</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中，<code>efc</code> 是 <code>eface</code>
类型的变量，对应到 <code>eface</code> 结构体的话，<code>_type</code>
就是 <code>Bird</code> 这个类型本身，而 <code>data</code> 就是
<code>&amp;bird</code> 这个指针：</p>
<p><img src="/images/go/interface/interface_6.png" /></p>
<p>类似的，<code>ifc</code> 是 <code>iface</code> 类型的变量，对应到
<code>iface</code> 结构体的话，<code>data</code> 也是
<code>&amp;bird</code> 这个指针：</p>
<p><img src="/images/go/interface/interface_7.png" /></p>
<h2 id="type-是什么">_type 是什么？</h2>
<p>在 go 中，<code>_type</code>
是保存了变量类型的元数据的结构体，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _type 是 go 里面所有类型的一个抽象，里面包含 GC、反射、大小等需要的细节，</span></span><br><span class="line"><span class="comment">// 它也决定了 data 如何解释和操作。</span></span><br><span class="line"><span class="comment">// 里面包含了非常多信息：类型的大小、哈希、对齐及 kind 等信息</span></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="type">uintptr</span> <span class="comment">// 数据类型共占用空间的大小</span></span><br><span class="line">    ptrdata    <span class="type">uintptr</span> <span class="comment">// 含有所有指针类型前缀大小</span></span><br><span class="line">    hash       <span class="type">uint32</span>  <span class="comment">// 类型 hash 值；避免在哈希表中计算</span></span><br><span class="line">    tflag      tflag   <span class="comment">// 额外类型信息标志</span></span><br><span class="line">    align      <span class="type">uint8</span>   <span class="comment">// 该类型变量对齐方式</span></span><br><span class="line">    fieldAlign <span class="type">uint8</span>   <span class="comment">// 该类型结构体字段对齐方式</span></span><br><span class="line">    kind       <span class="type">uint8</span>   <span class="comment">// 类型编号</span></span><br><span class="line">    <span class="comment">// 用于比较此类型对象的函数</span></span><br><span class="line">    equal <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span></span> <span class="type">bool</span></span><br><span class="line">    <span class="comment">// gc 相关数据</span></span><br><span class="line">    gcdata    *<span class="type">byte</span></span><br><span class="line">    str       nameOff <span class="comment">// 类型名字的偏移</span></span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>_type</code> 结构体定义大家随便看看就好了，实际上，go
底层的类型表示也不是上面这个结构体这么简单。</p>
<p><strong>但是，我们需要知道的一点是（与本文有关的信息），通过
<code>_type</code> 我们可以得到结构体里面所包含的方法这些信息。</strong>
具体我们可以看 <code>itab</code> 的 <code>init</code>
方法（<code>runtime/iface.go</code>），我们会看到如下几行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typ := m._type</span><br><span class="line">x := typ.uncommon() <span class="comment">// 结构体类型</span></span><br><span class="line"></span><br><span class="line">nt := <span class="type">int</span>(x.mcount)   <span class="comment">// 实际类型的方法数量</span></span><br><span class="line"><span class="comment">// 实际类型的方法数组，数组元素为 method</span></span><br><span class="line">xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]method)(add(unsafe.Pointer(x), <span class="type">uintptr</span>(x.moff)))[:nt:nt]</span><br></pre></td></tr></table></figure>
<p>在底层，go 是通过 <code>_type</code> 里面 <code>uncommon</code>
返回的地址，加上一个偏移量（<code>x.moff</code>）来得到实际结构体类型的方法列表的。</p>
<p>我们可以参考一下下图想象一下：</p>
<p><img src="/images/go/interface/interface_8.png" /></p>
<h2 id="itab-是什么">itab 是什么？</h2>
<p>我们从 <code>iface</code> 中可以看到，它包含了一个 <code>*itab</code>
类型的字段，我们看看这个 <code>itab</code> 的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器已知的 itab 布局</span></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">	inter *interfacetype <span class="comment">// 接口类型</span></span><br><span class="line">	_type *_type</span><br><span class="line">	hash  <span class="type">uint32</span></span><br><span class="line">	_     [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line">	fun   [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// 变长数组. fun[0]==0 意味着 _type 没有实现 inter 这个接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口类型</span></span><br><span class="line"><span class="comment">// 对应源代码：type xx interface &#123;&#125;</span></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ     _type     <span class="comment">// 类型信息</span></span><br><span class="line">    pkgpath name      <span class="comment">// 包路径</span></span><br><span class="line">    mhdr    []imethod <span class="comment">// 接口的方法列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据 <code>interfacetype</code>
我们可以得到关于接口所有方法的信息。同样的，通过 <code>_type</code>
也可以获取结构体类型的所有方法信息。</p>
</blockquote>
<p>从定义上，我们可以看到 <code>itab</code> 跟
<code>*interfacetype</code> 和 <code>*_type</code>
有关，但实际上有什么关系从定义上其实不太能看得出来，
但是我们可以看它是怎么被使用的，现在，假设我们有如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i 在底层是一个 interfacetype 类型</span></span><br><span class="line"><span class="keyword">type</span> i <span class="keyword">interface</span> &#123;</span><br><span class="line">	A()</span><br><span class="line">	C()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t 底层会用 _type 来表示</span></span><br><span class="line"><span class="comment">// t 里面有 A、B、C、D 方法</span></span><br><span class="line"><span class="comment">// 因为实现了 i 中的所有方法，所以 t 实现了接口 i</span></span><br><span class="line"><span class="keyword">type</span> t <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t)</span></span> A()  &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t)</span></span> B()  &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t)</span></span> C()  &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t)</span></span> D()  &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>下图描述了上面代码对应的 <code>itab</code> 生成的过程：</p>
<p><img src="/images/go/interface/interface_9.png" /></p>
<p>说明：</p>
<ul>
<li><code>itab</code> 里面的 <code>inter</code>
是接口类型的指针（比如通过 <code>type Reader interface&#123;&#125;</code>
这种形式定义的接口，记录的是这个类型本身的信息），这个接口类型本身定义了一系列的方法，如图中的
<code>i</code> 包含了 <code>A</code>、<code>C</code> 两个方法。</li>
<li><code>_type</code>
是实际类型的指针，记录的是这个实际类型本身的信息，比如这个类型包含哪些方法。图中的
<code>i</code> 实现了
<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>
四个方法，因为实现了 <code>i</code> 的所有方法，所以说 <code>t</code>
实现了 <code>i</code> 接口。</li>
<li>在底层做类型转换的时候，比如 <code>t</code> 转换为 <code>i</code>
的时候（<code>var v i = t&#123;&#125;</code>），会生成一个 <code>itab</code>，如果
<code>t</code> 没有实现 <code>i</code> 中的所有方法，那么生成的
<code>itab</code> 中不包含任何方法。</li>
<li>如果 <code>t</code> 实现了 <code>i</code> 中的所有方法，那么生成的
<code>itab</code> 中包含了 <code>i</code>
中的所有方法指针，但是实际指向的方法是实际类型的方法（也就是指向的是
<code>t</code> 中的方法地址）</li>
<li><code>mhdr</code> 就是 <code>itab</code>
中的方法表，里面的方法名就是接口的所有方法名，这个方法表中保存了实际类型（<code>t</code>）中同名方法的函数地址，通过这个地址就可以调用实际类型的方法了。</li>
</ul>
<p>所以，我们有如下结论：</p>
<ul>
<li><code>itab</code> 实际上定义了 <code>interfacetype</code> 和
<code>_type</code>
之间方法的交集。作用是什么呢？就是用来判断一个结构体是否实现某个接口的。</li>
<li><code>itab</code>
包含了接口的所有方法，这里面的方法是实际类型的子集。</li>
<li><code>itab</code>
里面的方法列表包含了实际类型的方法指针（也就是实际类型的方法的地址），通过这个地址可以对实际类型进行方法的调用。</li>
<li><code>itab</code>
在实际类型没有实现接口的所有方法的时候，生成失败（失败的意思是，生成的
<code>itab</code> 里面的方法列表是空的，在底层实现上是用
<code>fun[0] = 0</code> 来表示）。</li>
</ul>
<h2 id="生成的-itab-是怎么被使用的">生成的 itab 是怎么被使用的？</h2>
<p>go 里面定义了一个全局变量 <code>itabTable</code>，用来缓存
<code>itab</code>，因为在判断某一个结构体是否实现了某一个接口的时候，
需要比较两者的方法集，如果结构体实现了接口的所有方法，那么就表明结构体实现了接口（这也就是生成
<code>itab</code> 的过程）。
如果在每一次做接口断言的时候都要做一遍这个比较，性能无疑会大大地降低，因此
go 就把这个比较得出的结果缓存起来，也就是 <code>itab</code>。
这样在下一次判断结构体是否实现了某一个接口的时候，就可以直接使用之前的
<code>itab</code>，性能也就得到提升了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表里面缓存了 itab</span></span><br><span class="line">itabTable     = &amp;itabTableInit</span><br><span class="line">itabTableInit = itabTableType&#123;size: itabInitSize&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的 itab 表</span></span><br><span class="line"><span class="keyword">type</span> itabTableType <span class="keyword">struct</span> &#123;</span><br><span class="line">    size    <span class="type">uintptr</span>             <span class="comment">// entries 的长度，2 的次方</span></span><br><span class="line">    count   <span class="type">uintptr</span>             <span class="comment">// 当前 entries 的数量</span></span><br><span class="line">    entries [itabInitSize]*itab <span class="comment">// 保存 itab 的哈希表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>itabTableType</code> 里面的 <code>entries</code>
是一个哈希表，在实际保存的时候，会用 <code>interfacetype</code> 和
<code>_type</code> 这两个生成一个哈希表的键。 也就是说，这个保存
<code>itab</code> 的缓存哈希表中，只要我们有 <code>interfacetype</code>
和 <code>_type</code> 这两个信息，就可以获取一个 <code>itab</code>。</p>
<p>具体怎么使用，我们可以看看下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Flyable <span class="keyword">interface</span> &#123;</span><br><span class="line">	Fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Runnable <span class="keyword">interface</span> &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ Flyable = (*Bird)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ Runnable = (*Bird)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bird)</span></span> Fly() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bird)</span></span> Run() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GOOS=linux GOARCH=amd64 go tool compile -N -S -l main.go &gt; main.s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// f 的类型是 iface</span></span><br><span class="line">	<span class="keyword">var</span> f Flyable = Bird&#123;&#125;</span><br><span class="line">	<span class="comment">// Flyable 转 Runnable 本质上是 iface 到 iface 的转换</span></span><br><span class="line">	f.(Runnable).Run() <span class="comment">// CALL	runtime.assertI2I(SB)</span></span><br><span class="line">	<span class="comment">// 这个 switch 里面的类型断言本质上也是 iface 到 iface 的转换</span></span><br><span class="line">	<span class="comment">// 但是 switch 里面的类型断言失败不会引发 panic</span></span><br><span class="line">	<span class="keyword">switch</span> f.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> Flyable: <span class="comment">// CALL	runtime.assertI2I2(SB)</span></span><br><span class="line">	<span class="keyword">case</span> Runnable: <span class="comment">// CALL	runtime.assertI2I2(SB)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := f.(Runnable); ok &#123; <span class="comment">// CALL	runtime.assertI2I2(SB)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// i 的类型是 eface</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = Bird&#123;&#125;</span><br><span class="line">	<span class="comment">// i 转 Flyable 本质上是 eface 到 iface 的转换</span></span><br><span class="line">	i.(Flyable).Fly() <span class="comment">// CALL	runtime.assertE2I(SB)</span></span><br><span class="line">	<span class="comment">// 这个 switch 里面的类型断言本质上也是 eface 到 iface 的转换</span></span><br><span class="line">	<span class="comment">// 但是 switch 里面的类型断言失败不会引发 panic</span></span><br><span class="line">	<span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> Flyable: <span class="comment">// CALL	runtime.assertE2I2(SB)</span></span><br><span class="line">	<span class="keyword">case</span> Runnable: <span class="comment">// CALL	runtime.assertE2I2(SB)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := i.(Runnable); ok &#123; <span class="comment">// CALL	runtime.assertE2I2(SB)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对上面的代码生成伪汇编代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go tool compile -N -S -l main.go &gt; main.s</span><br></pre></td></tr></table></figure>
<p>然后我们去查看
<code>main.s</code>，就会发现类型断言的代码，本质上是对
<code>runtime.assert*</code>
方法的调用（<code>assertI2I</code>、<code>assertI2I2</code>、<code>assertE2I</code>、<code>assertE2I2</code>），
这几个方法名都是以 <code>assert</code> 开头的，<code>assert</code>
在编程语言中的含义是，判断后面的条件是否为 <code>true</code>，如果
<code>false</code> 则抛出异常或者其他中断程序执行的操作，为
<code>true</code> 则接着执行。
这里的用处就是，<strong>判断一个接口是否能够转换为另一个接口或者另一个类型</strong>。</p>
<p>但在这里有点不太一样，这里有两个函数最后有个数字 <code>2</code>
的，表明了我们对接口的类型转换会有两种情况，我们上面的代码生成的汇编其实已经很清楚了，
<strong>一种情况是直接断言，使用 <code>i.(T)</code>
这种形式，另外一种是在 <code>switch...case</code>
里面使用，</strong>。</p>
<p>我们可以看看它们的源码，看看有什么不一样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接根据 interfacetype/_type 获取 itab</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertE2I</span><span class="params">(inter *interfacetype, t *_type)</span></span> *itab &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 显式转换需要非nil接口值。</span></span><br><span class="line">		<span class="built_in">panic</span>(&amp;TypeAssertionError&#123;<span class="literal">nil</span>, <span class="literal">nil</span>, &amp;inter.typ, <span class="string">&quot;&quot;</span>&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// getitab 的第三个参数是 false</span></span><br><span class="line">	<span class="comment">// 表示 getiab 获取不到 itab 的时候需要 panic</span></span><br><span class="line">	<span class="keyword">return</span> getitab(inter, t, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 eface 转换为 iface</span></span><br><span class="line"><span class="comment">// 因为 e 包含了 *_type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertE2I2</span><span class="params">(inter *interfacetype, e eface)</span></span> (r iface) &#123;</span><br><span class="line">	t := e._type</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// getitab 的第三个参数是 true</span></span><br><span class="line">	<span class="comment">// 表示 getitab 获取不到 itab 的时候不需要 panic</span></span><br><span class="line">	tab := getitab(inter, t, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	r.tab = tab</span><br><span class="line">	r.data = e.data</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>getitab</code> 的源码后面会有。</p>
</blockquote>
<p>从上面的代码可以看到，其实带 <code>2</code> 和不带 <code>2</code>
后缀的关键区别在于：<code>getitab</code> 的调用允不允许失败。
这有点类似于 <code>chan</code> 里面的
<code>select</code>，<code>chan</code> 的 <code>select</code> 语句中读写
<code>chan</code> 不会阻塞，而其他地方会阻塞。</p>
<p><code>assertE2I2</code> 是用在 <code>switch...case</code>
中的，这个调用是允许失败的，因为我们还需要判断能否转换为其他类型；
又或者 <code>v, ok := i.(T)</code>
的时候，也是允许失败的，但是这种情况会返回第二个值给用户判断是否转换成功。
而直接使用类型断言的时候，如 <code>i.(T)</code> 这种，如果
<code>i</code> 不能转换为 <code>T</code> 类型，则直接
<code>panic</code>。</p>
<p>对于 go 中的接口断言可以总结如下：</p>
<ul>
<li><code>assertI2I</code> 用于将一个 <code>iface</code> 转换为另一个
<code>iface</code>，转换失败的时候<strong>会</strong>
<code>panic</code></li>
<li><code>assertI2I2</code> 用于将一个 <code>iface</code> 转换为另一个
<code>iface</code>，转换失败的时候<strong>不会</strong>
<code>panic</code></li>
<li><code>assertE2I</code> 用于将一个 <code>eface</code> 转换为另一个
<code>iface</code>，转换失败的时候<strong>会</strong>
<code>panic</code></li>
<li><code>assertE2I2</code> 用于将一个 <code>eface</code> 转换为另一个
<code>iface</code>，转换失败的时候<strong>不会</strong>
<code>panic</code></li>
<li><code>assert</code> 相关的方法后缀的
<code>I2I</code>、<code>E2E</code> 里面的 <code>I</code> 表示的是
<code>iface</code>，<code>E</code> 表示的是 <code>eface</code></li>
<li>带 <code>2</code> 后缀的允许失败，用于 <code>v, ok := i.(T)</code>
或者 <code>switch x.(type) ... case</code> 中</li>
<li>不带 <code>2</code> 后缀的不允许失败，用于 <code>i.(T)</code>
这种形式中</li>
</ul>
<blockquote>
<p>当然，这里说的转换不是说直接转换，只是说，在转换的过程中会用到
assert* 方法。</p>
</blockquote>
<p>如果我们足够细心，然后也去看了 <code>assertI2I</code> 和
<code>assertI2I2</code> 的源码，就会发现，这几个方法本质上都是， 通过
<code>interfacetype</code> 和 <code>_type</code> 来获取一个
<code>itab</code> 然后转换为另外一个 <code>itab</code> 或者 `iface。</p>
<blockquote>
<p>同时，我们也应该注意到，上面的转换都是转换到 iface 而没有转换到 eface
的操作，这是因为，所有类型都可以转换为空接口（interface{}，也就是
eface）。根本就不需要断言。</p>
</blockquote>
<p>上面的内容可以结合下图理解一下：</p>
<p><img src="/images/go/interface/interface_10.png" /></p>
<h2 id="itab-关键方法的实现">itab 关键方法的实现</h2>
<p>下面，让我们再来深入了解一下 <code>itab</code>
是怎么被创建出来的，以及是怎么保存到全局的哈希表中的。我们先来看看下图：</p>
<p><img src="/images/go/interface/interface_11.png" /></p>
<p>这个图描述了 go 底层存储 <code>itab</code> 的方式：</p>
<ul>
<li>通过一个 <code>itabTableType</code> 类型来存储所有的
<code>itab</code>。</li>
<li>在调用 <code>getitab</code> 的时候，会先根据 <code>inter</code> 和
<code>_type</code> 计算出哈希值，然后从 <code>entries</code>
中查找是否存在，存在就返回对应的 <code>itab</code>，不存在则新建一个
<code>itab</code>。</li>
<li>在调用 <code>itabAdd</code> 的时候，会将 <code>itab</code> 加入到
<code>itabTableType</code> 类型变量里面的 <code>entries</code> 中，其中
<code>entries</code> 里面的键是根据 <code>inter</code> 和
<code>_type</code> 做哈希运算得出的。</li>
</ul>
<p><code>itab</code> 两个比较关键的方法：</p>
<ul>
<li><code>getitab</code> 让我们可以通过 <code>interfacetype</code> 和
<code>_type</code> 获取一个
<code>itab</code>，会现在缓存中找，找不到会新建一个。</li>
<li><code>itabAdd</code> 是在我们缓存找不到
<code>itab</code>，然后新建之后，将这个新建的 <code>itab</code>
加入到缓存的方法。</li>
</ul>
<p><code>getitab</code> 方法的第三个参数 <code>canfail</code>
表示当前操作是否允许失败，上面说了，如果是用在
<code>switch...case</code> 或者 <code>v, ok := i.(T)</code>
这种是允许失败的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取某一个类型的 itab（从 itabTable 中查找，键是 inter 和 _type 的哈希值）</span></span><br><span class="line"><span class="comment">// 查找 interfacetype + _type 对应的 itab</span></span><br><span class="line"><span class="comment">// 找不到就新增。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getitab</span><span class="params">(inter *interfacetype, typ *_type, canfail <span class="type">bool</span>)</span></span> *itab &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(inter.mhdr) == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;internal error - misuse of itab&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不包含 Uncommon 信息的类型直接报错</span></span><br><span class="line">	<span class="keyword">if</span> typ.tflag&amp;tflagUncommon == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> canfail &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		name := inter.typ.nameOff(inter.mhdr[<span class="number">0</span>].name)</span><br><span class="line">		<span class="built_in">panic</span>(&amp;TypeAssertionError&#123;<span class="literal">nil</span>, typ, &amp;inter.typ, name.name()&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存返回的 itab</span></span><br><span class="line">	<span class="keyword">var</span> m *itab</span><br><span class="line"></span><br><span class="line">	<span class="comment">// t 指向了 itabTable（全局的 itab 表）</span></span><br><span class="line">	t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(&amp;itabTable)))</span><br><span class="line">	<span class="comment">// 会先从全局 itab 表中查找，找到就直接返回</span></span><br><span class="line">	<span class="keyword">if</span> m = t.find(inter, typ); m != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> finish</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 没有找到，获取锁，再次查找。</span></span><br><span class="line">	<span class="comment">// 找到则返回</span></span><br><span class="line">	lock(&amp;itabLock)</span><br><span class="line">	<span class="keyword">if</span> m = itabTable.find(inter, typ); m != <span class="literal">nil</span> &#123;</span><br><span class="line">		unlock(&amp;itabLock)</span><br><span class="line">		<span class="keyword">goto</span> finish</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 没有在缓存中找到，新建一个 itab</span></span><br><span class="line">	m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="type">uintptr</span>(<span class="built_in">len</span>(inter.mhdr)<span class="number">-1</span>)*goarch.PtrSize, <span class="number">0</span>, &amp;memstats.other_sys))</span><br><span class="line">	<span class="comment">// itab 的</span></span><br><span class="line">	m.inter = inter</span><br><span class="line">	m._type = typ</span><br><span class="line">	m.hash = <span class="number">0</span></span><br><span class="line">	<span class="comment">// itab 初始化</span></span><br><span class="line">	m.init()</span><br><span class="line">	<span class="comment">// 将新创建的 itab 加入到全局的 itabTable 中</span></span><br><span class="line">	itabAdd(m)</span><br><span class="line">	<span class="comment">// 释放锁</span></span><br><span class="line">	unlock(&amp;itabLock)</span><br><span class="line">finish:</span><br><span class="line">	<span class="comment">// == 0 表示没有任何方法</span></span><br><span class="line">	<span class="comment">// 下面 != 0 表示有 inter 和 typ 有方法的交集</span></span><br><span class="line">	<span class="keyword">if</span> m.fun[<span class="number">0</span>] != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> m</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 用在 switch x.(type) 中的时候，允许失败而不是直接 panic</span></span><br><span class="line">	<span class="comment">// 但在 x.(Flyable).Fly() 这种场景会直接 panic</span></span><br><span class="line">	<span class="keyword">if</span> canfail &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 没有找到有方法的交集，panic</span></span><br><span class="line">	<span class="built_in">panic</span>(&amp;TypeAssertionError&#123;concrete: typ, asserted: &amp;inter.typ, missingMethod: m.init()&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>itabAdd</code> 将给定的 <code>itab</code> 添加到
<code>itab</code> 哈希表中（<code>itabTable</code>）。</p>
<blockquote>
<p>注意：<code>itabAdd</code> 中在判断到哈希表的使用量超过
<code>75%</code> 的时候，会进行扩容，新的容量为旧容量的 2 倍。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须保持 itabLock。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabAdd</span><span class="params">(m *itab)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 正在分配内存的时候调用的话报错</span></span><br><span class="line">	<span class="keyword">if</span> getg().m.mallocing != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;malloc deadlock&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t := itabTable</span><br><span class="line">	<span class="comment">// 容量已经超过 75% 的负载了，hash 表扩容</span></span><br><span class="line">	<span class="keyword">if</span> t.count &gt;= <span class="number">3</span>*(t.size/<span class="number">4</span>) &#123;</span><br><span class="line">		<span class="comment">// 75% load factor（实际上是：t.size *0.75）</span></span><br><span class="line">		<span class="comment">// 扩展哈希表。原来 2 倍大小。</span></span><br><span class="line">		<span class="comment">// 我们撒谎告诉 malloc 我们需要无指针内存，因为所有指向的值都不在堆中。</span></span><br><span class="line">		<span class="comment">// 2 是 size 和 count 这两个字段需要的空间</span></span><br><span class="line">		t2 := (*itabTableType)(mallocgc((<span class="number">2</span>+<span class="number">2</span>*t.size)*goarch.PtrSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		t2.size = t.size * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 复制条目。</span></span><br><span class="line">		<span class="comment">// 注意：在复制时，其他线程可能会查找itab，但找不到它。</span></span><br><span class="line">		<span class="comment">// 没关系，然后它们会尝试获取itab锁，因此等待复制完成。</span></span><br><span class="line">		iterate_itabs(t2.add)    <span class="comment">// 遍历旧的 hash 表，复制函数指针到 t2 中</span></span><br><span class="line">		<span class="keyword">if</span> t2.count != t.count &#123; <span class="comment">// 复制出错</span></span><br><span class="line">			throw(<span class="string">&quot;mismatched count during itab table copy&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发布新哈希表。使用原子写入：请参见 getitab 中的注释。</span></span><br><span class="line">		<span class="comment">// 使用 t2 覆盖 itabTable</span></span><br><span class="line">		atomicstorep(unsafe.Pointer(&amp;itabTable), unsafe.Pointer(t2))</span><br><span class="line">		<span class="comment">// 使用新的 hash 表</span></span><br><span class="line">		<span class="comment">// 因为 t 是局部变量，指向旧的地址，</span></span><br><span class="line">		<span class="comment">// 但是扩容之后是新的地址了，所以现在需要将新的地址赋给 t</span></span><br><span class="line">		t = itabTable</span><br><span class="line">		<span class="comment">// 注：旧的哈希表可以在此处进行GC。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 itab 加入到全局哈希表</span></span><br><span class="line">	t.add(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 <code>itabAdd</code>
的关键路径比较清晰，只是因为它是一个哈希表，所以里面在判断到当前
<code>itab</code> 的数量超过 <code>itabTable</code> 容量的
<code>75%</code> 的时候，会对 <code>itabTable</code> 进行 2 倍扩容。</p>
<h2 id="根据-interfacetype-和-_type-初始化-itab">根据 interfacetype 和
_type 初始化 itab</h2>
<p>上面那个图我们说过，<code>itab</code> 本质上是
<code>interfacetype</code> 和 <code>_type</code>
方法的交集，这一节我们就来看看，<code>itab</code>
是怎么根据这两个类型来进行初始化的。</p>
<p><code>itab</code> 的 <code>init</code> 方法实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init 用 m.inter/m._type 对的所有代码指针填充 m.fun 数组。</span></span><br><span class="line"><span class="comment">// 如果该类型不实现接口，它将 m.fun[0] 设置为 0 ，并返回缺少的接口函数的名称。</span></span><br><span class="line"><span class="comment">// 可以在同一个m上多次调用，甚至同时调用。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *itab)</span></span> init() <span class="type">string</span> &#123;</span><br><span class="line">	inter := m.inter    <span class="comment">// 接口</span></span><br><span class="line">	typ := m._type      <span class="comment">// 实际的类型</span></span><br><span class="line">	x := typ.uncommon()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// inter 和 typ 都具有按名称排序的方法，并且接口名称是唯一的，因此可以在锁定步骤中迭代这两个；</span></span><br><span class="line">	<span class="comment">// 循环时间复杂度是 O(ni+nt)，不是 O(ni*nt)</span></span><br><span class="line">	ni := <span class="built_in">len</span>(inter.mhdr) <span class="comment">// 接口的方法数量</span></span><br><span class="line">	nt := <span class="type">int</span>(x.mcount)   <span class="comment">// 实际类型的方法数量</span></span><br><span class="line">	<span class="comment">// 实际类型的方法数组，数组元素为 method</span></span><br><span class="line">	xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]method)(add(unsafe.Pointer(x), <span class="type">uintptr</span>(x.moff)))[:nt:nt] <span class="comment">// 大小无关紧要，因为下面的指针访问不会超出范围</span></span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line">	<span class="comment">// 用来保存 inter/_type 对方法列表的数组，数组元素为 unsafe.Pointer（是实际类型方法的指针）</span></span><br><span class="line">	methods := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]unsafe.Pointer)(unsafe.Pointer(&amp;m.fun[<span class="number">0</span>]))[:ni:ni] <span class="comment">// 保存 itab 方法的数组</span></span><br><span class="line">	<span class="comment">// 第一个方法的指针</span></span><br><span class="line">	<span class="keyword">var</span> fun0 unsafe.Pointer</span><br><span class="line">imethods:</span><br><span class="line">	<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123; <span class="comment">// 接口方法遍历</span></span><br><span class="line">		i := &amp;inter.mhdr[k]                <span class="comment">// i 是接口方法， imethod 类型</span></span><br><span class="line">		itype := inter.typ.typeOff(i.ityp) <span class="comment">// 接口的方法类型</span></span><br><span class="line">		name := inter.typ.nameOff(i.name)  <span class="comment">// 接口的方法名称</span></span><br><span class="line">		iname := name.name()               <span class="comment">// 接口的方法名</span></span><br><span class="line">		ipkg := name.pkgPath()             <span class="comment">// 接口的包路径</span></span><br><span class="line">		<span class="keyword">if</span> ipkg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			ipkg = inter.pkgpath.name()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据接口方法查找实际类型的方法</span></span><br><span class="line">		<span class="keyword">for</span> ; j &lt; nt; j++ &#123; <span class="comment">// 实际类型的方法遍历</span></span><br><span class="line">			t := &amp;xmhdr[j]               <span class="comment">// t 是实际类型的方法，method 类型</span></span><br><span class="line">			tname := typ.nameOff(t.name) <span class="comment">// 实际类型的方法名</span></span><br><span class="line">			<span class="comment">// 比较接口的方法跟实际类型的方法是否一致</span></span><br><span class="line">			<span class="keyword">if</span> typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</span><br><span class="line">				<span class="comment">// 实际类型的包路径</span></span><br><span class="line">				pkgPath := tname.pkgPath()</span><br><span class="line">				<span class="keyword">if</span> pkgPath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">					pkgPath = typ.nameOff(x.pkgpath).name()</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 如果是导出的方法</span></span><br><span class="line">				<span class="comment">// 则保存到 itab 中</span></span><br><span class="line">				<span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line">					<span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</span><br><span class="line">						ifn := typ.textOff(t.ifn) <span class="comment">// 实际类型的方法指针（通过这个指针可以调用实际类型的方法）</span></span><br><span class="line">						<span class="keyword">if</span> k == <span class="number">0</span> &#123;</span><br><span class="line">							<span class="comment">// 第一个方法</span></span><br><span class="line">							fun0 = ifn <span class="comment">// we&#x27;ll set m.fun[0] at the end</span></span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							methods[k] = ifn</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 比较下一个方法</span></span><br><span class="line">					<span class="keyword">continue</span> imethods</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 没有实现接口（实际类型没有实现 interface 中的任何一个方法）</span></span><br><span class="line">		m.fun[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">		<span class="keyword">return</span> iname <span class="comment">// 返回缺失的方法名，返回值在类型断言失败的时候会需要提示用户</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 实现了接口</span></span><br><span class="line">	m.fun[<span class="number">0</span>] = <span class="type">uintptr</span>(fun0)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="接口断言过程总览类型转换的关键">接口断言过程总览（类型转换的关键）</h2>
<p>具体来说有四种情况，对应上面提到的 <code>runtime.assert*</code>
方法：</p>
<ul>
<li>实际类型转换到 <code>iface</code></li>
<li><code>iface</code> 转换到另一个 <code>iface</code></li>
<li>实际类型转换到 <code>eface</code></li>
<li><code>eface</code> 转换到 <code>iface</code></li>
</ul>
<blockquote>
<p>这其中的关键是 <code>interfacetype</code> + <code>_type</code>
可以生成一个 <code>itab</code>。</p>
</blockquote>
<p>上面的内容可能有点混乱，让人摸不着头脑，但是我们通过上面的讲述，相信已经了解了
go 接口中底层的一些实现细节，现在，就让我们重新来捋一下，看看 go
接口到底是怎么实现的：</p>
<p>首先，希望我们可以达成的一个共识就是，<strong>go
的接口断言本质上是类型转换，<code>switch...case</code> 里面或
<code>v, ok := i.(T)</code> 允许转换失败，而 <code>i.(T).xx()</code>
这种不允许转换失败，转换失败的时候会 <code>panic</code></strong>。</p>
<p>接着，我们就可以通过下图来了解 go
里面的接口整体的实现原理了（还是以上面的代码作为例子）：</p>
<ol type="1">
<li>将结构体赋值给接口类型：<code>var f Flyable = Bird&#123;&#125;</code></li>
</ol>
<p><img src="/images/go/interface/interface_12.png" /></p>
<p>在这个赋值过程中，创建了一个 <code>iface</code>
类型的变量，这个变量中的 <code>itab</code> 的方法表只包含了
<code>Flyable</code> 定义的方法。</p>
<ol start="2" type="1">
<li><code>iface</code> 转另一个 <code>iface</code>:</li>
</ol>
<ul>
<li><code>f.(Runnable)</code></li>
<li><code>_, ok := f.(Runnable)</code></li>
<li><code>switch f.(type)</code> 里面的 <code>case</code> 是
<code>Runnable</code></li>
</ul>
<p><img src="/images/go/interface/interface_13.png" /></p>
<p>在这个断言过程中，会将 <code>Flyable</code> 转换为
<code>Runnable</code>，本质上是一个 <code>iface</code> 转换到另一个
<code>iface</code>。但是有个不同之处在于， 两个 <code>iface</code>
里面的方法列表是不一样的，只包含了当前 <code>interfacetype</code>
里面定义的方法。</p>
<ol start="3" type="1">
<li>将结构体赋值给空接口：<code>var i interface&#123;&#125; = Bird&#123;&#125;</code></li>
</ol>
<p>在这个过程中，创建了一个 <code>eface</code> 类型的变量，这个
<code>eface</code> 里面只包含了类型信息以及实际的 <code>Bird</code>
结构体实例。</p>
<p><img src="/images/go/interface/interface_14.png" /></p>
<ol start="4" type="1">
<li><code>eface</code> 转换到 <code>iface</code></li>
</ol>
<ul>
<li><code>i.(Flyable)</code></li>
<li><code>_, ok := i.(Runnable)</code></li>
<li><code>switch i.(type)</code> 里面的 <code>case</code> 是
<code>Flyable</code></li>
</ul>
<p>因为 <code>_type</code> 包含了 <code>Bird</code> 类型的所有信息，而
<code>data</code> 包含了 <code>Bird</code>
实例的值，所以这个转换是可行的。</p>
<p><img src="/images/go/interface/interface_15.png" /></p>
<h2 id="panicdottypei-与-panicdottypee">panicdottypeI 与
panicdottypeE</h2>
<p>从前面的几个小节，我们知道，go 的 <code>iface</code> 类型转换使用的是
<code>runtime.assert*</code> 几个方法，还有另外一种情况就是，
在编译期间编译器就已经知道了无法转换成功的情况，比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Flyable <span class="keyword">interface</span> &#123;</span><br><span class="line">	Fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Fly() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> test() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GOOS=linux GOARCH=amd64 go tool compile -N -S -l main.go &gt; main.s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> _ = b.(<span class="type">int</span>) <span class="comment">// CALL	runtime.panicdottypeE(SB)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c Flyable = &amp;Cat&#123;&#125;</span><br><span class="line">	c.(Cat).test() <span class="comment">// CALL	runtime.panicdottypeI(SB)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的两个转换都是错误的，第一个 <code>b.(int)</code> 尝试将
<code>nil</code> 转换为 <code>int</code> 类型，第二个尝试将
<code>*Cat</code> 类型转换为 <code>Cat</code> 类型，
这两个错误的类型转换都在编译期可以发现，因此它们生成的汇编代码调用的是
<code>runtime.panicdottypeE</code> 和 <code>runtime.panicdottypeI</code>
方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在执行 e.(T) 转换时如果转换失败，则调用 panicdottypeE</span></span><br><span class="line"><span class="comment">// have：我们的动态类型。</span></span><br><span class="line"><span class="comment">// want：我们试图转换为的静态类型。</span></span><br><span class="line"><span class="comment">// iface：我们正在转换的静态类型。</span></span><br><span class="line"><span class="comment">// 转换的过程：尝试将 iface 的 have 转换为 want 失败了。</span></span><br><span class="line"><span class="comment">// 不是调用方法的时候的失败。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicdottypeE</span><span class="params">(have, want, iface *_type)</span></span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(&amp;TypeAssertionError&#123;iface, have, want, <span class="string">&quot;&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当执行 i.(T) 转换并且转换失败时，调用 panicdottypeI</span></span><br><span class="line"><span class="comment">// 跟 panicdottypeE 参数相同，但是 hava 是动态的 itab 类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicdottypeI</span><span class="params">(have *itab, want, iface *_type)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> t *_type</span><br><span class="line">	<span class="keyword">if</span> have != <span class="literal">nil</span> &#123;</span><br><span class="line">		t = have._type</span><br><span class="line">	&#125;</span><br><span class="line">	panicdottypeE(t, want, iface)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法都是引发一个
<code>panic</code>，因为我们的类型转换失败了：</p>
<p><img src="/images/go/interface/interface_16.png" /></p>
<h2 id="iface-和-eface-里面的-data-是怎么来的">iface 和 eface 里面的
data 是怎么来的？</h2>
<p>我们先看看下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bird)</span></span> Fly() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Flyable <span class="keyword">interface</span> &#123;</span><br><span class="line">	Fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GOOS=linux GOARCH=amd64 go tool compile -N -S -l main.go &gt; main.s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bird := Bird&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> efc <span class="keyword">interface</span>&#123;&#125; = bird <span class="comment">// CALL	runtime.convT(SB)</span></span><br><span class="line">	<span class="keyword">var</span> ifc Flyable = bird     <span class="comment">// CALL	runtime.convT(SB)</span></span><br><span class="line">	<span class="built_in">println</span>(efc, ifc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们生成伪汇编代码发现，里面将结构体变量赋值给接口类型变量的时候，实际上是调用了
<code>convT</code> 方法。</p>
<h2 id="convt-方法">convT* 方法</h2>
<p><code>iface</code> 里面还包含了几个 <code>conv*</code>
前缀的函数，在我们将某一具体类型的值赋值给接口类型的时候，go
底层会将具体类型的值通过 <code>conv*</code> 函数转换为
<code>iface</code> 里面的 <code>data</code> 指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// convT 将 v 指向的 t 类型的值转换为可以用作接口值的第二个字的指针（接口的第二个字是指向 data 的指针）。</span></span><br><span class="line"><span class="comment">// data(Pointer) =&gt; 指向 interface 第 2 个字的 Pointer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT</span><span class="params">(t *_type, v unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="comment">// ... 其他代码</span></span><br><span class="line">	<span class="comment">// 分配 _type 类型所需要的内存</span></span><br><span class="line">	x := mallocgc(t.size, t, <span class="literal">true</span>)</span><br><span class="line">	<span class="comment">// 将 v 指向的值复制到刚刚分配的内存上</span></span><br><span class="line">	typedmemmove(t, x, v)</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，在这个过程，实际上是将值复制了一份：</p>
<p><img src="/images/go/interface/interface_17.png" /></p>
<p><code>iface.go</code> 里面还有将无符号值转换为 <code>data</code>
指针的函数，但是还不知道在什么地方会用到这些方法，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换 uint16 类型值为 interface 里面 data 的指针。</span></span><br><span class="line"><span class="comment">// 如果是 0～255 的整数，返回指向 staticuint64s 数组里面对应下标的指针。</span></span><br><span class="line"><span class="comment">// 否则，分配新的内存地址。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT16</span><span class="params">(val <span class="type">uint16</span>)</span></span> (x unsafe.Pointer) &#123;</span><br><span class="line">	<span class="comment">// 如果小于 256，则使用共享的内存地址</span></span><br><span class="line">	<span class="keyword">if</span> val &lt; <span class="type">uint16</span>(<span class="built_in">len</span>(staticuint64s)) &#123;</span><br><span class="line">		x = unsafe.Pointer(&amp;staticuint64s[val])</span><br><span class="line">		<span class="keyword">if</span> goarch.BigEndian &#123;</span><br><span class="line">			x = add(x, <span class="number">6</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 否则，分配新的内存</span></span><br><span class="line">		x = mallocgc(<span class="number">2</span>, uint16Type, <span class="literal">false</span>)</span><br><span class="line">		*(*<span class="type">uint16</span>)(x) = val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人猜测，仅仅代表个人猜测，在整数赋值给 <code>iface</code> 或者
<code>eface</code>
的时候会调用这类方法。不管调不调用，我们依然可以看看它的设计，因为有些值得学习的地方：</p>
<p><code>staticuint64s</code> 是一个全局整型数组，里面存储的是
<code>0~255</code> 的整数。上面的代码可以表示为下图：</p>
<p><img src="/images/go/interface/interface_18.png" /></p>
<p>这个函数跟上面的 <code>convT</code>
的不同之处在于，它在判断整数如果小于 <code>256</code> 的时候，则使用的是
<code>staticuint64s</code> 数组里面对应下标的地址。
为什么这样做呢？本质上是为了节省内存，因为对于数字来说，其实除了值本身，没有包含其他的信息了，所以如果对于每一个整数都分配新的内存来保存，
无疑会造成浪费。按 <code>convT16</code> 里面的实现方式，对于
<code>0~255</code>
之间的整数，如果需要给它们分配内存，就可以使用同一个指针（指向
<code>staticuint64s[]</code> 数组中元素的地址）。</p>
<blockquote>
<p>这实际上是享元模式。</p>
</blockquote>
<h3 id="java-里面的小整数享元模式">Java 里面的小整数享元模式</h3>
<p>go 里使用 <code>staticuint64s</code> 的方式，其实在 Java
里面也有类似的实现，Java 中对于小整数也是使用了享元模式，
这样在装箱的时候，就不用分配新的内存了，就可以使用共享的一块内存了，当然，某一个整数能节省的内存非常有限，如果需要分配内存的小整数非常大，那么节省下来的内存就非常客观了。
当然，也不只是能节省内存这唯一的优点，从另一方面说，它也节省了垃圾回收器回收内存的开销，因为不需要管理那么多内存。</p>
<p>我们来看看 Java 中的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">k1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">k2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        System.out.println(k1 == k2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(k1.equals(k2)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">k10</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">k20</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.println(k10 == k20); <span class="comment">// false</span></span><br><span class="line">        System.out.println(k10.equals(k20)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 里面有点不一样，它是对 <code>-128~127</code>
范围内的整数做了享元模式的处理，而 go 里面是 <code>0~255</code>。</p>
<p>上面的代码中，当我们使用 <code>==</code> 来比较 <code>Integer</code>
的时候，值相等的两个数，在 <code>-128~127</code> 的范围的时候，返回的是
<code>true</code>，超出这个范围的时候比较返回的是 <code>false</code>。
这是因为在 <code>-128~127</code>
的时候，值相等的两个数字指向了相同的内存地址，超出这个范围的时候，值相等的两个数指向了不同的地址。</p>
<p>Java 的详细实现可以看
<code>java.lang.Integer.IntegerCache</code>。</p>
<h2 id="总结">总结</h2>
<ul>
<li>go 的的接口（<code>interface</code>）本质上是一种结构体，底册实现是
<code>iface</code> 和 <code>eface</code>，<code>iface</code>
表示我们通过 <code>type i interface&#123;&#125;</code> 定义的接口，而
<code>eface</code> 表示
<code>interface&#123;&#125;/any</code>，也就是空接口。</li>
<li><code>iface</code> 里面保存的 <code>itab</code>
中保存了具体类型的方法指针列表，<code>data</code>
保存了具体类型值的内存地址。</li>
<li><code>eface</code> 里面保存的 <code>_type</code>
包含了具体类型的所有信息，<code>data</code>
保存了具体类型值的内存地址。</li>
<li><code>itab</code>
是底层保存接口类型跟具体类型方法交集的结构体，如果具体类型实现了接口的所有方法，那么这个
<code>itab</code>
里面的保存有指向具体类型方法的指针。如果具体类型没有实现接口的全部方法，那么
<code>itab</code> 中的不会保存任何方法的指针（从 <code>itab</code>
的作用上看，我们可以看作是一个空的 <code>itab</code>）。</li>
<li>不管 <code>itab</code>
的方法列表是否为空，<code>interfacetype</code> 和 <code>_type</code>
比较之后生成的 <code>itab</code>
会缓存下来，在后续比较的时候可以直接使用缓存。</li>
<li><code>_type</code> 是 go
底层用来表示某一个类型的结构体，包含了类型所需空间大小等信息。</li>
<li>类型断言 <code>i.(T)</code> 本质上是 <code>iface</code> 到
<code>iface</code> 的转换，或者是 <code>eface</code> 到
<code>iface</code>
的转换，如果没有第二个返回值，那么转换失败的时候会引发
<code>panic</code>。</li>
<li><code>switch i.(type) &#123; case ...&#125;</code> 本质上也是
<code>iface</code> 或 <code>eface</code> 到 <code>iface</code>
的转换，但是转换失败的时候不会引发 <code>panic</code>。</li>
<li>全局的保存 <code>itab</code>
的缓存结构体，底层是使用了一个哈希表来保存 <code>itab</code>
的，在哈希表使用超过 <code>75%</code>
的时候，会触发扩容，新的哈希表容量为旧的 <code>2</code> 倍。</li>
<li><code>staticuint64s</code> 使用了享元模式，Java
中也有类似的实现。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/12/02/golang/go%20interface%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/02/golang/go%20interface%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">go interface 基本用法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-02 20:08:30" itemprop="dateCreated datePublished" datetime="2022-12-02T20:08:30+08:00">2022-12-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Go
中接口也是一个使用得非常频繁的特性，好的软件设计往往离不开接口的使用，比如依赖倒置原则（通过抽象出接口，分离了具体实现与实际使用的耦合）。
今天，就来给大家介绍一下 Go 中接口的一些基本用法。</p>
<h2 id="概述">概述</h2>
<p>Go 中的接口跟我们常见的编程语言中的接口不太一样，go
里面实现接口是不需要使用 <code>implements</code> 关键字显式声明的， go
的接口为我们提供了难以置信的一系列的灵活性和抽象性。接口有两个特点：</p>
<ul>
<li><strong>接口本质是一种自定义类型。（跟 Java
中的接口不一样）</strong></li>
<li><strong>接口是一种特殊的自定义类型，其中没有数据成员，只有方法（也可以为空）</strong>。</li>
</ul>
<p>go 中的接口定义方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flyable <span class="keyword">interface</span> &#123;</span><br><span class="line">    Fly() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口是完全抽象的，不能将其实例化。但是我们创建变量的时候可以将其类型声明为接口类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a Flyable</span><br></pre></td></tr></table></figure>
<p>然后，对于接口类型变量，我们可以把任何实现了接口所有方法的类型变量赋值给它，这个过程不需要显式声明。
例如，假如 <code>Bird</code> 实现了 <code>Fly</code>
方法，那么下面的赋值就是合法的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bird 实现了 Flyable 的所有方法</span></span><br><span class="line"><span class="keyword">var</span> a Flyable = Bird&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>go 实现接口不需要显式声明。</p>
</blockquote>
<p>由此我们引出 go 接口的最重要的特性是：</p>
<ul>
<li><strong>只要某个类型实现了接口的所有方法，那么我们就说该类型实现了此接口。该类型的值可以赋给该接口的值。</strong></li>
<li><strong>因为 interface{}
没有任何方法，所以任何类型的值都可以赋值给它（类似 Java 中的
Object）</strong></li>
</ul>
<h2 id="基本使用">基本使用</h2>
<h3 id="java-中的-interface接口">Java 中的 interface（接口）</h3>
<blockquote>
<p>先看看其他语言中的 interface 是怎么使用的。</p>
</blockquote>
<p>我们知道，很多编程语言里面都有 <code>interface</code>
这个关键字，表示的是<strong>接口</strong>，应该也用过，比如 Java
里面的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 Flyable 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个名为 Bird 的类，显式实现了 Flyable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>  <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird fly.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// fly 方法接收一个实现了 Flyable 接口的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(Flyable flyable)</span> &#123;</span><br><span class="line">        flyable.fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        <span class="comment">// b 实现了 Flyable 接口，所以可以作为 fly 的参数</span></span><br><span class="line">        fly(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个 <code>Flyable</code>
接口，然后定义了一个实现了 <code>Flyable</code> 接口的 <code>Bird</code>
类， 最后，定义了一个测试的类，这个类的 <code>fly</code> 方法接收一个
<code>Flyable</code> 接口类型的参数， 因为 <code>Bird</code> 类实现了
<code>Flyable</code> 接口，所以可以将 <code>b</code> 作为参数传递给
<code>fly</code> 方法。</p>
<p>这个例子就是 Java 中 <code>interface</code>
的典型用法，如果一个类要实现一个接口，我们必须显式地通过
<code>implements</code> 关键字来声明。
然后使用的时候，对于需要某一接口类型的参数的方法，我们可以传递实现了那个接口的对象进去。</p>
<blockquote>
<p>Java 中类实现接口必须显式通过 <code>implements</code>
关键字声明。</p>
</blockquote>
<h3 id="go-中的-interface接口">go 中的 interface（接口）</h3>
<p>go 里面也有 <code>interface</code> 这个关键字，但是 go
与其他语言不太一样。 go 里面结构体与接口之间不需要显式地通过
<code>implements</code> 关键字来声明的，<strong>在 go
中，只要一个结构体实现了 <code>interface</code>
的所有方法，我们就可以将这个结构体当做这个 <code>interface</code>
类型</strong>，比如下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 Flyable 接口</span></span><br><span class="line"><span class="keyword">type</span> Flyable <span class="keyword">interface</span> &#123;</span><br><span class="line">	Fly() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bird 结构体没有显式声明实现了 Flyable 接口（没有 implements 关键字）</span></span><br><span class="line"><span class="comment">// 但是 Bird 定义了 Fly() 方法，</span></span><br><span class="line"><span class="comment">// 所以可以作为下面 fly 函数的参数使用。</span></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bird)</span></span> Fly() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;bird fly.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要实现了 Flyable 的所有方法，</span></span><br><span class="line"><span class="comment">// 就可以作为 output 的参数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">(f Flyable)</span></span> &#123;</span><br><span class="line">	fmt.Println(f.Fly())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b = Bird&#123;&#125;</span><br><span class="line">	<span class="comment">// 在 go 看来，b 实现了 Fly 接口，</span></span><br><span class="line">	<span class="comment">// 因为 Bird 里面实现了 Fly 接口的所有方法。</span></span><br><span class="line">	fly(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>Person</code> 结构体实现了
<code>Stringer</code> 接口的所有方法，所以在需要 <code>Stringer</code>
接口的地方，都可以用 <code>Person</code> 的实例作为参数。</p>
<blockquote>
<p>Go 中结构体实现接口不用通过 <code>implements</code>
关键字声明。（实际上，Go 也没有这个关键字）</p>
</blockquote>
<p><img src="/images/go/interface/interface_1.png" /></p>
<h3 id="go-interface-的优势">go interface 的优势</h3>
<p>go 接口的这种实现方式，有点类似于动态类型的语言，比如
Python，但是相比 Python，go 在编译期间就可以发现一些明显的错误。</p>
<p>比如像 Python 中下面这种代码，如果传递的 <code>coder</code> 没有
<code>say_hello</code> 方法，这种错误只有运行时才能发现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">coder</span>):</span><br><span class="line">    coder.say_hello()</span><br></pre></td></tr></table></figure>
<p>但如果是 go 的话，下面这种写法中，如果传递给 <code>hello_world</code>
没有实现 <code>say</code>
接口，那么编译的时候就会报错，无法通过编译：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> say <span class="keyword">interface</span> &#123;</span><br><span class="line">	say_hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello_world</span><span class="params">(coder say)</span></span> &#123;</span><br><span class="line">	coder.say_hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，go
的这种接口实现方式有点像动态类型的语言，在一定程度上给了开发者自由，但是也在语言层面帮开发者做了类型检查。</p>
<blockquote>
<p>go 中不必像静态类型语言那样，所有地方都明确写出类型，go
的编译器帮我们做了很多工作，让我们在写 go 代码的时候更加的轻松。
interface
也是，我们无需显式实现接口，只要我们的结构体实现了接口的所有类型，那么它就可以当做那个接口类型使用（duck
typing）。</p>
</blockquote>
<h2 id="空接口">空接口</h2>
<p>go 中的 <code>interface&#123;&#125;</code>
表示一个空接口（在比较新版本中也可以使用 <code>any</code> 关键字来代替
<code>interface&#123;&#125;</code>），这个接口没有任何方法。因此可以将任何变量赋值给
<code>interface&#123;&#125;</code> 类型的变量。</p>
<p>这在一些允许不同类型或者不确定类型参数的方法中用得比较广泛，比如
<code>fmt</code> 里面的 <code>println</code> 等方法。</p>
<h2 id="如何使用-interface-类型的参数">如何使用 interface{}
类型的参数？</h2>
<p>这个可能是大部分人所需要关心的地方，因为这可能在日常开发中经常需要用到。</p>
<h3 id="类型断言">类型断言</h3>
<p>当实际开发中，我们接收到一个接口类型参数的时候，我们可能会知道它是几种可能的情况之一了，我们就可以使用类型断言来判断
<code>interface&#123;&#125;</code> 变量是否实现了某一个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">(f <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 第一个返回值 v 是 f 转换为接口之前的值，</span></span><br><span class="line">	<span class="comment">// ok 为 true 表示 f 是 Bird 类型</span></span><br><span class="line">	<span class="keyword">if</span> v, ok := f.(Flyable); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;bird &quot;</span> + v.Fly())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断言形式：接口.(类型)</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := f.(Bird); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;bird flying...&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际开发中，我们可以使用 <code>xx.(Type)</code>
这种形式来判断：</p>
<ul>
<li><code>interface&#123;&#125;</code> 类型的变量是否是某一个类型</li>
<li><code>interface&#123;&#125;</code> 类型的变量是否实现了某一个接口</li>
</ul>
<p>如，<code>f.(Flyable)</code> 就是判断 <code>f</code> 是否实现了
<code>Flyable</code> 接口，<code>f.(Bird)</code> 就是判断 <code>f</code>
是否是 <code>Bird</code> 类型。</p>
<h3 id="另外一种类型断言方式">另外一种类型断言方式</h3>
<p>可能我们会觉得上面的那种 <code>if</code>
的判断方式有点繁琐，确实如此，但是如果我们不能保证 <code>f</code>
是某一类型的情况下，用上面这种判断方式是比较安全的。</p>
<p>还有另外一种判断方式，用在我们确切地知道 <code>f</code>
具体类型的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fly2</span><span class="params">(f <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;bird &quot;</span> + f.(Flyable).Fly())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们断言 <code>f</code> 是 <code>Flyable</code>
类型，然后调用了它的 <code>Fly</code> 方法。</p>
<p>这是一种不安全的调用，<strong>如果 <code>f</code> 实际上没有实现了
<code>Flyable</code> 接口，上面这行代码会引发
<code>panic</code></strong>。
而相比之下，<code>v, ok := f.(Flyable)</code>
这种方式会返回第二个值让我们判断这个断言是否成立。</p>
<h3 id="switch...case-中判断接口类型">switch...case 中判断接口类型</h3>
<p>除了上面的断言方式，还有另外一种判断 <code>interface&#123;&#125;</code>
类型的方法，那就是使用 <code>switch...case</code> 语句：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">str</span><span class="params">(f <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 判断 f 的类型</span></span><br><span class="line">	<span class="keyword">switch</span> f.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		<span class="comment">// f 是 int 类型</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;int: &quot;</span> + strconv.Itoa(f.(<span class="type">int</span>))</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int64</span>:</span><br><span class="line">		<span class="comment">// f 是 int64 类型</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;int64: &quot;</span> + strconv.FormatInt(f.(<span class="type">int64</span>), <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">case</span> Flyable:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;flyable...&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;???&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="编译器自动检测类型是否实现接口">编译器自动检测类型是否实现接口</h2>
<p>上面我们说过了，在 go
里面，类型不用显式地声明实现了某个接口（也不能）。那么问题来了，我们开发的时候，
如果我们就是想让某一个类型实现某个接口的时候，但是漏实现了一个方法的话，IDE
是没有办法知道我们漏了的那个方法的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flyable <span class="keyword">interface</span> &#123;</span><br><span class="line">	Fly() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有实现 Flyable 接口，因为没有 Fly() 方法</span></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bird)</span></span> Eat() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;eat.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如这段代码中，我们本意是要 <code>Bird</code> 也实现
<code>Fly</code> 方法的，但是因为没有显式声明，所以 IDE
没有办法知道我们的意图。 这样一来，在实际运行的时候，那些我们需要
<code>Flyable</code> 的地方，如果我们传了 <code>Bird</code>
实例的话，就会报错了。</p>
<h3 id="一种简单的解决方法">一种简单的解决方法</h3>
<p>如果我们明确知道 <code>Bird</code> 将来是要当做 <code>Flyable</code>
参数使用的话，我们可以加一行声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ Flyable = Bird&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，因为我们有 <code>Bird</code> 转 <code>Flyable</code>
类型的操作，所以编译器就会去帮我们检查 <code>Bird</code> 是否实现了
<code>Flyable</code> 接口了。 如果 <code>Bird</code> 没有实现
<code>Flyable</code>
中的所有方法，那么编译的时候会报错，<strong>这样一来，这些错误就不用等到实际运行的时候才能发现了</strong>。</p>
<blockquote>
<p>实际上，很多开源项目都能看到这种写法。看起来定义了一个空变量，但是实际上却可以帮我们进行类型检查。</p>
</blockquote>
<p>这种解决方法还有另外一种写法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ Flyable = (*Bird)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<h3 id="类型转换与接口断言">类型转换与接口断言</h3>
<p>我们知道了，接口断言可以获得一个具体类型（也可以是接口）的变量，同时我们也知道了，在
go 里面也有类型转换这东西，
实际上，接口断言与类型转换都是类型转换，它们的差别只是：</p>
<p><code>interface&#123;&#125;</code>
只能通过类型断言来转换为某一种具体的类型，而一般的类型转换只是针对普通类型之间的转换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型转换：f 由 float32 转换为 int</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float32</span> = <span class="number">10.8</span></span><br><span class="line">i := <span class="type">int</span>(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口的类型断言</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">v, ok := f.(Flyable)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是 interface{}，需要使用类型断言转换为某一具体类型。</p>
</blockquote>
<h2 id="一个类型可以实现多个接口">一个类型可以实现多个接口</h2>
<p>上文我们说过了，只要一个类型实现了接口中的所有方法，那么那个类型就可以当作是那个接口来使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myFile <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了 Writer 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m myFile)</span></span>  Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了 Closer 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m myFile)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>myFile</code> 实现了 <code>Write</code> 和
<code>Close</code> 方法，而这两个方法分别是 <code>Writer</code> 和
<code>Closer</code> 接口中的所有方法。 在这种情况下，<code>myFile</code>
的实例既可以作为 <code>Writer</code> 使用，也可以作为
<code>Closer</code> 使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(w Writer)</span></span> &#123;</span><br><span class="line">	w.Write([]<span class="type">byte</span>(<span class="string">&quot;foo&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">(c Closer)</span></span> &#123;</span><br><span class="line">	c.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := myFile&#123;&#125;</span><br><span class="line">	<span class="comment">// m 可以作为 Writer 接口使用</span></span><br><span class="line">	foo(m)</span><br><span class="line">	<span class="comment">// m 也可以作为 Closer 接口使用</span></span><br><span class="line">	bar(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/go/interface/interface_2.png" /></p>
<h2 id="接口与-nil-不相等">接口与 nil 不相等</h2>
<p>有时候我们会发现，明明传了一个 <code>nil</code> 给
<code>interface&#123;&#125;</code> 类型的参数，但在我们判断实参是否与
<code>nil</code> 相等的时候，却发现并不相等，如下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(reflect.TypeOf(i))</span><br><span class="line">	fmt.Println(i == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b *<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line">	test(b) <span class="comment">// 会输出：*int false</span></span><br><span class="line">	test(<span class="literal">nil</span>) <span class="comment">// 会输出：&lt;nil&gt; true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为 go 里面的 <code>interface&#123;&#125;</code>
实际上是包含两部分的，一部分是 <code>type</code>，一部分是
<code>data</code>，如果我们传递的 <code>nil</code> 是某一个类型的
<code>nil</code>， 那么 <code>interface&#123;&#125;</code>
类型的参数实际上接收到的值会包含对应的类型。 但如果我们传递的
<code>nil</code> 就是一个普通的 <code>nil</code>，那么
<code>interface&#123;&#125;</code> 类型参数接收到的 <code>type</code> 和
<code>data</code> 都为 <code>nil</code>， 这个时候再与 <code>nil</code>
比较的时候才是相等的。</p>
<p><img src="/images/go/interface/interface_3.png" /></p>
<h2 id="嵌套的接口">嵌套的接口</h2>
<p>在 go
中，不仅结构体与结构体之间可以嵌套，接口与接口也可以通过嵌套创造出新的接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个接口包含了 Writer 和 Closer 的所有方法</span></span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WriteCloser</code> 是一个包含了 <code>Writer</code> 和
<code>Closer</code> 两个接口所有方法的新接口，也就是说，
<code>WriteCloser</code> 包含了 <code>Write</code> 和 <code>Close</code>
方法。</p>
<p>这样的好处是，可以将接口拆分为更小的粒度。比如，对于某些只需要
<code>Close</code> 方法的地方，我们就可以用 <code>Closer</code>
作为参数的类型， 即使参数也实现了 <code>Write</code>
方法，因为我们并不关心除了 <code>Close</code> 以外的其他方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(c Closer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	c.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于上面的 <code>myFile</code>，因为同时实现了 <code>Writer</code>
接口和 <code>Closer</code> 接口，而 <code>WriteCloser</code>
包含了这两个接口， 所以实际上 <code>myFile</code> 可以当作
<code>WriteCloser</code> 或者 <code>Writer</code> 或 <code>Closer</code>
类型使用。</p>
<p><img src="/images/go/interface/interface_4.png" /></p>
<h2 id="总结">总结</h2>
<ul>
<li>接口里面只声明了方法，没有数据成员。</li>
<li>go 中的接口不需要显式声明（也不能）。</li>
<li>只要一个类型实现了接口的所有方法，那么该类型实现了此接口。该类型的值可以赋值给该接口类型。</li>
<li><code>interface&#123;&#125;</code>/<code>any</code>
是空接口，任何类型的值都可以赋值给它。</li>
<li>通过类型断言我们可以将 <code>interface&#123;&#125;</code>
类型转换为具体的类型。</li>
<li>我们通过声明接口类型的 <code>_</code>
变量来让编译器帮我们检查我们的类型是否实现了某一接口。</li>
<li>一个类型可以同时实现多个接口，可以当作多个接口类型来使用。</li>
<li><code>nil</code> 与值为 <code>nil</code> 的 <code>interface&#123;&#125;</code>
实际上不想等，需要注意。</li>
<li>go 中的接口可以嵌套，类似结构体的嵌套。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/11/30/golang/go%20chan%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/30/golang/go%20chan%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">go chan 设计与实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-30 20:08:30" itemprop="dateCreated datePublished" datetime="2022-11-30T20:08:30+08:00">2022-11-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在上一篇文章<a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyMTI0MzA4OQ==&amp;mid=2650071997&amp;idx=1&amp;sn=5176840d3b943d5087ce7e9f09dd57d3&amp;chksm=f03ff003c748791551dd3a26ac3f27f9ca79e02e953b4ddcb016d504492888bc391616ad3c35#rd">《深入理解
go chan》</a>中，我们讲解了 <code>chan</code>
相关的一些概念、原理等东西，
今天让我们再深入一下，读一下它的源码，看看底层实际上是怎么实现的。</p>
<h2 id="整体设计">整体设计</h2>
<p>我们可以从以下三个角度看 <code>chan</code> 的设计（源码位于
<code>runtime/chan.go</code>，结构体 <code>hchan</code> 就是
<code>chan</code> 的底层数据结构）：</p>
<ul>
<li>存储：<code>chan</code>
里面的数据是通过一个<strong>环形队列</strong>来存储的（实际上是一个数组，但是我们视作环形队列来操作。无缓冲
<code>chan</code> 不用存储，会直接从 <code>sender</code> 复制到
<code>receiver</code>）</li>
<li>发送：数据发送到 <code>chan</code> 的时候，如果 <code>chan</code>
满了，则会将发送数据的协程挂起，将其放入一个协程队列中，<code>chan</code>
空闲的时候会唤醒这个协程队列。如果 <code>chan</code>
没满，则<strong>发送队列</strong>为空。</li>
<li>接收：从 <code>chan</code> 中接收数据的时候，如果 <code>chan</code>
是空的，则会将接收数据的协程挂起，将其放入一个协程队列中，当
<code>chan</code> 有数据的时候会唤醒这个协程队列。如果 <code>chan</code>
有数据，则<strong>接收队列</strong>为空。</li>
</ul>
<p>文中一些比较关键的名词解释：</p>
<ul>
<li><code>sender</code>: 表示尝试写入 <code>chan</code> 的
<code>goroutine</code>。</li>
<li><code>receiver</code>: 表示尝试从 <code>chan</code> 读取数据的
<code>goroutine</code>。</li>
<li><code>sendq</code> 是一个队列，存储那些尝试写入 <code>channel</code>
但被阻塞的 <code>goroutine</code>。</li>
<li><code>recvq</code> 是一个队列，存储那些尝试读取 <code>channel</code>
但被阻塞的 <code>goroutine</code>。</li>
<li><code>g</code> 表示一个协程。</li>
<li><code>gopark</code>
是将协程挂起的函数，协程状态：<code>_Grunning</code> =&gt;
<code>_Gwaiting</code>。</li>
<li><code>goready</code> 是将协程改为可运行状态的函数，协程状态:
<code>_Gwaiting</code> =&gt; <code>_Grunnable</code>。</li>
</ul>
<p>现在，假设我们有下面这样的一段代码，通过这段代码，我们可以大概看一下
<code>chan</code> 的总体设计：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个缓冲区大小为 9 的 chan</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">9</span>)</span><br><span class="line">	<span class="comment">// 往 chan 写入 [1,2,3,4,5,6,7]</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;</span><br><span class="line">		ch &lt;- i + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 1 从缓冲区移出来</span></span><br><span class="line">	&lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们的 <code>chan</code>
大概长得像下面这个样子，后面会详细展开将这个图中的所有元素：</p>
<p><img src="/images/go/chandesign/design.png" /></p>
<blockquote>
<p>上图为了说明而在 recvq 和 sendq 都画了 3 个 G，但实际上 recvq 和
sendq
至少有一个为空。因为不可能有协程正在等待接收数据的时候，还有协程的数据因为发不出去数据而阻塞。</p>
</blockquote>
<h2 id="数据结构">数据结构</h2>
<p>在底层，go 是使用 <code>hchan</code> 这个结构体来表示
<code>chan</code> 的，下面是结构体的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="type">uint</span>           <span class="comment">// 缓冲区（环形队列）元素个数</span></span><br><span class="line">	dataqsiz <span class="type">uint</span>           <span class="comment">// 缓冲区的大小（最多可容纳的元素个数）</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// 指向缓冲区入口的指针（从 buf 开始 qcount * elemsize 大小的内存就是缓冲区所用的内存）</span></span><br><span class="line">	elemsize <span class="type">uint16</span> <span class="comment">// chan 对应类型元素的大小（主要用以计算第 i 个元素的内存地址）</span></span><br><span class="line">	closed   <span class="type">uint32</span> <span class="comment">// chan 是否已经关闭（0-未关闭，1-已关闭）</span></span><br><span class="line">	elemtype *_type <span class="comment">// chan 的元素类型</span></span><br><span class="line">	sendx    <span class="type">uint</span>   <span class="comment">// chan 发送操作处理到的位置</span></span><br><span class="line">	recvx    <span class="type">uint</span>   <span class="comment">// chan 接收操作处理到的位置</span></span><br><span class="line">	recvq    waitq  <span class="comment">// 等待接收数据的协程队列（双向链表）</span></span><br><span class="line">	sendq    waitq  <span class="comment">// 等待发送数据的协程队列（双向链表）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 锁</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>waitq</code> 的数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>waitq</code>
用来保存阻塞在等待或接收数据的协程列表（是一个双向链表），在解除阻塞的时候，需要唤醒这两个队列中的数据。</p>
<h3 id="对应上图各字段详细说明">对应上图各字段详细说明</h3>
<p><code>hchan</code>，对于 <code>hchan</code> 这个结构体，我们知道，在
go 里面，结构体字段是存储在一段连续的内存上的（可以看看<a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyMTI0MzA4OQ==&amp;mid=2650071981&amp;idx=1&amp;sn=a96c9bb6dc76162451d2944444452b73&amp;chksm=f03ff013c74879059deb18b95077fd9d4fb4463f9f72836e09e465e82750bdab857fe83536ee#rd">《深入理解
go unsafe》</a>），所以图中用了连续的一段单元格表示。</p>
<p>下面是各字段说明：</p>
<ul>
<li><code>qcount</code>: 写入 <code>chan</code>
缓冲区元素个数。我们的代码往 <code>chan</code> 中存入了 <code>7</code>
个数，然后从中取出了一个数，最终还剩 <code>6</code> 个，因此
<code>qcount</code> 是 <code>6</code>。</li>
<li><code>dataqsiz</code>: <code>hchan</code>
缓冲区的长度。它在内存中是连续的一段内存，是一个数组，是通过
<code>make</code> 创建的时候传入的，是 <code>9</code>。</li>
<li><code>buf</code>：<code>hchan</code>
缓冲区指针。指向了一个数组，这个数组就是用来保存发送到 <code>chan</code>
的数据的。</li>
<li><code>sendx</code>、<code>recvx</code>：写、读操作的下标。指向了
<code>buf</code> 指向的数组中的下标，<code>sendx</code>
是下一个发送操作保存的下标，<code>recvx</code>
是下一个接收操作的下标。</li>
<li><code>recvq</code>、<code>sendq</code>: 阻塞在 <code>chan</code>
读写上的协程列表。底层是双向链表，链表的元素是
<code>sudog</code>（<code>sudog</code> 是一个对 <code>g</code>
的封装），我们可以简单地理解为 <code>recvq</code> 和 <code>sendq</code>
的元素就是 <code>g</code>（协程）。</li>
</ul>
<h3 id="g-和-sudog-是什么">g 和 sudog 是什么？</h3>
<p>上面提到了 <code>g</code> 和 <code>sudog</code>，<code>g</code>
是底层用来表示协程的结构体，而 <code>sudog</code> 是对 <code>g</code>
的封装，记录了一些额外的信息，比如关联的 <code>hchan</code>。</p>
<p>在 go 里面，协程调度的模型是 <code>GMP</code> 模型，<code>G</code>
代表协程、<code>M</code> 代表线程、<code>P</code>
表示协程调度器。我上图里面的 <code>G</code> 就是代表协程（当然，实际上是
<code>sudog</code>）。 还有一个下面会提到的就是
<code>g0</code>，<code>g0</code> 表示 <code>P</code>
上启动的第一个协程。</p>
<p><code>GMP</code>
模型是另外一个庞大的话题了，大家可以自行去了解一下，对理解本文也很有好处。因为在
<code>chan</code> 阻塞的时候实际上也是一个协程调度的过程。
具体来说，就是从 <code>g</code> 的栈切换到 <code>g0</code>
的栈，然后重新进行协程调度。这个时候 <code>g</code>
因为从运行状态修改为了等待状态，所以在协程调度中不会将它调度来执行，
而是会去找其他可执行的协程来执行。</p>
<h2 id="创建-chan">创建 chan</h2>
<p>我们的 <code>make(chan int, 9)</code> 最终会调用
<code>makechan</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chantype 是 chan 元素类型，size 是缓冲区大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// compiler checks this but be safe.</span></span><br><span class="line">	<span class="comment">// 检查元素个数是否合法（不能超过 1&lt;&lt;16 个）</span></span><br><span class="line">	<span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断内存是否对齐</span></span><br><span class="line">	<span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">		throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// mem 是 chan 缓冲区（环形队列）所需要的内存大小</span></span><br><span class="line">	<span class="comment">// mem = 元素大小 * 元素个数</span></span><br><span class="line">	mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义 hchan</span></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// 队列或者元素大小是 0（比如 make(chan int, 0)）</span></span><br><span class="line">		<span class="comment">// 只需要分配 hchan 所需要的内存</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="comment">// ... </span></span><br><span class="line">	<span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// elem 类型里面不包含指针</span></span><br><span class="line">		<span class="comment">// 分配的内存 = hchan 所需内存 + 缓冲区内存</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="comment">// 分配的是连续的一段内存，缓冲区内存在 hchan 后面</span></span><br><span class="line">		c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// 元素类型里面包含指针</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		<span class="comment">// buf 需要另外分配内存</span></span><br><span class="line">		c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 单个元素的大小</span></span><br><span class="line">	c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">	<span class="comment">// 元素类型</span></span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	<span class="comment">// 缓冲区大小</span></span><br><span class="line">	c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 <code>chan</code> 的过程主要就是给 <code>hchan</code>
分配内存的过程：</p>
<ul>
<li>非缓冲 <code>chan</code>，只需要分配 <code>hchan</code>
结构体所需要的内存，无需分配环形队列内存（数据会直接从
<code>sender</code> 复制到 <code>receiver</code>）</li>
<li>缓冲 <code>chan</code>（不包含指针），分配 <code>hchan</code>
所需要的内存和环形队列所需要的内存，其中 <code>buf</code> 会紧挨着
<code>hchan</code></li>
<li>缓冲 <code>chan</code>（含指针），<code>hchan</code>
和环形队列所需要的内存单独进行分配</li>
</ul>
<blockquote>
<p>对应到文章开头的图就是，底下的 <code>hchan</code> 和 <code>buf</code>
那两段内存。</p>
</blockquote>
<h2 id="发送数据">发送数据</h2>
<h3 id="语法糖">&lt;- 语法糖</h3>
<p>在<a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyMTI0MzA4OQ==&amp;mid=2650071997&amp;idx=1&amp;sn=5176840d3b943d5087ce7e9f09dd57d3&amp;chksm=f03ff003c748791551dd3a26ac3f27f9ca79e02e953b4ddcb016d504492888bc391616ad3c35#rd">《深入理解
go chan》</a>中，我们说也过，<code>&lt;-</code>
这个操作符号是一种语法糖， 实际上，<code>&lt;-</code>
会被编译成一个函数调用，对于发送操作而言，<code>c &lt;- x</code>
会编译为对下面的函数的调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// elem 是被发送到 chan 的数据的指针。</span></span><br><span class="line"><span class="comment">// 对于 ch &lt;- x，ch 对应参数中的 c，unsafe.Pointer(&amp;x) 对应参数中的 elem。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chansend(c, elem, <span class="literal">true</span>, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，对于 <code>select</code> 里面的调用，<code>chansend</code>
会返回一个布尔值给 <code>select</code> 用来判断是否是要选中当前
<code>case</code> 分支。 如果 <code>chan</code> 发送成功，则返回
<code>true</code>，则 <code>select</code>
的那个分支得以执行。（<code>select...case</code> 本质上是
<code>if...else</code>，返回 <code>false</code> 表示判断失败。）</p>
<h3 id="chansend-第二个参数的含义">chansend 第二个参数的含义</h3>
<p><code>chansend</code> 第二个参数 <code>true</code>
表示是一个阻塞调用，另外一种是在 <code>select</code> 里面的发送操作，在
<code>select</code> 中的操作是非阻塞的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	ch &lt;- <span class="number">1</span> <span class="comment">// 如果 ch 满了，会阻塞</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ch &lt;- <span class="number">3</span>: <span class="comment">// 非阻塞</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>select</code> 中对 <code>chan</code>
的读写是非阻塞的，不会导致当前协程阻塞，如果是因为 <code>chan</code>
满或者空无法发送或接收， 则不会导致阻塞在 <code>case</code>
的某一个分支上，还可以继续判断其他 <code>case</code> 分支。</p>
<p><code>select</code> 中的 <code>send</code> 实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 代码：</span></span><br><span class="line"><span class="comment">//	select &#123;</span></span><br><span class="line"><span class="comment">//	case c &lt;- v:</span></span><br><span class="line"><span class="comment">//		... foo</span></span><br><span class="line"><span class="comment">//	default:</span></span><br><span class="line"><span class="comment">//		... bar</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 实际效果：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	if selectnbsend(c, v) &#123;</span></span><br><span class="line"><span class="comment">//		... foo</span></span><br><span class="line"><span class="comment">//	&#125; else &#123;</span></span><br><span class="line"><span class="comment">//		... bar</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">// select 里面往 chan 发送数据的分支，返回的 selected 表示当前的分支是否被选中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="chansend-发送实现">chansend 发送实现</h3>
<ol type="1">
<li>发送到 <code>nil chan</code>（<code>select</code>
中发送不阻塞，其他情况阻塞）</li>
</ol>
<p><strong>如果是在 <code>select</code> 的 <code>case</code>
里面发送，则不会阻塞，其他情况会导致当前 goroutine
挂起，永远阻塞</strong>：</p>
<p><img src="/images/go/chandesign/chansend_1.png" /></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码运行会报错：</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="comment">// 发送到 nil chan 会永久阻塞</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 这个发送失败，但是不会阻塞，可继续判断其他分支。</span></span><br><span class="line"><span class="keyword">case</span> ch &lt;- <span class="number">3</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>发送到满了的 <code>chan</code>（<code>select</code>
中发送不阻塞，其他情况阻塞）</li>
</ol>
<p>对于无缓冲而且又没有
<code>receiver</code>，或者是有缓冲但是缓冲满了的情况，发送也会阻塞（我们称其为
<code>full</code>，也就是满了，满了的 <code>chan</code>
是放不下任何数据了的，所以就无法再往 <code>chan</code>
发送数据了）：</p>
<blockquote>
<p>receiver 表示等待从 chan 接收数据的协程。</p>
</blockquote>
<p><img src="/images/go/chandesign/chansend_2.png" /></p>
<p>对于满了的
<code>chan</code>，什么时候可以再次发送呢？那就是<strong>有
<code>receiver</code> 接收数据的时候</strong>。<code>chan</code>
之所以会满就是因为没有 <code>receiver</code>，也就是没有从
<code>chan</code> 接收数据的协程。</p>
<p>A. 对于无缓冲的 <code>chan</code>，在满了的情况下，当有
<code>receiver</code> 来读取数据的时候，数据会直接从 <code>sender</code>
复制到 <code>receiver</code> 中：</p>
<p><img src="/images/go/chandesign/chansend_3.png" /></p>
<p>B. 对于有缓冲，但是缓冲满了的情况（图中 <code>chan</code>
满了，并且有两个 <code>g</code> 正在等待写入 <code>chan</code>）：</p>
<p><img src="/images/go/chandesign/chansend_4.png" /></p>
<p>这个发送过程大概如下：</p>
<ul>
<li><code>receiver</code> 从 <code>chan</code> 中获取到
<code>chan</code> 队头元素，然后 <code>chan</code> 的队头元素出队。</li>
<li>发送队列 <code>sendq</code> 对头元素出队，将其要发送的数据写入到
<code>chan</code> 缓冲中。最后，<code>sendq</code> 只剩下一个等待写入
<code>chan</code> 的 <code>g</code></li>
</ul>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：以下代码可能不能正常执行，只是为了描述问题。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 情况 2.A.</span></span><br><span class="line">	<span class="keyword">var</span> ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 无缓冲的 chan</span></span><br><span class="line">	ch1 &lt;- <span class="number">1</span>                 <span class="comment">// 阻塞</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 不阻塞，但是不会执行这个分支</span></span><br><span class="line">	<span class="keyword">case</span> ch1 &lt;- <span class="number">1</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 情况 2.B.</span></span><br><span class="line">	<span class="keyword">var</span> ch2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 有缓冲，缓冲区容量为 1</span></span><br><span class="line">	ch2 &lt;- <span class="number">1</span>                    <span class="comment">// 1 写入之后，ch2 的缓冲区满了</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch2 &lt;- <span class="number">2</span> <span class="comment">// 阻塞，调用 gopark 挂起</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch2 &lt;- <span class="number">3</span> <span class="comment">// 阻塞</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 不阻塞，但是不会执行这个分支</span></span><br><span class="line">	<span class="keyword">case</span> ch2 &lt;- <span class="number">4</span>:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>发送到有缓冲，但是缓冲还没满的
<code>chan</code>（不阻塞，发送成功）</li>
</ol>
<p>这种情况比较简单，就是将 <code>sender</code> 要发送的数据写入到
<code>chan</code> 缓冲区：</p>
<p><img src="/images/go/chandesign/chansend_5.png" /></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 不阻塞，1 写入 chan 缓冲区</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="chansend-源码解读">chansend 源码解读</h3>
<p>阻塞模式下，在发送的过程中，如果遇到无法发送成功的情况，会调用
<code>gopark</code> 来将协程挂起，然后当前协程陷入阻塞状态。</p>
<p>非阻塞模式下（<code>select</code>），在发送过程中，任何无法发送的情况，都会直接返回
<code>false</code>，表示发送失败。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// c 表示 hchan 实例</span></span><br><span class="line"><span class="comment">// ep 表示要发送的数据所在的地址</span></span><br><span class="line"><span class="comment">// block 是否是阻塞模式（select 语句的 case 里面的发送是非阻塞模式，其他情况是阻塞模式）</span></span><br><span class="line"><span class="comment">// 非阻塞模式下，遇到无法发送的情况，会返回 false。阻塞模式下，遇到无法发送的情况，协程会挂起。</span></span><br><span class="line"><span class="comment">// 返回值：表示是否发送成功。false 的时候，如果是 select 的 case，则表示没有选中这个 case。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 情况 1：nil chan</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// select 语句里面发送数据到 chan 的操作失败，直接返回 false，表示当前的 case 没有被选中。</span></span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="comment">// select 分支没有被选中</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 阻塞模式，协程挂起</span></span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... 其他代码...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 不获取锁的情况下快速失败。select 中 chan 满了的时候无法发送成功，直接返回 false，协程无需挂起。</span></span><br><span class="line">	<span class="comment">// 场景：非阻塞模式、chan 未关闭、chan 已满（无缓冲且没有接收数据的协程、或者有缓冲但是缓冲区满）</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// ... 其他代码...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取锁</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 chan 已经关闭，则释放锁并 panic，不能往一个已经关闭的 chan 发送数据</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 情况 2.A，又或者是有缓冲但是缓冲区空，有一个正在等待接收数据的 receiver。</span></span><br><span class="line">	<span class="comment">// 如果有协程在等待接收数据（说明 chan 缓冲区空、或者 chan 是无缓冲的）</span></span><br><span class="line">	<span class="comment">// 则直接将元素传递给这个接收数据的协程，这样就避免了 sender -&gt; chan -&gt; receiver 这个数据复制的过程，效率更高。</span></span><br><span class="line">	<span class="comment">// 返回 true 表示 select 的分支可以执行（发送成功）</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 情况 3，发送到缓冲 chan，且 chan 未满</span></span><br><span class="line">	<span class="comment">// 没有协程在等待接收数据。</span></span><br><span class="line">	<span class="comment">// 缓冲区还有空余，则将数据写入到 chan 的缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// 获取写入的地址</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">		<span class="comment">// 通过内存复制的方式写入</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		<span class="comment">// 写入的下标指向下一个位置</span></span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="comment">// 如果到超出环形队列尾了，则指向第一个位置</span></span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// chan 里面的元素个数加上 1</span></span><br><span class="line">		c.qcount++</span><br><span class="line">		<span class="comment">// 释放锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="comment">// 发送成功，返回 true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 没有协程在接收数据，而且缓冲区满了。</span></span><br><span class="line">	<span class="comment">// 如果是 select 语句里面的发送，则释放锁，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发不出去，当前协程阻塞。</span></span><br><span class="line">	<span class="comment">// 阻塞模式下，缓冲区满了，需要将当前协程挂起。</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	mysg.elem = ep <span class="comment">// chan 要操作的元素指针</span></span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp           <span class="comment">// sudog 上的 g 属性</span></span><br><span class="line">	mysg.isSelect = <span class="literal">false</span> <span class="comment">// 如果是 select，上面已经返回了，因此这里是 false</span></span><br><span class="line">	mysg.c = c            <span class="comment">// sudog 上的 c 属性</span></span><br><span class="line">	gp.waiting = mysg     <span class="comment">// g 正在等待的 sudog</span></span><br><span class="line">	gp.param = <span class="literal">nil</span>        <span class="comment">// 当通道操作唤醒被阻塞的 goroutine 时，它将 param 设置为指向已完成的阻塞操作的 sudog</span></span><br><span class="line">	c.sendq.enqueue(mysg) <span class="comment">// 将 sudog 放入发送队列</span></span><br><span class="line">	<span class="comment">// 在 chan 读写上阻塞的标志</span></span><br><span class="line">	gp.parkingOnChan.Store(<span class="literal">true</span>)</span><br><span class="line">	<span class="comment">// 最关键的一步：将当前协程挂起</span></span><br><span class="line">	gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// 保证 ep 指向的地址不被垃圾回收器回收</span></span><br><span class="line">	KeepAlive(ep)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...被唤醒了之后的一些收尾操作...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数说明：c 是 chan 实例，sg 是等待接收数据的 g，ep 是被发送进 chan 的数据，unlockf 是释放锁的函数。</span></span><br><span class="line"><span class="comment">// 空 chan 上发送，会直接发送给等待接收数据的协程。</span></span><br><span class="line"><span class="comment">// ep 指向的值会被复制到 sg 中（ep -&gt; sg，ep 是被发送的值，sg 是要接收数据的 g）。</span></span><br><span class="line"><span class="comment">// 接收数据的协程会被唤醒。</span></span><br><span class="line"><span class="comment">// 通道 c 必须是空的并且获取了锁。send 会通过 unlockf 来释放锁。</span></span><br><span class="line"><span class="comment">// sg 必须已从 c 中退出队列（从 recvq 这个接收队列中移除）。</span></span><br><span class="line"><span class="comment">// ep 必须不能为 nil，同时指向堆或者调用者的栈。</span></span><br><span class="line"><span class="comment">// sg 是接收队列上的 g。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// ...其他代码...</span></span><br><span class="line">	<span class="comment">// 如果没有忽略返回值，将值直接从 ep 复制到 sg 中</span></span><br><span class="line">	<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		sendDirect(c.elemtype, sg, ep)</span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp := sg.g</span><br><span class="line">	<span class="comment">// 释放锁</span></span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	sg.success = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">		sg.releasetime = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最关键的一步：唤醒等待队列中的那个接收到数据的 g</span></span><br><span class="line">	<span class="comment">//（也就是之前因为接收不到数据而被阻塞的那个 g）</span></span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：t 是 chan 的元素类型，sg 是接收数据的 g（协程），src 是被发送的数据的指针。</span></span><br><span class="line"><span class="comment">// 场景：无缓冲 chan、有缓冲但是缓冲区没数据。</span></span><br><span class="line"><span class="comment">// 作用：将数据直接从发送数据的协程复制到接收数据的协程。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	dst := sg.elem</span><br><span class="line">	typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line">	<span class="comment">// 将 ep 的值直接复制到 sg 中</span></span><br><span class="line">	memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// full 报告 c 上的发送是否会阻塞（即通道已满）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">full</span><span class="params">(c *hchan)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// c.dataqsiz 是不可变的（创建 chan 后不会再去修改）</span></span><br><span class="line">    <span class="comment">// 因此在 chan 操作期间的任何时间读取都是安全的。</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是非缓冲 chan，则看接收队列有没有数据，有则表明满了（没有正在发送的 g）</span></span><br><span class="line">        <span class="keyword">return</span> c.recvq.first == <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是缓冲 chan，只需要比较实际元素总数跟缓冲区容量即可</span></span><br><span class="line">    <span class="keyword">return</span> c.qcount == c.dataqsiz</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接收数据">接收数据</h2>
<h3 id="语法糖-1">&lt;- 语法糖</h3>
<p>在发送数据的那一节我们提到了，<code>ch &lt;- x</code>
编译之后，实际上是对 <code>chansend1</code>
的函数调用。同样的，在接收数据的时候， <code>&lt;-</code>
这个操作符也会根据不同情况编译成不同的函数调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// elem 是用来保存从 c 中接收到的值的地址的指针</span></span><br><span class="line"><span class="comment">// &lt;- c 编译器处理之后实际上就是下面的这个函数调用。（从通道接收，但是忽略接收到的值）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// received 表示是否是从 chan 中接收到的（如果 chan 关闭，则接收到的是零值，received 是 false）</span></span><br><span class="line"><span class="comment">// v, ok := &lt;-c 编译之后的函数（从通道接收，第一个 v 对应 elem，第二个 ok 对应 received）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">	_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select 里面的接收操作：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	select &#123;</span></span><br><span class="line"><span class="comment">//	case v, ok = &lt;-c:</span></span><br><span class="line"><span class="comment">//		... foo</span></span><br><span class="line"><span class="comment">//	default:</span></span><br><span class="line"><span class="comment">//		... bar</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 实际 go 实现</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	if selected, ok = selectnbrecv(&amp;v, c); selected &#123;</span></span><br><span class="line"><span class="comment">//		... foo</span></span><br><span class="line"><span class="comment">//	&#125; else &#123;</span></span><br><span class="line"><span class="comment">//		... bar</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// select 里面从 chan 接收数据的分支，返回的 selected 表示当前的分支是否被选中，received 表示是否有数据被接收到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还需要再提醒一下的是：<code>chan</code> 关闭之后，并且
<code>chan</code> 缓冲区所有数据被接收完之后，<code>received</code>
才会是 <code>false</code>，并不是一关闭 <code>received</code> 马上返回
<code>false</code></p>
<h3 id="chanrecv-函数-block-参数的含义">chanrecv 函数 block
参数的含义</h3>
<p>跟 <code>chansend</code> 中的 <code>block</code>
参数的作用一样，用来判断是否是 <code>select</code>
模式下的接收操作，如果是，则在需要阻塞的时候不会阻塞，取而代之的是直接返回。</p>
<h3 id="chanrecv-接收数据实现">chanrecv 接收数据实现</h3>
<ol type="1">
<li>从 <code>nil chan</code> 接收（<code>select</code>
中接收不阻塞，其他情况阻塞）</li>
</ol>
<p>从 <code>nil chan</code> 中读取的时候，如果是阻塞模式，会调用
<code>gopark</code> 将协程阻塞起来。</p>
<p><img src="/images/go/chandesign/chanrecv_1.png" /></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>从空 <code>chan</code> 接收（<code>select</code>
中接收不阻塞，其他情况阻塞）</li>
</ol>
<p><img src="/images/go/chandesign/chanrecv_2.png" /></p>
<blockquote>
<p>判断空的条件为：无缓冲并且没有等待发送数据的
g，或者有缓冲但是缓冲区无数据。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：以下代码执行不了，只是展示一下实际中对应的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 情况 1，无缓冲的 chan，空的</span></span><br><span class="line">	<span class="keyword">var</span> ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	&lt;-ch1 <span class="comment">// 阻塞</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 不阻塞，但是该分支不会执行</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ch1:</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 情况 2，有缓冲的 chan，空的</span></span><br><span class="line">	<span class="keyword">var</span> ch2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	&lt;-ch2 <span class="comment">// 阻塞</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 不阻塞，但是该分支不会执行</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ch2:</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>从缓冲区满的 <code>chan</code> 接收（不会阻塞，这个时候
<code>sendq</code> 一定不为空）</li>
</ol>
<blockquote>
<p>这种情况不会阻塞，上面已经有图了，这里不再贴了。</p>
</blockquote>
<ol start="4" type="1">
<li>从缓冲区不满的 <code>chan</code> 接收（不会阻塞）</li>
</ol>
<p><img src="/images/go/chandesign/chanrecv_3.png" /></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line">	<span class="comment">// 从缓冲区没满的 chan 接收</span></span><br><span class="line">	&lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="chanrecv-源码解读">chanrecv 源码解读</h3>
<p><code>chanrecv</code> 函数:</p>
<ul>
<li>参数：<code>c</code> 是 <code>chan</code> 实例，<code>ep</code>
是用来接收数据的指针，<code>block</code> 表示是否是阻塞模式。</li>
<li>返回值：<code>selected</code> 表示 <code>select</code> 语句的
<code>case</code> 是否被选中，<code>received</code>
表示接收到的值是否有效。</li>
<li>功能：从 <code>c</code> 这个通道接收数据，同时将接收到的数据写入到
<code>ep</code> 里。</li>
</ul>
<p>概览：</p>
<ul>
<li><code>ep</code> 可能是
<code>nil</code>，这意味着接收到的值被忽略了（对应 <code>&lt;-c</code>
这种形式的接收）。</li>
<li>如果是非阻塞模式，并且通道无数据，返回
<code>(false, false)</code>，也就是 <code>select</code> 语句中的
<code>case</code> 不会被选中。</li>
<li>否则，如果 <code>c</code> 关闭了，会对 <code>ep</code>
指向的地址设置零值，然后返回 <code>(true, false)</code>。如果是
<code>select</code> 语句，意味被选中，</li>
<li>但是 <code>received</code> 为 <code>false</code>
表明返回的数不是通道关闭之前发送的。</li>
<li>否则，将从通道中获取到的值写入 <code>ep</code> 指向的地址，并且返回
<code>(true, true)</code></li>
<li>一个非 <code>nil</code> 的 <code>ep</code>
必须指向堆或者调用者的栈。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 c 读取数据，写入到 ep 指向的地址。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// c 是 nil chan</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// select 里面的 case 不会被选中</span></span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 阻塞模式时，协程挂起</span></span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		<span class="comment">// 在实际执行的时候，如果其他协程都执行完了，只剩下这一个协程（又或者全部协程都是睡眠状态，并且无法被唤醒的那种），那么会报错：</span></span><br><span class="line">		<span class="comment">// &quot;fatal error: all goroutines are asleep - deadlock!&quot;</span></span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是非阻塞模式（select），并且 c 是空的</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line">		<span class="comment">// chan 未关闭，并且是空的，返回 false,false</span></span><br><span class="line">		<span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// chan 已经关闭，并且 chan 是空的</span></span><br><span class="line">		<span class="keyword">if</span> empty(c) &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">			<span class="comment">// 返回一个零值</span></span><br><span class="line">			<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">				typedmemclr(c.elemtype, ep)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// select 分支被选中，但是返回值是无效的，是一个零值</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取锁</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// chan 已关闭</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// chan 已经关闭，同时也没有数据</span></span><br><span class="line">		<span class="keyword">if</span> c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">			<span class="comment">// 释放锁</span></span><br><span class="line">			unlock(&amp;c.lock)</span><br><span class="line">			<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// 设置零值</span></span><br><span class="line">				typedmemclr(c.elemtype, ep)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// select 的分支被选中，但是返回值无效</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// chan 未关闭，并且有一个等待发送的元素（对应情况：chan 是满的或者无缓冲而且没有 receiver）</span></span><br><span class="line">		<span class="comment">// 如果无缓冲：则将元素直接从 sender 复制到 receiver 中。</span></span><br><span class="line">		<span class="comment">// 否则：意味着 c 的缓冲区满了，从环形队列中接收值，将 sg 需要发送的值添加到环形队列尾，</span></span><br><span class="line">		<span class="comment">// 		实际上这个时候，队列头和队列尾都是同一个位置，因为队列满了。</span></span><br><span class="line">		<span class="comment">//		只不过，队列头和队列尾指向的位置会发生变化（都加 1，然后对缓冲区长度取模）。</span></span><br><span class="line">		<span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 找到一个 sender。</span></span><br><span class="line">			<span class="comment">// 如果无缓冲，直接从 sender 复制到 receiver</span></span><br><span class="line">			<span class="comment">// 否则，环形队列对头元素复制给 receiver，sender 要发送的元素复制进环形队列队尾。</span></span><br><span class="line">			recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">			<span class="comment">// select 分支被选中，接收成功，并且接收的值是有效的。</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲区有数据，并且缓冲区没满</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// qp 是被接收元素的地址</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 将 qp 指向的值复制到 ep</span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 清空队列中 ep 的空间（设置为零值）</span></span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		<span class="comment">// 被接收的下标指向下一个元素</span></span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="comment">// 环形队列，回到开头</span></span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 缓冲区长度减 1</span></span><br><span class="line">		c.qcount--</span><br><span class="line">		<span class="comment">// 释放锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="comment">// select 分支被选中，并且接收的值是有效的。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲区空的，并且是非阻塞（select）</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		<span class="comment">// 释放锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="comment">// 返回 false,false</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲区空，并且是阻塞模式，同时没有等待发送的 g</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 没有 sender，阻塞</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// c 的 recvq，也就是等待接收的队列，在队尾添加当前的 g</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// g 挂起，等待下一个发送数据的协程</span></span><br><span class="line">	gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... 被唤醒后的操作 ...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recv 处理缓冲区已满的 chan 的接收操作（或者无缓冲，这个函数处理这两种情况）。</span></span><br><span class="line"><span class="comment">// 有两部分：</span></span><br><span class="line"><span class="comment">//  1. 等待发送数据的协程（sender），会将其要发送的数据放入 chan 中，然后这个协程会被唤醒</span></span><br><span class="line"><span class="comment">//  2. 被接收协程接收的值会写入到 ep 中</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 对于同步 chan（无缓冲 chan），两个值是同一个。</span></span><br><span class="line"><span class="comment">// 对于异步 chan，接收者从 chan 的缓冲区获取数据，发送方的输入放入 chan 缓冲区。</span></span><br><span class="line"><span class="comment">// 通道 c 必须已满并锁定。recv 会使用 unlockf 来解锁 c。</span></span><br><span class="line"><span class="comment">// sg 必须已经从 c 中移除（准确来说是 c.sendq）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果无缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 直接将 sender 的要发送的值复制到 ep</span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			recvDirect(c.elemtype, sg, ep)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 有缓冲区，但是缓冲区满了。</span></span><br><span class="line">		<span class="comment">// 从队列头获取元素，将要发送的值放入队列尾。（实际上操作的是同一个位置，因为环形队列满了）</span></span><br><span class="line">		<span class="comment">// 需要获取的值的指针地址</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 如果需要接收值，则将 qp 复制到 ep（没有忽略返回值）</span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将要发送的值写入到 qp（sendq 对头元素要发送的值写入到 qp，也就是 chan 刚刚空出来的位置）</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">		<span class="comment">// 队列头、尾指针移动</span></span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">	&#125;</span><br><span class="line">	sg.elem = <span class="literal">nil</span></span><br><span class="line">	gp := sg.g</span><br><span class="line">	<span class="comment">// 释放锁</span></span><br><span class="line">	unlockf()</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 唤醒协程（这个被唤醒的协程是之前因为发送不出去被阻塞的协程）</span></span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据直接从 sender 复制到 receiver</span></span><br><span class="line"><span class="comment">// 场景：发送到无缓冲的 chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    src := sg.elem</span><br><span class="line">    typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line">	<span class="comment">// dst 是 receiver 栈里保存接收值的地址，src 是 sender 栈里要被发送的值的地址</span></span><br><span class="line">    memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关闭-chan">关闭 chan</h2>
<p><code>chan</code> 关闭的过程比较简单，修改 <code>closed</code> 为
1，然后唤醒发送队列和接收队列里面的 <code>g</code>，如果发送队列有
<code>g</code>，被唤醒之后会
<code>panic</code>，因为不能往一个已经关闭的 <code>chan</code>
发送数据。</p>
<p><img src="/images/go/chandesign/chanrecv_4.png" /></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭 chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 不能关闭 nil chan</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启锁</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// chan 已经关闭，panic，不能重复关闭。释放锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 设置 closed 标志</span></span><br><span class="line">	c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// gList 用来保存阻塞在 chan 上的 g（链表，包括了 sender 和 receiver）</span></span><br><span class="line">	<span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放所有等待读取 chan 的协程（解除阻塞状态）</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// recvq 队头元素出队</span></span><br><span class="line">		sg := c.recvq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// sendq 已经没有元素了</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭之后，从 chan 接收到的都是零值</span></span><br><span class="line">		<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">			sg.elem = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		glist.push(gp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放所有正在等待写入 chan 的协程（解除阻塞状态，这些协程会 panic）</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// sendq 队头元素出队</span></span><br><span class="line">		sg := c.sendq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// sendq 已经没有元素了</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		glist.push(gp)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 释放锁</span></span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将所有等待的协程修改为就绪态</span></span><br><span class="line">	<span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">		gp := glist.pop()</span><br><span class="line">		gp.schedlink = <span class="number">0</span></span><br><span class="line">		<span class="comment">// g 状态修改为可运行状态</span></span><br><span class="line">		goready(gp, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对于实际开发的作用">对于实际开发的作用</h2>
<p>在上一篇文章和本文中，花了很大的篇幅来讲述 <code>chan</code>
的设计、实现与使用，这么多东西对我们有什么用呢？</p>
<p>其中非常重要的一个作用是，清楚地了解 <code>chan</code>
的工作机制，便于我们对程序实际运行情况进行分析，
尤其是一些非常隐晦的读写 <code>chan</code>
场景，毕竟稍有不慎就会导致协程泄漏，这对进程影响可能是非常大的。</p>
<p>比如下面的这种代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 永远阻塞，协程泄漏</span></span><br><span class="line">			<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">			ch &lt;- <span class="number">1</span></span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="comment">// 我们会看到协程数量逐渐增长。</span></span><br><span class="line">		<span class="comment">// 但是这部分挂起的协程永远不会被调度。</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;goroutine count: %d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Hour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips：在 <code>chan</code> 读写的地方需要注意自己的写法会不会让
goroutine 永远陷入阻塞，或者长时间阻塞。</p>
</blockquote>
<h2 id="总结">总结</h2>
<ul>
<li><code>chan</code> 底层是 <code>hchan</code> 结构体。</li>
<li>go 语法里面的 <code>&lt;-</code>
不过是语法糖，在编译的时候，会编译成 <code>hchan</code>
相关的方法调用。最终都会调用 <code>chansend</code> 或者
<code>chanrecv</code>。<code>select...case</code> 里面的
<code>chan</code> 读写最终也会编译为对 <code>chansend</code> 或
<code>chanrecv</code> 的调用。</li>
<li><code>chan</code> 总体设计：维护了三个队列：
<ul>
<li><code>hchan.buf</code>: <code>chan</code> 中暂存 <code>sender</code>
发送数据的队列（在有 <code>receiver</code>
读取的时候会从这个队列中复制到 <code>receiver</code> 中）</li>
<li><code>hchan.recvq</code>: 接收队列，存储那些尝试读取
<code>channel</code> 但被阻塞的 <code>goroutine</code>。</li>
<li><code>hchan.sendq</code>: 发送队列，存储那些尝试写入
<code>channel</code> 但被阻塞的 <code>goroutine</code>。</li>
</ul></li>
<li>读写 <code>chan</code> 的协程阻塞是通过 <code>gopark</code>
实现的，而从阻塞态转换为可运行状态是通过 <code>goready</code>
实现的。</li>
<li>在 <code>chan</code> 读写操作阻塞的时候，如果是在
<code>select</code>
语句中，则会直接返回（表示当前的分支没有被选中），否则，会调用
<code>gopark</code> 挂起当前协程。</li>
<li>在关闭 <code>chan</code> 的时候，会调用 <code>goready</code>
唤醒阻塞在发送或者接收操作上的 <code>g</code>（协程）。</li>
<li>无缓冲 <code>chan</code> 的操作有点特殊，对于无缓冲
<code>chan</code>，必须同时有 <code>sender</code> 和
<code>receiver</code>
才能发送和接收成功，否则另一边都会陷入阻塞（当然，<code>select</code>
不会阻塞）。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/15/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/70/">70</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/17/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">eleven26</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eleven26" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
