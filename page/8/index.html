<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eleven26.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="eleven26">
<meta property="og:url" content="https://eleven26.github.io/page/8/index.html">
<meta property="og:site_name" content="eleven26">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="eleven26">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="PHP">
<meta property="article:tag" content="Laravel">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://eleven26.github.io/page/8/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>eleven26</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">eleven26</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">100</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">346</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eleven26</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eleven26" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eleven26" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2024/02/04/golang/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20Go%20%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%20-%20%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/04/golang/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20Go%20%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%20-%20%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">一文搞懂 Go 跨平台编译 - 交叉编译</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-04 20:28:30" itemprop="dateCreated datePublished" datetime="2024-02-04T20:28:30+08:00">2024-02-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在实际的工作中，我们很多时候开发环境跟应用程序最终运行的环境是不同的操作系统，比如在
Windows 上进行开发，但是应用程序最终是要在 Linux 上运行的， 又或者是在
mac 下开发，在 Linux
下运行。这个时候我们就需要进行交叉编译，即在一个操作系统上编译出另一个操作系统的可执行文件。</p>
<p>使用 Go
的时候，我们可以很方便的进行交叉编译，只需要设置好环境变量或者设置构建标签即可，本文会通过一个简单的例子来演示如何进行交叉编译。</p>
<h2 id="goos-和-goarch-环境变量所有可能的值">GOOS 和 GOARCH
环境变量所有可能的值</h2>
<p>在 Go 语言中，我们可以通过设置环境变量 <code>GOOS</code> 和
<code>GOARCH</code> 来指定目标操作系统和目标架构。
比如在我的系统上，查看 <code>GOOS</code> 和 <code>GOARCH</code>
的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ go env GOOS GOARCH</span><br><span class="line">darwin</span><br><span class="line">amd64</span><br></pre></td></tr></table></figure>
<p>在 Go 编译的时候，默认的 <code>GOOS</code> 和 <code>GOARCH</code>
的值是当前系统的操作系统和架构，比如在我的系统上，<code>GOOS</code>
的值是 <code>darwin</code>，<code>GOARCH</code> 的值是
<code>amd64</code>。
所以编译出来的就是当前系统可以执行的二进制文件，如果我们想要编译出其他系统的二进制文件，就需要设置
<code>GOOS</code> 和 <code>GOARCH</code> 的值。</p>
<p>首先，我们需要了解这两个环境变量支持哪些值。下面是所有可能的值，我们可以通过
<code>go tool dist list</code> 列出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">aix/ppc64        freebsd/amd64   linux/mipsle   openbsd/386</span><br><span class="line">android/386      freebsd/arm     linux/ppc64    openbsd/amd64</span><br><span class="line">android/amd64    illumos/amd64   linux/ppc64le  openbsd/arm</span><br><span class="line">android/arm      js/wasm         linux/s390x    openbsd/arm64</span><br><span class="line">android/arm64    linux/386       nacl/386       plan9/386</span><br><span class="line">darwin/386       linux/amd64     nacl/amd64p32  plan9/amd64</span><br><span class="line">darwin/amd64     linux/arm       nacl/arm       plan9/arm</span><br><span class="line">darwin/arm       linux/arm64     netbsd/386     solaris/amd64</span><br><span class="line">darwin/arm64     linux/mips      netbsd/amd64   windows/386</span><br><span class="line">dragonfly/amd64  linux/mips64    netbsd/arm     windows/amd64</span><br><span class="line">freebsd/386      linux/mips64le  netbsd/arm64   windows/arm</span><br></pre></td></tr></table></figure>
<p>在上面的输出中，<code>/</code> 前面操作系统，<code>/</code>
后面是架构。以 <code>linux/386</code> 为例，键值对以 <code>GOOS</code>
开始，在本例中将是 <code>linux</code> ，指的是 Linux 操作系统。这里的
<code>GOARCH</code> 将是 <code>386</code> ，代表
<code>Intel 80386</code> 微处理器。</p>
<p>我们发现其实 Go
支持很多操作系统和架构，但是大多数情况下，你最终会使用
<code>linux</code>、<code>windows</code> 或 <code>darwin</code>
中的一个作为 <code>GOOS</code>
的值，这涵盖了三大操作系统平台：Linux、Windows 和 macOS。</p>
<h2 id="使用文件名后缀实现交叉编译">使用文件名后缀实现交叉编译</h2>
<p><strong>使用场景：不同操作系统需要通过不同代码来实现。</strong></p>
<p>Go 标准库中 <code>path/filepath</code> 包中的 <code>Join</code>
函数，在不同平台下会有不同的效果。该函数接受一些字符串，并返回一个使用正确文件路径分隔符连接在一起的字符串。</p>
<p>这是一个很好的示例程序，因为程序的操作取决于它运行的操作系统。在
Windows 上，路径分隔符是反斜杠 <code>\</code>，而 Unix 系统使用正斜杠
<code>/</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s := filepath.Join(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">  fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序在 Windows 上运行时，将输出 <code>a\b\c</code>，而在 Unix
系统上运行时，将输出 <code>a/b/c</code>。</p>
<p>这是如何实现的呢？这就涉及到了 Go
中实现交叉编译的其中一种方式，就是指定文件名后缀， 我们看 Go
的源码或者一些开源项目的源码，就会发现有些文件的文件名带了操作系统的后缀，比如
<code>file_windows.go</code>、<code>file_linux.go</code>、<code>file_darwin.go</code>
等等。</p>
<p>同样的，<code>path/filepath</code> 包中的 <code>Join</code>
函数也是这样实现的，我们可以看到 <code>path/filepath</code>
包中有很多文件，比如
<code>path_windows.go</code>、<code>path_unix.go</code> 等等，其中：</p>
<ul>
<li><code>path_windows.go</code> 中实现了 <code>Join</code> 函数在
Windows 上的实现</li>
<li><code>path_unix.go</code> 中实现了 <code>Join</code> 函数在 Unix
系统上的实现</li>
</ul>
<p>我们点开 <code>path_unix.go</code> 文件，可以看到如下的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    PathSeparator     = <span class="string">&#x27;/&#x27;</span> <span class="comment">// OS-specific path separator</span></span><br><span class="line">    PathListSeparator = <span class="string">&#x27;:&#x27;</span> <span class="comment">// OS-specific path list separator</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>也就是说，<code>Join</code> 函数的路径分隔符是在这里通过
<code>PathSeparator</code> 定义成 <code>/</code> 的，而在
<code>path_windows.go</code> 文件中，<code>PathSeparator</code> 是定义成
<code>\</code> 的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path_windows.go</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    PathSeparator     = <span class="string">&#x27;\\&#x27;</span> <span class="comment">// OS-specific path separator</span></span><br><span class="line">    PathListSeparator = <span class="string">&#x27;;&#x27;</span>  <span class="comment">// OS-specific path list separator</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有两个 <code>\</code> 是因为需要转义。</p>
</blockquote>
<h3 id="同时在文件名中加上-goarch-后缀">同时在文件名中加上 GOARCH
后缀</h3>
<p>在命名文件时，您可以按照顺序将 <code>GOOS</code> 和
<code>GOARCH</code>
添加为文件名的后缀，用下划线（<code>_</code>）分隔这些值。如果您有一个名为
<code>filename.go</code> 的 Go 文件，您可以通过将文件名更改为
<code>filename_GOOS_GOARCH.go</code>
来指定操作系统和架构。例如，如果您希望将其编译为具有 64 位 ARM 架构的
Windows 文件，您将文件名更改为 <code>filename_windows_arm64.go</code>
。这种命名约定有助于保持代码整洁有序。</p>
<p>在我们编译的时候，如果我们当前的 <code>GOOS</code> 和
<code>GOARCH</code> 跟文件名不匹配，则 Go 会忽略这个文件。</p>
<h2 id="使用构建标签实现交叉编译">使用构建标签实现交叉编译</h2>
<p><strong>使用场景：不同操作系统需要使用不同代码。（跟上一个类似）</strong></p>
<p>除了指定文件名后缀以外，我们还可以使用构建标签来实现交叉编译。具体来说，就是在文件的第一行添加
<code>// +build</code> 标签，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build windows</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PathSeparator = <span class="string">&quot;\\&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样的话，这个文件就只会在 Windows
上编译，而在其他系统上不会编译。</p>
<h2 id="使用你本地-goos-和-goarch-的值进行交叉编译">使用你本地 GOOS 和
GOARCH 的值进行交叉编译</h2>
<p><strong>使用场景：在本地开发环境编译出其他系统的可执行文件。</strong></p>
<p>之前，您运行了 <code>go env GOOS GOARCH</code>
命令来查看您正在使用的操作系统和架构。当您运行 <code>go env</code>
命令时，它会查找两个环境变量 <code>GOOS</code> 和
<code>GOARCH</code>；如果找到，它们的值将被使用，但如果未找到，则 Go
将使用当前平台的信息来设置它们。这意味着您可以更改 <code>GOOS</code> 或
<code>GOARCH</code>，以便它们不会默认为您的本地操作系统和架构。这样就可以编译出其他平台的可执行文件。</p>
<p><code>go build</code> 命令的行为方式类似于 <code>go env</code>
命令。您可以使用 <code>go build</code> 设置 <code>GOOS</code> 或
<code>GOARCH</code> 环境变量以构建不同平台的应用程序。</p>
<p>如果您没有使用 Windows 系统，请在运行 <code>go build</code> 命令时将
<code>GOOS</code> 环境变量设置为 <code>windows</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=windows go build</span><br></pre></td></tr></table></figure>
<p>你也可以同时设置 <code>GOARCH</code> 环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go build</span><br></pre></td></tr></table></figure>
<p>这将编译出一个 Linux 平台上的 64 位可执行文件，我们如果使用的是
macOS，我们可以通过 <code>file</code> 命令查看编译出来的文件的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file main</span><br><span class="line">main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=xx, with debug_info, not stripped</span><br></pre></td></tr></table></figure>
<p>我们会看到这是一个 64 位的 ELF 可执行文件，而 ELF 是 Linux
下的可执行文件格式。</p>
<h2 id="更加现代化的交叉编译方式">更加现代化的交叉编译方式</h2>
<p>我们前面讲了很多如何进行交叉编译，但是如果我们每次都需要针对不同平台来手动编译，未免过于麻烦，当然我们可以写一个脚本来自动化这个过程。</p>
<p>这一小节，我将介绍一个比较好用的交叉编译工具
<code>goreleaser</code>，我们只需要简单的配置一下，它就可以帮我们自动化交叉编译的过程。
比如 <code>frp</code> 这个开源项目就是使用 <code>goreleaser</code>
来进行发布新版本的。</p>
<p>下面是一个示例配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .goreleaser.yml，放在项目根目录下</span></span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="attr">project_name:</span> <span class="string">goss</span></span><br><span class="line"><span class="comment"># 在执行前需要执行的命令</span></span><br><span class="line"><span class="attr">before:</span></span><br><span class="line">  <span class="attr">hooks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">go</span> <span class="string">mod</span> <span class="string">tidy</span></span><br><span class="line"><span class="comment"># 编译配置</span></span><br><span class="line"><span class="attr">builds:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">env:</span></span><br><span class="line">      <span class="comment"># 可以指定环境变量</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CGO_ENABLED=0</span></span><br><span class="line">    <span class="attr">goos:</span> <span class="comment"># 需要编译的操作系统</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">linux</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">windows</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">darwin</span></span><br><span class="line"><span class="attr">archives:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">replacements:</span> <span class="comment"># 将 GOARCH 替换，因为用户更熟悉 x86_64</span></span><br><span class="line">      <span class="attr">386:</span> <span class="string">i386</span></span><br><span class="line">      <span class="attr">amd64:</span> <span class="string">x86_64</span></span><br><span class="line"><span class="attr">checksum:</span></span><br><span class="line">  <span class="attr">name_template:</span> <span class="string">&#x27;checksums.txt&#x27;</span></span><br><span class="line"><span class="attr">snapshot:</span></span><br><span class="line">  <span class="attr">name_template:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; incpatch .Version &#125;&#125;</span>&quot;</span></span><br><span class="line"><span class="attr">changelog:</span></span><br><span class="line">  <span class="attr">sort:</span> <span class="string">asc</span></span><br><span class="line">  <span class="attr">filters:</span></span><br><span class="line">    <span class="attr">exclude:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;^docs:&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;^test:&#x27;</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>project_name</code> 是项目的名称</li>
<li><code>before</code> 是在执行前需要执行的命令</li>
<li><code>builds</code> 是编译配置，<code>env</code>
是环境变量，<code>goos</code> 是需要编译的操作系统</li>
<li><code>archives</code> 是归档配置，<code>replacements</code> 是将
<code>GOARCH</code> 替换。</li>
<li><code>checksum</code> 是生成 checksum 的配置</li>
</ul>
<p>接着我们只需要执行 <code>goreleaser build</code>
命令即可进行编译：</p>
<blockquote>
<p><code>goreleaser</code> 的安装方式可参考它的官网。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goreleaser build</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">• starting build...</span><br><span class="line">• loading config file                   file=.goreleaser.yaml</span><br><span class="line">• loading environment variables</span><br><span class="line">• getting and validating git state</span><br><span class="line">  • building...                         commit=e913b9258e649f8f2784d9daaebbf3a4d7cf7a17 latest tag=v0.0.9</span><br><span class="line">• parsing tag</span><br><span class="line">• setting defaults</span><br><span class="line">• running before hooks</span><br><span class="line">  • running                             hook=go mod tidy</span><br><span class="line">  • running                             hook=go generate ./...</span><br><span class="line">• checking distribution directory</span><br><span class="line">• loading go mod information</span><br><span class="line">• build prerequisites</span><br><span class="line">• writing effective config file</span><br><span class="line">  • writing                             config=dist/config.yaml</span><br><span class="line">• generating changelog</span><br><span class="line">  • writing                             changelog=dist/CHANGELOG.md</span><br><span class="line">• building binaries</span><br><span class="line">  • building                             binary=dist/goss_windows_amd64_v1/goss.exe</span><br><span class="line">  • building                             binary=dist/goss_darwin_arm64/goss</span><br><span class="line">  • building                             binary=dist/goss_windows_arm64/goss.exe</span><br><span class="line">  • building                             binary=dist/goss_darwin_amd64_v1/goss</span><br><span class="line">  • building                             binary=dist/goss_linux_amd64_v1/goss</span><br><span class="line">  • building                             binary=dist/goss_linux_arm64/goss</span><br><span class="line">  • building                             binary=dist/goss_windows_386/goss.exe</span><br><span class="line">  • building                             binary=dist/goss_linux_386/goss</span><br><span class="line">  • took: 39s</span><br><span class="line">• storing release metadata</span><br><span class="line">  • writing                              file=dist/artifacts.json</span><br><span class="line">  • writing                              file=dist/metadata.json</span><br><span class="line">• build succeeded after 39s</span><br></pre></td></tr></table></figure>
<p>编译完成后，我们会在 <code>dist</code> 目录下看到编译好的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l dist/</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">total 32</span><br><span class="line">-rw-r--r--  1 ruby  staff    36 Feb  3 11:12 CHANGELOG.md</span><br><span class="line">-rw-r--r--  1 ruby  staff  1803 Feb  3 11:13 artifacts.json</span><br><span class="line">-rw-r--r--  1 ruby  staff  3509 Feb  3 11:12 config.yaml</span><br><span class="line">drwxr-xr-x  3 ruby  staff    96 Feb  3 11:13 goss_darwin_amd64_v1</span><br><span class="line">drwxr-xr-x  3 ruby  staff    96 Feb  3 11:13 goss_darwin_arm64</span><br><span class="line">drwxr-xr-x  3 ruby  staff    96 Feb  3 11:13 goss_linux_386</span><br><span class="line">drwxr-xr-x  3 ruby  staff    96 Feb  3 11:13 goss_linux_amd64_v1</span><br><span class="line">drwxr-xr-x  3 ruby  staff    96 Feb  3 11:13 goss_linux_arm64</span><br><span class="line">drwxr-xr-x  3 ruby  staff    96 Feb  3 11:13 goss_windows_386</span><br><span class="line">drwxr-xr-x  3 ruby  staff    96 Feb  3 11:13 goss_windows_amd64_v1</span><br><span class="line">drwxr-xr-x  3 ruby  staff    96 Feb  3 11:13 goss_windows_arm64</span><br><span class="line">-rw-r--r--  1 ruby  staff   219 Feb  3 11:13 metadata.json</span><br></pre></td></tr></table></figure>
<p>接着，我们就可以来发布这些二进制文件了。如果我们有其他个性化的需求，我们可以通过修改
<code>.goreleaser.yml</code>
文件来满足我们的需求。它还有很多配置可以自定义。
如果后续我们需要调整，只需要修改一下配置文件就行了，比如我们需要支持一个新的操作系统，只需要在
<code>goos</code> 下面增加一个新的操作系统即可。</p>
<blockquote>
<p>使用 goreleaser 进行交叉编译的好处是，它会自动帮我们打包、生成
checksum、生成 changelog 等等，省去了很多手动操作。</p>
</blockquote>
<p>另外，它还支持直接发布到 Github，使用 Github Actions
来自动化这个过程，这样我们只需要 push
代码，就可以自动进行编译、打包、发布。</p>
<p>下面是一个 github workflow 的示例配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">goreleaser</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="comment"># run only against tags</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">permissions:</span></span><br><span class="line">  <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line">  <span class="comment"># packages: write</span></span><br><span class="line">  <span class="comment"># issues: write</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">goreleaser:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">fetch-depth:</span> <span class="number">0</span></span><br><span class="line">      <span class="bullet">-</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Fetch</span> <span class="string">all</span> <span class="string">tags</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">git</span> <span class="string">fetch</span> <span class="string">--force</span> <span class="string">--tags</span></span><br><span class="line">      <span class="bullet">-</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Go</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-go@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">go-version:</span> <span class="number">1.19</span></span><br><span class="line">      <span class="bullet">-</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Run</span> <span class="string">GoReleaser</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">goreleaser/goreleaser-action@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">distribution:</span> <span class="string">goreleaser</span></span><br><span class="line">          <span class="attr">version:</span> <span class="string">latest</span></span><br><span class="line">          <span class="attr">args:</span> <span class="string">release</span> <span class="string">--rm-dist</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个配置文件的意思是，当我们 push tag 的时候，就会触发这个
workflow，它会自动运行 goreleaser，然后进行编译、打包、发布。</p>
<h2 id="总结">总结</h2>
<p>Go
支持我们很方便的进行交叉编译，只需要设置好环境变量或者设置构建标签即可：</p>
<ul>
<li>环境变量：<code>GOOS</code> 和 <code>GOARCH</code></li>
<li>文件名后缀：<code>filename_GOOS_GOARCH.go</code></li>
<li>构建标签：<code>// +build</code> 标签</li>
</ul>
<p>另外，我们还可以使用 <code>goreleaser</code>
这个工具来自动化交叉编译的过程，它还支持直接发布到 Github，使用 Github
Actions 来自动化这个过程，这样我们只需要 push
tag，就可以自动进行编译、打包、发布。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2024/02/02/golang/Golang%20%E6%B3%9B%E5%9E%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/02/golang/Golang%20%E6%B3%9B%E5%9E%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Golang 泛型入门指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 20:28:30" itemprop="dateCreated datePublished" datetime="2024-02-02T20:28:30+08:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Go
语言中的泛型是指一种语言特性，允许创建可以处理不同类型的函数、数据结构和接口。换句话说，泛型使得可以创建不受特定类型或数据结构限制的代码。如果我们此前有使用
Java 或者 C++ 的经验，那么会很好理解。</p>
<p>在 Go
语言引入泛型之前，开发人员必须编写多个函数来处理不同类型的数据。这种方法通常很繁琐，并导致代码重复。有了泛型，开发人员可以编写更简洁和可重用的代码，可以处理不同类型的数据。</p>
<p>Go 语言中的泛型是在 2021 年 2 月发布的 1.18 版本中引入的。Go
语言中的泛型实现是基于类型参数的概念。类型参数是传递给函数或数据结构的类型的占位符，使它们能够处理不同类型的数据。</p>
<h2 id="go-中的泛型是什么">Go 中的泛型是什么？</h2>
<p>泛型是一种代码，允许我们通过改变函数类型来在各种函数中使用它们。泛型的创建是为了使代码独立于类型和函数。</p>
<p>泛型的主要目的是通过添加更少的代码行来实现更大的灵活性。</p>
<p>为了更好地理解，看下面的例子。我们创建一个打印任何类型参数的函数，就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(s[] <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Print(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们突然希望打印一个整数，所以我们相应地改变了代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(s[] <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Print(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是每次像这样更改代码可能看起来令人生畏，这就是泛型发挥作用的地方。通过将任何类型分配给其泛型形式，我们可以将相同的代码用于不同的函数。看一下这个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s[] T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Print(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们将 <code>"T"</code> 定义为 <code>any</code>
类型。这个任意类型允许我们在同一个函数中解析不同类型的变量。<code>S</code>
是相应的变量，它是 <code>T</code>
类型的一个切片。现在，调用该方法，我们可以在同一个函数中打印一个字符串和一个整数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := []<span class="type">string</span>&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Again Hello&quot;</span>&#125;</span><br><span class="line">    intArray := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    Print(str)</span><br><span class="line">    Print(intArray)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="go-中的泛型是如何工作的">Go 中的泛型是如何工作的？</h2>
<p>Go
中的泛型是使用类型参数实现的，它允许创建可以在不同类型上操作的泛型函数和数据结构，而无需显式类型转换。</p>
<p>考虑以下示例，其中类型参数 <code>“T”</code> 是使用 <code>“any”</code>
关键字定义的，该关键字指定该函数可以与任何类型一起使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Swap</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(a, b * T)</span></span> &#123;</span><br><span class="line">    *a, *b = *b, *a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数体然后执行传入的两个指针指向的值的简单交换。</p>
<p>当函数被调用时，编译器为与函数一起使用的类型生成特定版本的函数。例如，如果函数被用于两个整数指针，编译器会生成一个操作整数的函数版本。</p>
<h2 id="类型参数是什么">类型参数是什么？</h2>
<p>在 Go
中，类型参数是使用方括号括起的类型参数列表来指定的，紧跟在函数、数据结构或接口名称之后。类型参数由单个大写字母或一系列大写字母表示，并用尖括号括起来。</p>
<p>类型参数用于在 Go
中创建通用函数、数据结构和接口。类型参数是在编译时确定的类型的占位符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 T 是类型参数，any 是类型约束；</span></span><br><span class="line"><span class="comment">// 这里表示 T 可以是任何类型。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Print(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := []<span class="type">string</span>&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Again Hello&quot;</span>&#125;</span><br><span class="line">    intArray := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    Print(str)</span><br><span class="line">    Print(intArray)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，考虑上面的示例，显式了使用类型参数的函数声明。在这个函数中，类型参数由大写字母
<code>"T"</code> 表示。<code>"any"</code>
关键字表示函数可以使用任何类型。当调用此函数时，类型参数将被替换为传递给函数的实际类型。</p>
<p>类型参数使得在 Go
语言中可以创建更通用和可重用的代码，因为它允许函数和数据结构可以处理不同类型的数据。</p>
<h2 id="在泛型中使用类型参数">在泛型中使用类型参数</h2>
<p>在上面的例子中，我们看到了如何在同一个函数下结合多种类型的变量。</p>
<p>在这个例子中，使用 <code>"any"</code> 关键字声明了一个带有类型参数
<code>"T"</code> 的函数。<code>"any"</code>
关键字表示该函数可以处理任何类型。该函数以类型 <code>"T"</code>
的切片作为参数，并打印其内容。</p>
<blockquote>
<p><code>T</code> 是类型参数，<code>any</code> 是类型约束；这里表示
<code>T</code> 可以是任何类型。</p>
</blockquote>
<p>要使用此功能，您可以使用下面给出的任何类型的切片来调用它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">intSlice := []<span class="type">int</span>&#123;</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line">stringSlice := []<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">Print(intSlice)    <span class="comment">// prints 1 2 3 4 5</span></span><br><span class="line">Print(stringSlice) <span class="comment">// prints apple banana cherry</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>Print</code>
函数被调用时使用了整数切片和字符串切片。类型参数 <code>"T"</code>
被实际传递给函数的参数类型所替换。</p>
<p>您还可以使用类型参数在 Go
中创建通用数据结构和接口。以下是一个使用类型参数的通用数据结构示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack[T])</span></span> Push(item T) &#123;</span><br><span class="line">    s.items = <span class="built_in">append</span>(s.items, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack[T])</span></span> Pop() T &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s.items) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;stack is empty&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    item := s.items[<span class="built_in">len</span>(s.items)<span class="number">-1</span>]</span><br><span class="line">    s.items = s.items[:<span class="built_in">len</span>(s.items)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这里，使用 <code>“any”</code> 关键字声明了带有类型参数
<code>“T”</code> 的栈数据结构。</li>
<li><code>Push</code> 方法接受类型为 <code>"T"</code>
的项目作为参数，并将其添加到栈中。</li>
<li><code>Pop</code> 方法从栈顶返回一个类型为 <code>"T"</code>
的项目。</li>
</ul>
<p>要使用这种数据结构，您可以创建任何类型的栈：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">intStack := &amp;Stack[<span class="type">int</span>]&#123;&#125;</span><br><span class="line">stringStack := &amp;Stack[<span class="type">string</span>]&#123;&#125;</span><br><span class="line">intStack.Push(<span class="number">1</span>)</span><br><span class="line">intStack.Push(<span class="number">2</span>)</span><br><span class="line">intStack.Push(<span class="number">3</span>)</span><br><span class="line">stringStack.Push(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">stringStack.Push(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line">stringStack.Push(<span class="string">&quot;cherry&quot;</span>)</span><br><span class="line">fmt.Println(intStack.Pop())    <span class="comment">// prints 3</span></span><br><span class="line">fmt.Println(stringStack.Pop()) <span class="comment">// prints cherry</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，创建了两个栈，一个是 <code>int</code> 类型，另一个是
<code>string</code> 类型。类型参数 <code>“T”</code>
被替换为创建栈的实际类型。</p>
<h2 id="类型约束">类型约束</h2>
<p>泛型中的类型约束定义了可以与泛型函数或数据结构一起使用的类型集合。类型约束允许编译器强制执行类型安全，并确保只有兼容的类型与泛型结构一起使用。</p>
<p>类型约束使用 <code>"interface"</code>
关键字指定，后跟接口的名称和类型必须实现的方法。例如，考虑以下使用类型约束的通用函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Equal</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">if</span> a == b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，类型参数 <code>"T"</code> 受到
<code>"comparable"</code> 接口的约束，该接口要求类型可以进行
<code>==</code> 或 <code>!=</code>
比较。这确保了函数只能被支持比较的类型调用。</p>
<p><code>comparable</code>
是一个内置接口，用于将泛型类型参数限制为仅支持比较运算符（!= ，和
==）的类型。</p>
<p><code>comparable</code> 接口是由 Go
语言规范隐式定义的，并不需要在代码中显式定义。这意味着任何支持比较运算符的类型都可以作为
<code>Equal</code> 函数的类型参数，而无需额外声明
<code>comparable</code> 接口。</p>
<p>类型约束也可以是用户定义的接口，它允许对可以与通用函数或数据结构一起使用的类型进行更具体的约束。例如，考虑以下用户定义的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(other Number) Number</span><br><span class="line">    Sub(other Number) Number</span><br><span class="line">    Mul(other Number) Number</span><br><span class="line">    Div(other Number) Number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口定义了一组方法，一个类型必须实现这些方法才能被视为
<code>“Number”</code>。使用该接口作为类型约束的泛型函数或数据结构只能与实现了这些方法的类型一起使用，确保类型安全和兼容性。</p>
<p>Go
中的泛型类型约束提供了一种确保类型安全并限制可以与泛型结构一起使用的类型集的方法，同时仍然允许泛型提供的灵活性和可重用性。</p>
<h2 id="在-golang-中使用泛型的示例">在 Golang 中使用泛型的示例</h2>
<p>这里有一些在Go中使用泛型的例子：</p>
<h3 id="通用函数">通用函数</h3>
<p>该函数接受任何类型 <code>T</code> 的切片和类型 <code>T</code>
的值，并返回该值在切片中的索引。类型参数中的 <code>any</code>
关键字指定可以使用任何类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findIndex</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(slice []T, value T)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">if</span> reflect.DeepEqual(v, value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通用类型">通用类型</h3>
<p>这定义了一个通用的栈类型，可以保存任何类型 <code>T</code>
的元素。关键字 <code>any</code> 指定任何类型都可以用作元素类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack[T any] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack[T])</span></span> Push(value T) &#123;</span><br><span class="line">    *s = <span class="built_in">append</span>(*s, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack[T])</span></span> Pop() T &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(*s) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;Stack is empty&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    value := (*s)[<span class="built_in">len</span>(*s)<span class="number">-1</span>]</span><br><span class="line">    *s = (*s)[:<span class="built_in">len</span>(*s)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型参数的约束">类型参数的约束</h3>
<p>这定义了对类型参数 <code>T</code> 的类型约束，要求其实现
<code>Equatable</code> 接口。这允许 <code>findIndex</code> 函数使用
<code>Equals</code> 方法来比较类型T的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Equatable <span class="keyword">interface</span> &#123;</span><br><span class="line">    Equals(other <span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findIndex</span>[<span class="title">T</span> <span class="title">Equatable</span>]<span class="params">(slice []T, value T)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">if</span> v.Equals(value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="支持多种数据类型的加法">支持多种数据类型的加法</h3>
<p>让我们编写一个函数 <code>SumGenerics</code>
，它对各种数值类型进行加法操作，比如
<code>int</code>，<code>int16</code>，<code>int32</code>，<code>int64</code>，<code>int8</code>，<code>float32</code>
和 <code>float64</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumGenerics</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">int16</span> | <span class="title">int32</span> | <span class="title">int64</span> | <span class="title">int8</span> | <span class="title">float32</span> | <span class="title">float64</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sumInt := SumGenerics[<span class="type">int</span>](<span class="number">2</span>, <span class="number">3</span>)           <span class="comment">// returns 5</span></span><br><span class="line">    sumFloat := SumGenerics[<span class="type">float32</span>](<span class="number">2.5</span>, <span class="number">3.5</span>) <span class="comment">// returns 6.0</span></span><br><span class="line">    sumInt64 := SumGenerics[<span class="type">int64</span>](<span class="number">10</span>, <span class="number">20</span>)     <span class="comment">// returns 30</span></span><br><span class="line">    <span class="built_in">println</span>(sumInt, sumFloat, sumInt64)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们可以看到，在调用泛型函数时通过在方括号
<code>[]</code>
中指定类型参数，我们可以对不同的数值类型执行加法操作。类型约束确保只有指定的类型
<code>[T int, int16, int32, int64, int8, float32, or float64]</code>
可以用作类型参数。</p>
<h3 id="map-中的泛型">map 中的泛型</h3>
<p><code>map</code> 的泛型需要两种类型，一个 <code>key</code> 类型和一个
<code>value</code> 类型。值类型没有任何限制，但键类型应该始终满足
<code>comparable</code> 约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keys 返回一个 map 的所有 key</span></span><br><span class="line"><span class="comment">// m 参数是使用了 K 和 V 泛型的 map</span></span><br><span class="line"><span class="comment">// K 是使用了 comparable 约束的泛型，也就是说 K 必须支持 != 和 == 操作</span></span><br><span class="line"><span class="comment">// V 是使用了 any 约束的泛型，也就是说 V 可以是任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keys</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span></span> []K &#123;</span><br><span class="line">    <span class="comment">// 创建一个长度为 map 长度的 K 类型的 slice</span></span><br><span class="line">    key := <span class="built_in">make</span>([]K, <span class="built_in">len</span>(m))</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k, _ := <span class="keyword">range</span> m &#123;</span><br><span class="line">        key[i] = k</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体中的泛型">结构体中的泛型</h3>
<p>Go 允许使用类型参数定义 <code>struct</code>
。语法类似于泛型函数。类型参数可用于结构体上的方法和数据成员。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 是类型参数，使用了 any 约束</span></span><br><span class="line"><span class="keyword">type</span> MyStruct[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    inner T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 struct 方法中不允许使用新的类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyStruct[T])</span></span> Get() T &#123;</span><br><span class="line">    <span class="keyword">return</span> m.inner</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyStruct[T])</span></span> Set(v T) &#123;</span><br><span class="line">    m.inner = v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在结构体方法中不允许定义新的类型参数，但在结构体定义中定义的类型参数可以在方法中使用。</p>
<h3 id="多个泛型参数">多个泛型参数</h3>
<p>泛型可以嵌套在其他类型中。在函数或结构中定义的类型参数可以传递给具有类型参数的任何其他类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拥有两个泛型类型的泛型 struct</span></span><br><span class="line"><span class="keyword">type</span> Entries[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key   K</span><br><span class="line">    Value V</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entries 函数返回一个 Entries 的 slice，代表了传入的 map 的所有 key 和 value</span></span><br><span class="line"><span class="comment">// K 和 V 是泛型类型参数，K 有 comparable 约束，V 没有约束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entries</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span></span> []*Entries[K, V] &#123;</span><br><span class="line">    <span class="comment">// 创建一个 Entries 类型的 slice，传入 K 和 V 类型参数</span></span><br><span class="line">    e := <span class="built_in">make</span>([]*Entries[K, V], <span class="built_in">len</span>(m))</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        <span class="comment">// 定义一个 Entries 类型的变量</span></span><br><span class="line">        newEntry := <span class="built_in">new</span>(Entries[K, V])</span><br><span class="line">        newEntry.Key = k</span><br><span class="line">        newEntry.Value = v</span><br><span class="line">        e[i] = newEntry</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过逗号分隔多个类型参数来实现多个泛型参数。</p>
<h3 id="类型并集">类型并集</h3>
<p>我们知道，在以往的 <code>interface</code>
定义中，往往都是只包含了方法定义的，如下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而现在，我们还可以在 <code>interface</code>
中定义多个类型，如下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span> | <span class="type">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种带有类型的 <code>interface</code>
可以帮助我们写出更加简洁的泛型代码，因为它可以用一个
<code>intreface</code> 来表示多个不同的相似类型。
<strong>但是这种带有类型的接口，不能用于定义变量，只能用于泛型的类型约束中。</strong></p>
<p>在上面的泛型加法实现中，我们使用了
<code>[T int | int16 | int32 | int64 | int8 | float32 | float64]</code>
这种方式来给 <code>T</code> 定义了一个约束，
但是这种方式并不是很优雅，我们可以将约束定义为一个
<code>interface</code>，然后将 <code>interface</code> 作为约束。</p>
<blockquote>
<p>我们称通过 <code>|</code> 连接的多个类型的 <code>interface</code>
为类型并集。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span> | <span class="type">int8</span> | <span class="type">int16</span> | <span class="type">int32</span> | <span class="type">int64</span> | <span class="type">float32</span> | <span class="type">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>Number</code> 来作为泛型的约束：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 可以是任意 int 或 float 类型</span></span><br><span class="line"><span class="comment">// T 只能是支持算术运算的类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span>[<span class="title">T</span> <span class="title">Number</span>]<span class="params">(x, y T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用多种类型的联合允许执行这些类型支持的常见操作，并编写适用于联合中所有类型的代码。</p>
<p>这些只是一些示例，说明了在 Go
中如何使用泛型来编写更灵活、可重用的代码。</p>
<h3 id="类型交集">类型交集</h3>
<p>类似的，还有一种类型交集的概念，它是通过在 <code>interface</code>
中写多行类型来实现的：每一行定义了一种或多种类型的并集。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AllInt <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> | ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>AllInt</code>
是一个类型并集，它包含了所有整数类型。<code>Uint</code>
是一个类型并集，它包含了所有无符号整数类型。</p>
<p>下面是一个使用类型交集的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取 AllInt 和 Uint 的交集</span></span><br><span class="line"><span class="comment">// 也就是：~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64</span></span><br><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    AllInt</span><br><span class="line">	Uint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实它的最终的结果等同于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除此之外，如果其中不同行之间没有任何交集，那么它们的交集就是空集。在现实中可能意义不大。</p>
</blockquote>
<h3 id="泛型接口和泛型结构体">泛型接口和泛型结构体</h3>
<p>在 Go 中，<code>struct</code> 和 <code>interface</code>
都可以使用泛型。</p>
<p>例如，在下面的代码片段中，类型参数 <code>T</code> 的任何值只支持
<code>String</code> 方法 - 您可以使用 <code>len()</code>
或对其进行任何其他操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringer 是一个约束</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T 需要实现 Stringer 接口，T 只能执行 Stringer 接口中定义的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringer</span>[<span class="title">T</span> <span class="title">Stringer</span>]<span class="params">(s T)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再比如，下面的例子中，是一个使用了泛型的 <code>struct</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person[T <span class="type">int</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">	age T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person[T])</span></span> Age() T &#123;</span><br><span class="line">	<span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个 <code>struct</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p Person[<span class="type">int</span>]</span><br><span class="line">p.age = <span class="number">10</span></span><br><span class="line">fmt.Println(p.Age()) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-指定底层类型">使用 ~ 指定底层类型</h2>
<p>在 Go 中，定义了一个 <code>cmp.Ordered</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> |</span><br><span class="line">		~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span> |</span><br><span class="line">		~<span class="type">float32</span> | ~<span class="type">float64</span> |</span><br><span class="line">		~<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个声明表示 <code>Ordered</code>
是所有整数、浮点数、和字符串类型的集合。</p>
<p>对于类型约束，我们通常不关心特定类型，比如
<code>string</code>，我们对所有字符串类型感兴趣，所以我们使用
<code>~string</code> 来表示所有字符串类型的集合。 <code>~string</code>
表达式表示所有底层类型为 <code>string</code> 的类型的集合，这包括类型
<code>string</code> 本身以及所有使用如 <code>type MyString string</code>
声明定义的类型。</p>
<p>下面是一个错误的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 Slice[<span class="type">int</span>] <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="comment">// 错误。MyInt 类型底层类型是 int 但并不是 int 类型，不符合 Slice[T] 的类型约束</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt]</span><br></pre></td></tr></table></figure>
<p>正确的做法是，将 <code>Slice</code> 的类型约束修改为
<code>~int</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 的底层类型是 int 即可，不一定是 int 类型</span></span><br><span class="line"><span class="keyword">type</span> Slice[T ~<span class="type">int</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 Slice[<span class="type">int</span>] <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="comment">// 错误。MyInt 类型底层类型是 int 但并不是 int 类型，不符合 Slice[T] 的类型约束</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt]</span><br></pre></td></tr></table></figure>
<p>使用 <code>~</code> 有个限制：</p>
<ul>
<li><code>~</code> 后面的类型不能为接口</li>
<li><code>~</code> 后面的类型必须为基础类型</li>
</ul>
<p>比如，下面是一个错误的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：Invalid use of ~ (&#x27;cmp.Ordered&#x27; is an interface)</span></span><br><span class="line"><span class="keyword">type</span> Ab[T ~cmp.Ordered] <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型的限制">泛型的限制</h2>
<p>尽管 Go
语言中的泛型带来了许多好处和新的可能性，但它们的实现仍然存在一些限制和挑战。以下是
Go 语言中泛型的一些主要限制：</p>
<ul>
<li>性能：在 Go
语言中，泛型的一个主要问题是对性能的潜在影响。引入泛型后，Go
编译器需要在编译时为不同类型生成代码，这可能导致更大的二进制文件和更慢的编译时间。</li>
<li>类型约束：Go
语言的泛型实现依赖于类型约束来确保类型安全。然而，这些约束可能会限制可以与泛型函数和数据结构一起使用的类型。</li>
<li>语法复杂性：声明和使用泛型函数和数据结构的语法可能会很复杂，尤其对于初学者来说难以理解。</li>
<li>错误消息：Go
编译器生成的与泛型相关的问题的错误消息可能难以理解，使得调试和故障排除更具挑战性。</li>
<li>代码可读性：在 Go
中，泛型有时会使代码变得不太易读，更难理解，特别是在大量使用类型约束和类型参数的情况下。</li>
<li>无法进行切换：当您想要从一个基础泛型类型切换到另一个时，使用泛型是不可能的。唯一的方法是使用接口，并在运行时运行类型切换函数。</li>
</ul>
<h2 id="总结">总结</h2>
<p>泛型为创建通用接口、结构体和函数提供了一种强大而简单的方法。</p>
<p>它们可以减少冗余信息，并且至少在某些情况下，提供了一种比反射更优越的替代方案。</p>
<p>当然，长时间以来，泛型受到激烈反对的主要原因是它们可能使代码更难阅读和解析，这似乎与
Go 语言的简洁性相悖。
鉴于此，本文也不会介绍太多复杂的泛型用法，上面提到的这些用法应该可以覆盖
90% 以上的使用场景了，因为复杂的代码必然会牺牲不少代码的可维护性。</p>
<p>另一方面，泛型是语言中的一个很好且必要的补充，如果明智地使用并且在有意义的地方使用的话。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2024/02/01/golang/Golang%20%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%B7%A5%E5%85%B7%20-%20golangci-lint%20%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/01/golang/Golang%20%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%B7%A5%E5%85%B7%20-%20golangci-lint%20%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Golang 代码质量工具 - golangci-lint 不完全指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-01 20:28:30" itemprop="dateCreated datePublished" datetime="2024-02-01T20:28:30+08:00">2024-02-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Linting</code>
是识别和报告代码中发现的模式的过程，旨在提高一致性，并在开发周期的早期捕捉错误。
在团队合作时特别有用，因为它有助于使所有代码看起来都一样，无论是谁写的，这减少了复杂性，使代码更易于维护。
在本文中，将演示针对 Go 程序的全面 <code>linting</code>
设置，并讨论将其引入现有项目的最佳方法。</p>
<p>代码检查是确保项目中一致的编码规范的最基本的事情之一。
Go语言已经比大多数其他编程语言走得更远，它捆绑了一个格式化工具（也就是
<code>gofmt</code>），确保所有的Go代码看起来都一样，但它只处理代码的格式。
<code>go vet</code>
工具也可用于帮助检测可能不会被编译器捕捉到的可疑结构，但它只能捕捉有限数量的潜在问题。</p>
<p>开发更全面的代码检查工具的任务已交给更广泛的社区，这产生了大量的代码检查工具，每个工具都有特定的目的。其中一些著名的例子包括：</p>
<ul>
<li><code>unused</code> - 检查 Go
代码中未使用的常量、变量、函数和类型。</li>
<li><code>goconst</code> - 查找可以用常量替换的重复字符串。</li>
<li><code>gocyclo</code> - 计算并检查函数的圈复杂度。</li>
<li><code>errcheck</code> - 检测Go程序中未检查的错误。</li>
</ul>
<p>拥有如此多独立的代码检查工具的问题在于你必须自己下载每个单独的代码检查工具并管理它们的版本。
此外，依次运行每一个可能会太慢。因此，<code>golangci-lint</code>，一个Go代码检查工具聚合器，可以并行运行代码检查工具，重用
Go 构建缓存，并缓存分析结果，从而在后续运行中大大提高性能，是在 Go
项目中设置代码检查的首选方式。</p>
<p>该项目是为了方便和提高性能而开发的，可以同时聚合和运行多个单独的代码检查工具。安装该程序后，您将获得约
48
个代码检查工具，您可以选择其中对您的项目重要的工具。除了在开发过程中本地运行外，您还可以将其设置为持续集成（<code>CI</code>）工作流程的一部分。</p>
<h2 id="安装-golangci-lint">安装 golangci-lint</h2>
<p>你可以通过下面的命令将 <code>golangci-lint</code>
安装到你的系统中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest</span><br></pre></td></tr></table></figure>
<p>安装完成后，您应该检查已安装的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ golangci-lint version</span><br><span class="line">golangci-lint has version v1.55.2 built with go1.21.6 from (unknown, mod sum: &quot;h1:yllEIsSJ7MtlDBwDJ9IMBkyEUz2fYE0b5B8IUgO1oP8=&quot;) on (unknown)</span><br></pre></td></tr></table></figure>
<p>您还可以通过以下命令查看所有可用的代码检查器:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">golangci-lint <span class="built_in">help</span> linters</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enabled by default linters:</span><br><span class="line">errcheck: errcheck is a program for checking for unchecked errors in Go code. These unchecked errors can be critical bugs in some cases [fast: false, auto-fix: false]</span><br><span class="line">gosimple (megacheck): Linter for Go source code that specializes in simplifying code [fast: false, auto-fix: false]</span><br><span class="line">govet (vet, vetshadow): Vet examines Go source code and reports suspicious constructs, such as Printf calls whose arguments do not align with the format string [fast: false, auto-fix: false]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>也就是说 <code>golangci-lint</code> 默认已经启用了
<code>errcheck</code>、<code>govet</code> 等代码检查器。</p>
<blockquote>
<p>默认启用小部分，大部分默认处于禁用状态。</p>
</blockquote>
<p>如果在项目目录的根目录运行启用的代码检查工具，可能会看到一些错误。
每个问题都会报告所有您需要修复它的上下文，包括问题的简短描述，以及它发生的文件和行号。</p>
<p>进入项目目录，执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">golangci-lint run</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main.go:1: : # gopprof</span><br><span class="line">./main.go:31:2: err declared and not used (typecheck)</span><br><span class="line">package main</span><br></pre></td></tr></table></figure>
<blockquote>
<p>golangci-lint
提供了带颜色、源代码行和标识符的良好输出，以便您可以轻松地找到问题所在。</p>
</blockquote>
<p>您还可以通过传递一个或多个目录或文件路径来选择要分析的目录和文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">golangci-lint run dir1 dir2 dir3/main.go</span><br></pre></td></tr></table></figure>
<h2 id="配置-golangci-lint">配置 golangci-lint</h2>
<p><code>golangci-lint</code> 旨在尽可能灵活，适用于各种用例。
可以通过命令行选项或配置文件来管理 <code>golangci-lint</code>
的配置，尽管如果同时使用两者，前者的优先级更高。
以下是一个使用命令行选项禁用所有检查器并配置应该运行的特定检查器的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">golangci-lint run --disable-all -E revive -E errcheck -E nilerr -E gosec</span><br></pre></td></tr></table></figure>
<p>这个命令只会进行
<code>revive</code>、<code>errcheck</code>、<code>nilerr</code> 和
<code>gosec</code> 检查。</p>
<blockquote>
<p>通过 <code>--disable-all</code> 禁用所有检查器，然后使用
<code>-E</code> 选项启用特定的检查器。</p>
</blockquote>
<p>您还可以运行由 <code>golangci-lint</code>
提供的预设。以下是了解可用预设的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">golangci-lint <span class="built_in">help</span> linters | sed -n <span class="string">&#x27;/Linters presets:/,$p&#x27;</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">error: errcheck, errorlint, goerr113, wrapcheck</span><br><span class="line">format: decorder, gci, gofmt, gofumpt, goimports, sloglint, tagalign</span><br><span class="line">import: depguard, gci, goimports, gomodguard</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后，您可以通过将其名称传递给 <code>--preset</code> 或
<code>-p</code> 标志来运行预设:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">golangci-lint run -p bugs -p error</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>golangci-lint</code> 的 <code>preset</code>
可以被理解为预定义的配置集，每个 <code>preset</code>
对应一组特定的配置和规则。通过使用 <code>preset</code>
，用户可以方便地启用一组默认的规则，而无需手动配置每个 linter
的选项。</p>
</blockquote>
<p>最好通过配置文件来为项目配置
<code>golangci-lint</code>。这样，您可以配置特定的代码检查器选项，这是通过命令行选项无法实现的。
您可以将配置文件指定为 <code>YAML</code>、<code>TOML</code> 或
<code>JSON</code> 格式，但我建议坚持使用 <code>YAML</code>
格式（<code>.golangci.yml</code> 或
<code>.golangci.yaml</code>），因为官方文档页面上使用的就是这种格式。</p>
<p>一般来说，你应该在项目目录的根目录中创建特定于项目的配置。程序会自动在待检查文件所在的目录以及一直向上到文件系统根目录的父目录中寻找它们。这意味着你可以通过在
<code>home</code>
目录中放置一个配置文件来实现所有项目的全局配置（不建议）。如果本地范围的配置文件不存在，将使用该文件。</p>
<p>官网上提供了一个示例配置文件，其中包含所有支持的选项、它们的描述和默认值。在创建自己的配置时，您可以将其作为起点。
请记住，一些代码检查工具执行类似的功能，因此您需要有意地启用代码检查工具，以避免重复的条目。
以下是我在个人项目中使用的一般配置（<code>.golangci.yml</code>）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">linters-settings:</span></span><br><span class="line">  <span class="attr">errcheck:</span></span><br><span class="line">    <span class="attr">check-type-assertions:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">goconst:</span></span><br><span class="line">    <span class="attr">min-len:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">min-occurrences:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">gocritic:</span></span><br><span class="line">    <span class="attr">enabled-tags:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">diagnostic</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">experimental</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">opinionated</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">performance</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">style</span></span><br><span class="line">  <span class="attr">govet:</span></span><br><span class="line">    <span class="attr">check-shadowing:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">enable:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">fieldalignment</span></span><br><span class="line">  <span class="attr">nolintlint:</span></span><br><span class="line">    <span class="attr">require-explanation:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">require-specific:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">linters:</span></span><br><span class="line">  <span class="attr">disable-all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bodyclose</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">deadcode</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">depguard</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dogsled</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dupl</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">errcheck</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">exportloopref</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">exhaustive</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">goconst</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gocritic</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gofmt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">goimports</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gomnd</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gocyclo</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gosec</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gosimple</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">govet</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ineffassign</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">misspell</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nolintlint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nakedret</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">prealloc</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">predeclared</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">revive</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">staticcheck</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">structcheck</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">stylecheck</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">thelper</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tparallel</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">typecheck</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">unconvert</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">unparam</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">varcheck</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">whitespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wsl</span></span><br><span class="line"></span><br><span class="line"><span class="attr">run:</span></span><br><span class="line">  <span class="attr">issues-exit-code:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="抑制-linting-错误">抑制 linting 错误</h2>
<p>有时需要禁用文件或包中出现的特定代码检查问题。这可以通过两种主要方式实现：通过
<code>nolint</code>
指令和配置文件中的排除规则。让我们依次看看每种方法。</p>
<h3 id="nolint-指令">nolint 指令</h3>
<p>假设我们有以下代码，它会将伪随机整数打印到标准输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	fmt.Println(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>golangci-lint</code>
时（<code>golangci-lint run --disable-all -E gosec</code>），会看到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main.go:11:14: G404: Use of weak random number generator (math/rand instead of crypto/rand) (gosec)</span><br><span class="line">        fmt.Println(rand.Int())</span><br><span class="line">                    ^</span><br></pre></td></tr></table></figure>
<p><code>linter</code> 鼓励使用 <code>crypto/rand</code> 的
<code>Int</code> 方法，因为它在密码学上更安全，但它的 API
不太友好，性能较慢。
如果你可以接受速度更快的代价来换取不太安全的伪随机数，你可以通过在必要的行上添加
<code>nolint</code> 指令来忽略错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	fmt.Println(rand.Int()) <span class="comment">//nolint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据 Go 的约定，机器可读的注释不应包含空格，因此应该使用
<code>//nolint</code> 而不是 <code>// nolint</code>。</p>
</blockquote>
<p>当您在文件顶部使用 <code>nolint</code> 指令时，它会禁用该文件的所有
<code>linting</code> 问题:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nolint:govet,errcheck</span></span><br><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure>
<p>您还可以通过在代码块（如函数）的开头使用 <code>nolint</code>
指令来排除问题。</p>
<p>添加 <code>nolint</code>
指令后，建议添加一条注释，解释为什么需要该指令。该注释应放置在与标志本身相同的行上：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	fmt.Println(rand.Int()) <span class="comment">//nolint:gosec // for faster performance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排除规则">排除规则</h3>
<p>在配置文件中可以指定排除规则，以更精细地控制对哪些文件进行代码检查，以及报告哪些问题。
例如，您可以禁用某些代码检查器在测试文件上的运行，或者可以禁用某个代码检查器在整个项目中产生特定的错误：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#.golangci.yml</span></span><br><span class="line"><span class="attr">issues:</span></span><br><span class="line">  <span class="attr">exclude-rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">_test\.go</span> <span class="comment"># disable some linters on test files</span></span><br><span class="line">      <span class="attr">linters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">gocyclo</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">gosec</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">dupl</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Exclude some gosec messages project-wide</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">linters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">gosec</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">&quot;weak cryptographic primitive&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="与现有项目集成">与现有项目集成</h2>
<p>在向现有项目添加 <code>golangci-lint</code>
时，可能会出现许多问题，一次性解决所有问题可能会很困难。
但这并不意味着你应该因此放弃对项目进行代码检查的想法。有一个
<code>new-from-rev</code> 设置，允许你仅显示在特定 git
修订版本之后创建的新问题，这样可以轻松地只对新代码进行代码检查，直到有足够的时间来解决旧问题。一旦找到要从中开始进行代码检查的修订版本（使用
<code>git log</code> ），你可以在配置文件中指定如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#.golangci.yml</span></span><br><span class="line"><span class="attr">issues:</span></span><br><span class="line">  <span class="comment"># Show only new issues created after git revision: 02270a6</span></span><br><span class="line">  <span class="attr">new-from-rev:</span> <span class="string">02270a6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样只会检查 02270a6 版本后的代码。</p>
</blockquote>
<h2 id="在你的编辑器中集成-golangci-lint">在你的编辑器中集成
golangci-lint</h2>
<p><code>golangci-lint</code> 支持与多个编辑器集成，以便快速获得反馈。在
Visual Studio Code中，您只需安装 Go 扩展，并将以下行添加到您的
<code>settings.json</code> 文件中：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;go.lintTool&quot;</span><span class="punctuation">:</span><span class="string">&quot;golangci-lint&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;go.lintFlags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;--fast&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="持续集成">持续集成</h2>
<p>在每个 PR
上运行项目的代码检查规则，可以防止不符合标准的代码进入代码库。这也可以通过将
<code>golangci-lint</code> 添加到持续集成流程中实现自动化。 比如：</p>
<ul>
<li>Github Actions（如果你使用 Github）</li>
<li>Gitlab CI（如果你使用 Gitlab）</li>
</ul>
<p>下面是一个 Github Action
配置的示例（当然，下面这个例子不太好，没有指定确定的版本）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Go</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">&quot;main&quot;</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">&quot;main&quot;</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">lint:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Lint</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">golangci-lint</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">golangci/golangci-lint-action@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">version:</span> <span class="string">latest</span></span><br><span class="line">          <span class="attr">args:</span> <span class="string">--timeout</span> <span class="string">5m</span></span><br></pre></td></tr></table></figure>
<p>在设置过程中，请确保固定使用的 <code>golangci-lint</code>
版本，以便在本地环境中产生一致的结果。</p>
<h2 id="总结">总结</h2>
<p>本文介绍了 Golang 中代码检查的工具
<code>golangci-lint</code>，并讨论了如何将其集成到现有项目中。 使用
<code>golangci-lint</code>，您可以轻松地在团队协作中保持一致的代码风格，并在开发周期的早期捕捉错误。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2024/02/01/golang/%E5%A6%82%E4%BD%95%E5%9C%A8%20Go%20%E4%B8%AD%E6%89%A7%E8%A1%8C%20shell%20%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/01/golang/%E5%A6%82%E4%BD%95%E5%9C%A8%20Go%20%E4%B8%AD%E6%89%A7%E8%A1%8C%20shell%20%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">如何在 Go 中执行 shell 命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-01 20:28:30" itemprop="dateCreated datePublished" datetime="2024-02-01T20:28:30+08:00">2024-02-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在本教程中，我们将介绍在 golang 中执行 <code>shell</code>
命令的多种方法和场景。</p>
<h2 id="使用-exec.command-运行简单的-shell-命令">使用 exec.Command()
运行简单的 shell 命令</h2>
<p>这是一个简单的 golang 代码，它使用 <code>exec.Command()</code>
函数打印当前目录的内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">	out, err := cmd.Output()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="type">string</span>(out))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要将参数传递给命令，可以将它们作为附加参数包含在
<code>exec.Command()</code>. 例如，要运行
<code>ls -l -a</code>，您可以使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你可以传递多个参数给 exec.Command()</span></span><br><span class="line"><span class="comment">// exec.Command(&quot;cmd&quot;, &quot;arg1&quot;, &quot;arg2&quot;, &quot;argn&quot;)</span></span><br><span class="line">cmd := exec.Command(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-a&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2
id="是否可以在不存储输出的情况下执行shell命令">是否可以在不存储输出的情况下执行shell命令？</h2>
<p>如果您需要仅执行某些 shell 命令而不存储输出，那么我们可以使用
<code>Run()</code> 函数而不是 <code>Output()</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ls&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行 shell 命令，但不存储输出</span></span><br><span class="line">	err := cmd.Run()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码不会产生任何输出，它只会触发 <code>ls</code> 命令并退出。</p>
<h2 id="为什么我们不应该使用-exec.command-函数">为什么我们不应该使用
exec.Command() 函数？</h2>
<p>虽然 <code>exec.Command()</code> 可以让我们执行 <code>shell</code>
命令，但是我们应该尽量避免 <code>exec.Command()</code>，原因有多种：</p>
<ul>
<li>安全风险：如果没有正确清理，传递给的参数 <code>exec.Command</code>
可能容易受到命令注入攻击。</li>
<li>资源使用：<code>exec.Command</code>
为每个命令创建一个新进程，这可能会占用大量资源并导致性能不佳。</li>
<li>有限控制：<code>exec.Command</code>
将命令作为单独的进程启动并立即返回，这意味着命令运行后您对其的控制权有限。</li>
<li>错误处理：如果 <code>exec.Command</code>
执行的命令以非零状态代码退出，则返回错误，但不提供有关错误的详细信息。</li>
<li>不可预测的行为：当命令在不同平台上运行或环境发生变化时，可能会出现意外的行为。</li>
<li>有限的互操作性：当您需要在默认 shell 之外的不同 shell
中运行命令时，这不是最佳选择。</li>
</ul>
<p>虽然 <code>exec.Command</code> 对于运行简单的 shell
命令很有用，但对于更复杂的命令或当您需要对命令执行进行更多控制时，它可能不是最佳选择。
您可以尝试考虑使用其他库（例如
Cobra）来处理应用程序中的命令行参数和命令。</p>
<h2 id="在后台执行-shell-命令并等待其完成">在后台执行 shell
命令并等待其完成</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;10&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Starting now!&quot;</span>)</span><br><span class="line">	<span class="comment">// 开始执行命令</span></span><br><span class="line">	err := cmd.Start()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待命令执行完成</span></span><br><span class="line">	err = cmd.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Completed..&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Starting now!</span><br><span class="line">Completed..</span><br></pre></td></tr></table></figure>
<h2 id="使用上下文执行-shell-命令">使用上下文执行 shell 命令</h2>
<p>我们还可以使用 <code>os/exec</code> 包的 <code>CommandContext</code>
功能，它允许传递上下文并将参数作为字符串切片传递。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	cmd := exec.CommandContext(ctx, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-a&quot;</span>)</span><br><span class="line">	out, err := cmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(out))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>context</code> 可以用于取消命令的执行（使用
<code>context.WithCancel()</code> 即可）。</p>
<h2 id="如何将变量传递给-shell-命令">如何将变量传递给 shell 命令？</h2>
<p>我们可能还需要将变量从 golang 代码传递到 shell
命令作为输入参数。这需要一些额外的处理，这里有一些可能的方法。</p>
<h3 id="方法-1传递变量作为输入参数">方法 1：传递变量作为输入参数</h3>
<p>我们可以将变量作为输入参数传递给 <code>exec.Command()</code>
如下例所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	message := <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;echo&quot;</span>, message)</span><br><span class="line">	out, err := cmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(out))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法-2使用-fmt.sprintf-函数">方法 2：使用 fmt.Sprintf()
函数</h3>
<p>我们还可以使用 <code>Sprintf</code>
函数创建一个包含命令和变量的字符串，然后将该字符串传递给
<code>Command</code> 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	message := <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">	cmdStr := fmt.Sprintf(<span class="string">&quot;echo %s&quot;</span>, message)</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmdStr)</span><br><span class="line">	out, err := cmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(out))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将整数作为变量传递给-shell-命令">将整数作为变量传递给 shell
命令</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">42</span></span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;echo&quot;</span>, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x))</span><br><span class="line">	out, err := cmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(out)) <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将浮点数作为变量传递给-shell-命令">将浮点数作为变量传递给 shell
命令</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    y := <span class="number">3.14</span></span><br><span class="line">    cmd := exec.Command(<span class="string">&quot;echo&quot;</span>, fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, y))</span><br><span class="line">    out, err := cmd.Output()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(out)) <span class="comment">// 3.140000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用管道符-传递-shell-命令">使用管道符 (|) 传递 shell 命令</h2>
<h3 id="方法-1使用-exec.command">方法 1：使用 exec.Command()</h3>
<p>我们可以通过使用 <code>exec.Command()</code> 并将命令作为由管道字符
“|” 分隔的单个字符串来传递，从而使用管道运行 shell
命令。以下是运行简单命令 <code>ls</code>、将其输出通过管道传输到 grep
命令并搜索特定文件的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ls | grep main.go&quot;</span>)</span><br><span class="line">	out, err := cmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(out))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以使用以下格式的管道传递多个命令：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd := exec.Command(<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;command1 | command2 | command3&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="方法2使用context包">方法2：使用context包</h3>
<p>我们可以使用 <code>os/exec</code> 包的 <code>CommandContext</code>
函数来实现相同的目的，该函数允许传递上下文并在字符串切片中传递命令。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	cmd := exec.CommandContext(ctx, <span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ls | grep main.go&quot;</span>)</span><br><span class="line">	out, err := cmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(out))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行多个-shell-命令">运行多个 shell 命令</h2>
<h3 id="方法-1使用-exec.command-函数">方法 1：使用 exec.Command()
函数</h3>
<p>我们可以再次使用 <code>exec.Command()</code>
函数来提供要按顺序执行的命令列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	commands := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;ping -c 2 google.com&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ping -c 2 facebook.com&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ping -c 2 www.golinuxcloud.com&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, command := <span class="keyword">range</span> commands &#123;</span><br><span class="line">		cmd := exec.Command(<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, command)</span><br><span class="line">		out, err := cmd.Output()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="type">string</span>(out))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2使用上下文功能">方法2：使用上下文功能</h3>
<p>我们还可以使用 <code>os/exec</code> 包的 <code>CommandContext</code>
函数来实现相同的目的，该函数允许传递上下文并在字符串切片中传递命令。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	commands := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;ping -c 2 google.com&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ping -c 2 yahoo.com&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ping -c 2 www.golinuxcloud.com&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, command := <span class="keyword">range</span> commands &#123;</span><br><span class="line">		cmd := exec.CommandContext(ctx, <span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, command)</span><br><span class="line">		out, err := cmd.Output()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="type">string</span>(out))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>在本文中，我们尝试介绍可在 golang 中使用的各种可能的方法来执行 shell
命令。以下是我们使用的一些方法：</p>
<ul>
<li><code>exec.Command</code>：这是在 Go 中运行 shell
命令最常用的方法。它创建一个新进程并在该进程中运行命令。该函数将命令及其参数作为单独的参数，并返回一个
<code>exec.Cmd</code> 结构体，该结构体提供与命令交互的方法。</li>
<li><code>exec.CommandContext</code>：它类似于
<code>exec.Command</code>，但它允许将上下文传递给命令（功能类似我们
<code>http</code> 中常用的 <code>context</code>）。</li>
</ul>
<p>我们还学习了如何使用 <code>Start</code> 和 <code>Wait</code>
函数在后台启动进程并等待其完成。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2024/01/31/golang/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20Go%201.21%20%E7%9A%84%E6%97%A5%E5%BF%97%E6%A0%87%E5%87%86%E5%BA%93%20-%20slog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/31/golang/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20Go%201.21%20%E7%9A%84%E6%97%A5%E5%BF%97%E6%A0%87%E5%87%86%E5%BA%93%20-%20slog/" class="post-title-link" itemprop="url">一文搞懂 Go 1.21 的日志标准库 - slog</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-01-31 20:28:30" itemprop="dateCreated datePublished" datetime="2024-01-31T20:28:30+08:00">2024-01-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在过去多年里，我们在 Go 中写日志的时候，通常都是使用
<code>Zerolog</code> 或者 <code>Zap</code> 这两个包，</p>
<p>在本文中，我们将重点探讨 Go 最近引入的 <code>log/slog</code>
包，该包旨在将高性能、结构化和分级日志记录引入 Go 标准库。</p>
<p>该软件包起源于某位用户在 GitHub 上发起的讨论：<a
target="_blank" rel="noopener" href="https://github.com/golang/go/discussions/54763">structured,
leveled logging</a>，后来演变为描述软件包设计的<a
target="_blank" rel="noopener" href="https://github.com/golang/go/issues/56345">提案</a>。经最终确定，该软件包在
<code>Go 1.21</code> 中发布，也就是现在的 <code>log/slog</code>。</p>
<p><code>slog</code> 旨在提供一个简单的
API，用于记录结构化的、分级的日志。它也可以很容易地与现有的日志记录库集成，例如
<code>Zerolog</code> 和
<code>Zap</code>，这样你就可以在不改变太多现有代码的情况下，使用
<code>slog</code> 来记录日志。（这种情况下，<code>slog</code>
只是作为日志记录库的一个 “前端”。）</p>
<p>在接下来的章节中，我将详细介绍 <code>Slog</code>
提供的内容，并附上示例。</p>
<h2 id="开始使用-slog">开始使用 Slog</h2>
<p>让我们通过对其设计和架构的讲解来开始探索 <code>log/slog</code>
包。它提供了三种主要类型，你应该熟悉：</p>
<ul>
<li><code>Logger</code>：记录 “前端”，提供诸如（<code>Info()</code> 和
<code>Error()</code>）的级别方法，用于记录感兴趣的事件。</li>
<li><code>Record</code>：由 <code>Logger</code>
创建的每个独立的日志对象的表示。</li>
<li><code>Handler</code>: 一种接口，一旦实现，就确定了每个
<code>Record</code> 的格式和目的地。 <code>log/slog</code>
包中包含两个内置处理程序： <code>TextHandler</code> 和
<code>JSONHandler</code> 分别用于 <code>key=value</code> 和
<code>JSON</code> 输出。</li>
</ul>
<p>与大多数 Go 日志库一样， <code>slog</code> 包公开了一个默认的
<code>Logger</code>
，可以通过顶层函数访问。这个记录器产生的输出几乎与旧的
<code>log.Printf()</code> 方法完全相同，只是包含了日志级别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;log/slog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Print(<span class="string">&quot;Info message&quot;</span>)</span><br><span class="line">    slog.Info(<span class="string">&quot;Info message&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2024/01/03 10:24:22 Info message</span><br><span class="line">2024/01/03 10:24:22 INFO Info message</span><br></pre></td></tr></table></figure>
<p>这是一个有点奇怪的默认设置，因为 <code>Slog</code>
的主要目的是将结构化日志记录引入标准库。</p>
<p>通过使用 <code>slog.New()</code> 方法创建自定义 <code>Logger</code>
实例来纠正这个问题是相当容易的。它接受 <code>Handler</code>
接口的实现，该接口确定日志的格式和写入位置。</p>
<p>这是一个使用内置 <code>JSONHandler</code> 类型将 JSON 日志输出到
<code>stdout</code> 的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logger := slog.New(slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>))</span><br><span class="line">    logger.Debug(<span class="string">&quot;Debug message&quot;</span>)</span><br><span class="line">    logger.Info(<span class="string">&quot;Info message&quot;</span>)</span><br><span class="line">    logger.Warn(<span class="string">&quot;Warning message&quot;</span>)</span><br><span class="line">    logger.Error(<span class="string">&quot;Error message&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2023-03-15T12:59:22.227408691+01:00&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;msg&quot;:&quot;Info message&quot;&#125;</span><br><span class="line">&#123;&quot;time&quot;:&quot;2023-03-15T12:59:22.227468972+01:00&quot;,&quot;level&quot;:&quot;WARN&quot;,&quot;msg&quot;:&quot;Warning message&quot;&#125;</span><br><span class="line">&#123;&quot;time&quot;:&quot;2023-03-15T12:59:22.227472149+01:00&quot;,&quot;level&quot;:&quot;ERROR&quot;,&quot;msg&quot;:&quot;Error message&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>当使用 <code>TextHandler</code> 类型时，每个日志记录将按照
<code>Logfmt</code> 标准进行格式化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger := slog.New(slog.NewTextHandler(os.Stdout, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time=2023-03-15T13:00:11.333+01:00 level=INFO msg=&quot;Info message&quot;</span><br><span class="line">time=2023-03-15T13:00:11.333+01:00 level=WARN msg=&quot;Warning message&quot;</span><br><span class="line">time=2023-03-15T13:00:11.333+01:00 level=ERROR msg=&quot;Error message&quot;</span><br></pre></td></tr></table></figure>
<p>所有 <code>Logger</code> 实例默认记录在 <code>INFO</code>
级别，这会导致 <code>DEBUG</code>
条目被抑制，但您可以根据需要轻松更新。</p>
<h2 id="自定义默认记录器">自定义默认记录器</h2>
<p>定制默认 <code>Logger</code> 最直接的方法是利用
<code>slog.SetDefault()</code>
方法，允许您用自定义的日志记录器替换默认的日志记录器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logger := slog.New(slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">    slog.SetDefault(logger)</span><br><span class="line"></span><br><span class="line">    slog.Info(<span class="string">&quot;Info message&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您现在会注意到，软件包的顶层日志记录方法现在会生成如下所示的 JSON
输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2023-03-15T13:02:22.227408691+01:00&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;msg&quot;:&quot;Info message&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>SetDefault()</code> 方法还会改变 <code>log</code>
包使用的默认 <code>log.Logger</code>。这种行为允许利用旧
<code>log</code> 包的现有应用程序无缝过渡到结构化日志记录：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logger := slog.New(slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">    slog.SetDefault(logger)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// elsewhere in the application</span></span><br><span class="line">    log.Println(<span class="string">&quot;Hello from old logger&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2023-03-15T13:03:22.227408691+01:00&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;msg&quot;:&quot;Hello from old logger&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>当您需要使用需要后者（例如 <code>http.Server.ErrorLog</code>）的 API
时，也可以使用 <code>slog.NewLogLogger()</code> 方法将
<code>slog.Logger</code> 转换为 <code>log.Logger</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handler := slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    logger := slog.NewLogLogger(handler, slog.LevelError)</span><br><span class="line"></span><br><span class="line">    _ = http.Server&#123;</span><br><span class="line">        <span class="comment">// this API only accepts `log.Logger`</span></span><br><span class="line">        ErrorLog: logger,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将上下文属性添加到日志记录">将上下文属性添加到日志记录</h2>
<p>结构化日志比非结构化格式的一个重要优势是能够在日志记录中添加任意属性作为键值对。</p>
<p>这些属性提供了有关已记录事件的额外上下文，这对于诸如故障排除、生成指标、审计和其他各种目的非常有价值。</p>
<p>这里有一个示例，说明了它在 <code>Slog</code> 中是如何工作的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">logger.Info(</span><br><span class="line">  <span class="string">&quot;incoming request&quot;</span>,</span><br><span class="line">  <span class="string">&quot;method&quot;</span>, <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="string">&quot;time_taken_ms&quot;</span>, <span class="number">158</span>,</span><br><span class="line">  <span class="string">&quot;path&quot;</span>, <span class="string">&quot;/hello/world?q=search&quot;</span>,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>, <span class="number">200</span>,</span><br><span class="line">  <span class="string">&quot;user_agent&quot;</span>, <span class="string">&quot;Googlebot/2.1 (+http://www.google.com/bot.html)&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;:&quot;2023-02-24T11:52:49.554074496+01:00&quot;,</span><br><span class="line">  &quot;level&quot;:&quot;INFO&quot;,</span><br><span class="line">  &quot;msg&quot;:&quot;incoming request&quot;,</span><br><span class="line">  &quot;method&quot;:&quot;GET&quot;,</span><br><span class="line">  &quot;time_taken_ms&quot;:158,</span><br><span class="line">  &quot;path&quot;:&quot;/hello/world?q=search&quot;,</span><br><span class="line">  &quot;status&quot;:200,</span><br><span class="line">  &quot;user_agent&quot;:&quot;Googlebot/2.1 (+http://www.google.com/bot.html)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有级别方法（<code>Info()</code>，<code>Debug()</code>
等）都接受日志消息作为它们的第一个参数，以及之后无限数量的松散类型的键/值对。</p>
<p>这个 API 类似于 <code>Zap</code> 中的
<code>SugaredLogger API</code>（特别是它的以 <code>w</code>
结尾的级别方法），因为它在追求简洁的同时牺牲了额外的内存分配。</p>
<p>但要小心，因为这种方法可能会导致意想不到的问题。具体来说，不平衡的键/值对可能会导致问题输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logger.Info(</span><br><span class="line">  &quot;incoming request&quot;,</span><br><span class="line">  &quot;method&quot;, &quot;GET&quot;,</span><br><span class="line">  &quot;time_taken_ms&quot;, // the value for this key is missing</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>由于 <code>time_taken_ms</code> 键没有对应的值，它将被视为具有键
<code>!BADKEY</code>
的值。这并不好，因为属性不对齐可能会产生错误的条目，直到您需要使用日志时才会知道。</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;: &quot;2023-03-15T13:15:29.956566795+01:00&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="line">  &quot;msg&quot;: &quot;incoming request&quot;,</span><br><span class="line">  &quot;method&quot;: &quot;GET&quot;,</span><br><span class="line">  &quot;!BADKEY&quot;: &quot;time_taken_ms&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止这样的问题，您可以运行 vet
命令或使用一个代码检查工具来自动报告这些问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go vet .</span><br><span class="line">./main.go:11:2: call to slog.Info missing a final value</span><br></pre></td></tr></table></figure>
<p>另一种防止这种错误的方法是使用如下所示的强类型上下文属性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logger.Info(</span><br><span class="line">  <span class="string">&quot;incoming request&quot;</span>,</span><br><span class="line">  slog.String(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;GET&quot;</span>),</span><br><span class="line">  slog.Int(<span class="string">&quot;time_taken_ms&quot;</span>, <span class="number">158</span>),</span><br><span class="line">  slog.String(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;/hello/world?q=search&quot;</span>),</span><br><span class="line">  slog.Int(<span class="string">&quot;status&quot;</span>, <span class="number">200</span>),</span><br><span class="line">  slog.String(</span><br><span class="line">    <span class="string">&quot;user_agent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Googlebot/2.1 (+http://www.google.com/bot.html)&quot;</span>,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>虽然这是一种更好的上下文日志记录方法，但它并非百分之百可靠，因为没有阻止你像这样混合使用强类型和弱类型的键值对：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logger.Info(</span><br><span class="line">  <span class="string">&quot;incoming request&quot;</span>,</span><br><span class="line">  <span class="string">&quot;method&quot;</span>, <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  slog.Int(<span class="string">&quot;time_taken_ms&quot;</span>, <span class="number">158</span>),</span><br><span class="line">  slog.String(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;/hello/world?q=search&quot;</span>),</span><br><span class="line">  <span class="string">&quot;status&quot;</span>, <span class="number">200</span>,</span><br><span class="line">  slog.String(</span><br><span class="line">    <span class="string">&quot;user_agent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Googlebot/2.1 (+http://www.google.com/bot.html)&quot;</span>,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>为了确保在向记录添加上下文属性时的类型安全性，您必须像这样使用
<code>LogAttrs()</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">logger.LogAttrs(</span><br><span class="line">  context.Background(),</span><br><span class="line">  slog.LevelInfo,</span><br><span class="line">  <span class="string">&quot;incoming request&quot;</span>,</span><br><span class="line">  slog.String(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;GET&quot;</span>),</span><br><span class="line">  slog.Int(<span class="string">&quot;time_taken_ms&quot;</span>, <span class="number">158</span>),</span><br><span class="line">  slog.String(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;/hello/world?q=search&quot;</span>),</span><br><span class="line">  slog.Int(<span class="string">&quot;status&quot;</span>, <span class="number">200</span>),</span><br><span class="line">  slog.String(</span><br><span class="line">    <span class="string">&quot;user_agent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Googlebot/2.1 (+http://www.google.com/bot.html)&quot;</span>,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>该方法只接受自定义属性的 <code>slog.Attr</code>
类型，因此不可能存在不平衡的键/值对。然而，它的 API
更加复杂，因为您总是需要传递上下文（或 <code>nil</code>
）和日志级别到该方法，除了日志消息和自定义属性。</p>
<h2 id="分组上下文属性">分组上下文属性</h2>
<p><code>Slog</code>
还允许将多个属性分组在一个名称下，但输出取决于使用的
<code>Handler</code> 。例如，使用 <code>JSONHandler</code>
，每个组都嵌套在 JSON 对象中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logger.LogAttrs(</span><br><span class="line">  context.Background(),</span><br><span class="line">  slog.LevelInfo,</span><br><span class="line">  <span class="string">&quot;image uploaded&quot;</span>,</span><br><span class="line">  slog.Int(<span class="string">&quot;id&quot;</span>, <span class="number">23123</span>),</span><br><span class="line">  slog.Group(<span class="string">&quot;properties&quot;</span>,</span><br><span class="line">    slog.Int(<span class="string">&quot;width&quot;</span>, <span class="number">4000</span>),</span><br><span class="line">    slog.Int(<span class="string">&quot;height&quot;</span>, <span class="number">3000</span>),</span><br><span class="line">    slog.String(<span class="string">&quot;format&quot;</span>, <span class="string">&quot;jpeg&quot;</span>),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;:&quot;2023-02-24T12:03:12.175582603+01:00&quot;,</span><br><span class="line">  &quot;level&quot;:&quot;INFO&quot;,</span><br><span class="line">  &quot;msg&quot;:&quot;image uploaded&quot;,</span><br><span class="line">  &quot;id&quot;:23123,</span><br><span class="line">  &quot;properties&quot;:&#123;</span><br><span class="line">    &quot;width&quot;:4000,</span><br><span class="line">    &quot;height&quot;:3000,</span><br><span class="line">    &quot;format&quot;:&quot;jpeg&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用 <code>TextHandler</code>
时，组中的每个键都将以组名作为前缀，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time=2023-02-24T12:06:20.249+01:00 level=INFO msg=&quot;image uploaded&quot; id=23123</span><br><span class="line">  properties.width=4000 properties.height=3000 properties.format=jpeg</span><br></pre></td></tr></table></figure>
<h2 id="创建和使用子记录器">创建和使用子记录器</h2>
<p>在特定范围内的所有记录中包含相同的属性可能有益，可以确保它们的存在，而无需重复的记录语句。</p>
<p>这就是孩子记录器可以发挥作用的地方，因为它们创建了一个新的日志上下文，继承自其父级，同时允许包含额外的字段。</p>
<p>在 <code>Slog</code> 中，使用 <code>Logger.With()</code>
方法可以创建子记录器。它接受一个或多个键/值对，并返回一个包含指定属性的新
<code>Logger</code> 。</p>
<p>考虑以下代码片段，它将程序的进程ID和用于编译的 Go
版本添加到每个日志记录中，并将它们存储在一个 <code>program_info</code>
属性中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handler := slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>)</span><br><span class="line">    buildInfo, _ := debug.ReadBuildInfo()</span><br><span class="line"></span><br><span class="line">    logger := slog.New(handler)</span><br><span class="line"></span><br><span class="line">    child := logger.With(</span><br><span class="line">        slog.Group(<span class="string">&quot;program_info&quot;</span>,</span><br><span class="line">            slog.Int(<span class="string">&quot;pid&quot;</span>, os.Getpid()),</span><br><span class="line">            slog.String(<span class="string">&quot;go_version&quot;</span>, buildInfo.GoVersion),</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个配置，<code>child</code>
记录器创建的所有记录都将包含指定属性在 <code>program_info</code>
属性下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line"></span><br><span class="line">    child.Info(<span class="string">&quot;image upload successful&quot;</span>, slog.String(<span class="string">&quot;image_id&quot;</span>, <span class="string">&quot;39ud88&quot;</span>))</span><br><span class="line">    child.Warn(</span><br><span class="line">        <span class="string">&quot;storage is 90% full&quot;</span>,</span><br><span class="line">        slog.String(<span class="string">&quot;available_space&quot;</span>, <span class="string">&quot;900.1 mb&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;: &quot;2023-02-26T19:26:46.046793623+01:00&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="line">  &quot;msg&quot;: &quot;image upload successful&quot;,</span><br><span class="line">  &quot;program_info&quot;: &#123;</span><br><span class="line">    &quot;pid&quot;: 229108,</span><br><span class="line">    &quot;go_version&quot;: &quot;go1.20&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;image_id&quot;: &quot;39ud88&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;: &quot;2023-02-26T19:26:46.046847902+01:00&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;WARN&quot;,</span><br><span class="line">  &quot;msg&quot;: &quot;storage is 90% full&quot;,</span><br><span class="line">  &quot;program_info&quot;: &#123;</span><br><span class="line">    &quot;pid&quot;: 229108,</span><br><span class="line">    &quot;go_version&quot;: &quot;go1.20&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;available_space&quot;: &quot;900.1 MB&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以使用 <code>WithGroup()</code>
方法创建一个子记录器，以便启动一个组，使所有添加到记录器的属性（包括在日志点添加的属性）都嵌套在组名称下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">handler := slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>)</span><br><span class="line">buildInfo, _ := debug.ReadBuildInfo()</span><br><span class="line">logger := slog.New(handler).WithGroup(<span class="string">&quot;program_info&quot;</span>)</span><br><span class="line"></span><br><span class="line">child := logger.With(</span><br><span class="line">  slog.Int(<span class="string">&quot;pid&quot;</span>, os.Getpid()),</span><br><span class="line">  slog.String(<span class="string">&quot;go_version&quot;</span>, buildInfo.GoVersion),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">child.Warn(</span><br><span class="line">  <span class="string">&quot;storage is 90% full&quot;</span>,</span><br><span class="line">  slog.String(<span class="string">&quot;available_space&quot;</span>, <span class="string">&quot;900.1 MB&quot;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;: &quot;2023-05-24T19:00:18.384136084+01:00&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;WARN&quot;,</span><br><span class="line">  &quot;msg&quot;: &quot;storage is 90% full&quot;,</span><br><span class="line">  &quot;program_info&quot;: &#123;</span><br><span class="line">    &quot;pid&quot;: 1971993,</span><br><span class="line">    &quot;go_version&quot;: &quot;go1.20.2&quot;,</span><br><span class="line">    &quot;available_space&quot;: &quot;900.1 mb&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义-slog-级别">自定义 Slog 级别</h2>
<p><code>log/slog</code>
包默认提供了四个日志级别，每个级别都与一个整数值相关联：<code>DEBUG(-4)</code>、<code>INFO(0)</code>、<code>WARN(4)</code>
和 <code>ERROR(8)</code>。</p>
<p>每个级别之间的间隔为
4，这是一个经过深思熟虑的设计决定，以适应具有自定义级别的日志方案。例如，您可以在
<code>INFO</code> 和 <code>WARN</code>
之间创建一个自定义级别，其值为1、2或3。</p>
<p>我们先前观察到，默认情况下，所有记录器都配置为以 <code>INFO</code>
级别记录日志，这会导致记录在更低严重性（如 DEBUG
）的事件被抑制。您可以通过以下 <code>HandlerOptions</code>
类型自定义此行为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    opts := &amp;slog.HandlerOptions&#123;</span><br><span class="line">        Level: slog.LevelDebug,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handler := slog.NewJSONHandler(os.Stdout, opts)</span><br><span class="line"></span><br><span class="line">    logger := slog.New(handler)</span><br><span class="line">    logger.Debug(<span class="string">&quot;Debug message&quot;</span>)</span><br><span class="line">    logger.Info(<span class="string">&quot;Info message&quot;</span>)</span><br><span class="line">    logger.Warn(<span class="string">&quot;Warning message&quot;</span>)</span><br><span class="line">    logger.Error(<span class="string">&quot;Error message&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2023-05-24T19:03:10.70311982+01:00&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;msg&quot;:&quot;Debug message&quot;&#125;</span><br><span class="line">&#123;&quot;time&quot;:&quot;2023-05-24T19:03:10.703187713+01:00&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;msg&quot;:&quot;Info message&quot;&#125;</span><br><span class="line">&#123;&quot;time&quot;:&quot;2023-05-24T19:03:10.703190419+01:00&quot;,&quot;level&quot;:&quot;WARN&quot;,&quot;msg&quot;:&quot;Warning message&quot;&#125;</span><br><span class="line">&#123;&quot;time&quot;:&quot;2023-05-24T19:03:10.703192892+01:00&quot;,&quot;level&quot;:&quot;ERROR&quot;,&quot;msg&quot;:&quot;Error message&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>这种设置级别的方法会在整个生命周期中固定级别。如果需要动态变化的最小级别，必须使用下面所示的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logLevel := &amp;slog.LevelVar&#123;&#125; <span class="comment">// INFO</span></span><br><span class="line"></span><br><span class="line">    opts := &amp;slog.HandlerOptions&#123;</span><br><span class="line">        Level: logLevel,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handler := slog.NewJSONHandler(os.Stdout, opts)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您随时可以使用以下方法更新日志级别:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logLevel.Set(slog.LevelDebug)</span><br></pre></td></tr></table></figure>
<h2 id="创建自定义日志级别">创建自定义日志级别</h2>
<p>如果您需要超出 <code>Slog</code>
默认提供的自定义级别，可以通过实现以下签名的 <code>Leveler</code>
接口来创建它们：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Leveler <span class="keyword">interface</span> &#123;</span><br><span class="line">    Level() Level</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过下面显示的类型很容易实现这个接口（因为 <code>Level</code>
本身实现了 <code>Leveler</code>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    LevelTrace  = slog.Level(<span class="number">-8</span>)</span><br><span class="line">    LevelFatal  = slog.Level(<span class="number">12</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>一旦您按上述方式定义了自定义级别，您只能通过 <code>Log()</code> 或
<code>LogAttrs()</code> 方法使用它们：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">opts := &amp;slog.HandlerOptions&#123;</span><br><span class="line">    Level: LevelTrace,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger := slog.New(slog.NewJSONHandler(os.Stdout, opts))</span><br><span class="line"></span><br><span class="line">ctx := context.Background()</span><br><span class="line">logger.Log(ctx, LevelTrace, <span class="string">&quot;Trace message&quot;</span>)</span><br><span class="line">logger.Log(ctx, LevelFatal, <span class="string">&quot;Fatal level&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2023-02-24T09:26:41.666493901+01:00&quot;,&quot;level&quot;:&quot;DEBUG-4&quot;,&quot;msg&quot;:&quot;Trace level&quot;&#125;</span><br><span class="line">&#123;&quot;time&quot;:&quot;2023-02-24T09:26:41.666602404+01:00&quot;,&quot;level&quot;:&quot;ERROR+4&quot;,&quot;msg&quot;:&quot;Fatal level&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>注意自定义级别是如何以默认级别标记的。这绝对不是你想要的，所以你应该通过
<code>HandlerOptions</code> 类型自定义级别名称，就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> LevelNames = <span class="keyword">map</span>[slog.Leveler]<span class="type">string</span>&#123;</span><br><span class="line">    LevelTrace:      <span class="string">&quot;TRACE&quot;</span>,</span><br><span class="line">    LevelFatal:      <span class="string">&quot;FATAL&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    opts := slog.HandlerOptions&#123;</span><br><span class="line">        Level: LevelTrace,</span><br><span class="line">        ReplaceAttr: <span class="function"><span class="keyword">func</span><span class="params">(groups []<span class="type">string</span>, a slog.Attr)</span></span> slog.Attr &#123;</span><br><span class="line">            <span class="keyword">if</span> a.Key == slog.LevelKey &#123;</span><br><span class="line">                level := a.Value.Any().(slog.Level)</span><br><span class="line">                levelLabel, exists := LevelNames[level]</span><br><span class="line">                <span class="keyword">if</span> !exists &#123;</span><br><span class="line">                    levelLabel = level.String()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                a.Value = slog.StringValue(levelLabel)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该 <code>ReplaceAttr()</code> 函数用于自定义 <code>Handler</code>
处理 <code>Record</code>
中每个键值对的方式。它可以用于自定义键名，或以某种方式处理值。</p>
<p>在上面的示例中，它将自定义日志级别映射到它们各自的标签，分别生成
<code>TRACE</code> 和 <code>FATAL</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2023-02-24T09:27:51.747625912+01:00&quot;,&quot;level&quot;:&quot;TRACE&quot;,&quot;msg&quot;:&quot;Trace level&quot;&#125;</span><br><span class="line">&#123;&quot;time&quot;:&quot;2023-02-24T09:27:51.747737319+01:00&quot;,&quot;level&quot;:&quot;FATAL&quot;,&quot;msg&quot;:&quot;Fatal level&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义-slog-处理程序handler">自定义 Slog
处理程序（Handler）</h2>
<p>如前所述，<code>TextHandler</code> 和 <code>JSONHandler</code>
都可以使用 <code>HandlerOptions</code>
类型进行自定义。您已经看到了如何调整最小级别并修改属性以记录它们。</p>
<p>如果需要，可以通过包括日志来源来实现另一种定制化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opts := &amp;slog.HandlerOptions&#123;</span><br><span class="line">    AddSource: <span class="literal">true</span>,</span><br><span class="line">    Level:     slog.LevelDebug,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;: &quot;2024-01-03T11:06:50.971029852+01:00&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;DEBUG&quot;,</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;function&quot;: &quot;main.main&quot;,</span><br><span class="line">    &quot;file&quot;: &quot;/home/ayo/dev/betterstack/demo/slog/main.go&quot;,</span><br><span class="line">    &quot;line&quot;: 17</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;msg&quot;: &quot;Debug message&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据应用环境轻松切换足够的处理程序也很容易。例如，您可能更喜欢在开发日志中使用
<code>TextHandler</code> ，因为它更容易阅读，然后在生产环境中切换到
<code>JSONHandler</code> ，以获得更灵活性和与各种日志工具的兼容性。</p>
<p>这种行为可以通过环境变量轻松实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> appEnv = os.Getenv(<span class="string">&quot;APP_ENV&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    opts := &amp;slog.HandlerOptions&#123;</span><br><span class="line">        Level: slog.LevelDebug,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> handler slog.Handler = slog.NewTextHandler(os.Stdout, opts)</span><br><span class="line">    <span class="keyword">if</span> appEnv == <span class="string">&quot;production&quot;</span> &#123;</span><br><span class="line">        handler = slog.NewJSONHandler(os.Stdout, opts)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger := slog.New(handler)</span><br><span class="line"></span><br><span class="line">    logger.Info(<span class="string">&quot;Info message&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time=2023-02-24T10:36:39.697+01:00 level=INFO msg=&quot;Info message&quot;</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APP_ENV=production go run main.go</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2023-02-24T10:35:16.964821548+01:00&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;msg&quot;:&quot;Info message&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建自定义处理程序">创建自定义处理程序</h3>
<p>由于 <code>Handler</code>
是一个接口，可以创建自定义处理程序，以不同的格式格式化日志或将其写入其他目的地。</p>
<p>它的签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    Enabled(context.Context, Level) <span class="type">bool</span></span><br><span class="line">    Handle(context.Context, r Record) <span class="type">error</span></span><br><span class="line">    WithAttrs(attrs []Attr) Handler</span><br><span class="line">    WithGroup(name <span class="type">string</span>) Handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是每种方法的作用：</p>
<ul>
<li><code>Enabled</code>:
根据其级别确定是否处理或丢弃日志记录。也可以使用 context 做出决定。</li>
<li><code>Handle</code>: 处理每个发送到处理程序的日志记录。仅在
Enabled() 返回 true 时调用。</li>
<li><code>WithAttrs</code>:
从现有的处理程序创建一个新的处理程序，并将指定的属性添加到其中。</li>
<li><code>WithGroup</code>:
从现有的处理程序创建一个新的处理程序，并将指定的组名添加到其中，以便该名称限定后续的属性。</li>
</ul>
<p>这是一个使用 <code>log</code>、<code>json</code> 和
<code>color</code> 包来实现日志记录的美化开发输出的示例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：下面代码没有经过完整测试，只是为了说明可能的用法</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;log/slog&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/fatih/color&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PrettyHandlerOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    SlogOpts slog.HandlerOptions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PrettyHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    slog.Handler</span><br><span class="line">    l *log.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *PrettyHandler)</span></span> Handle(ctx context.Context, r slog.Record) <span class="type">error</span> &#123;</span><br><span class="line">    level := r.Level.String() + <span class="string">&quot;:&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> r.Level &#123;</span><br><span class="line">    <span class="keyword">case</span> slog.LevelDebug:</span><br><span class="line">        level = color.MagentaString(level)</span><br><span class="line">    <span class="keyword">case</span> slog.LevelInfo:</span><br><span class="line">        level = color.BlueString(level)</span><br><span class="line">    <span class="keyword">case</span> slog.LevelWarn:</span><br><span class="line">        level = color.YellowString(level)</span><br><span class="line">    <span class="keyword">case</span> slog.LevelError:</span><br><span class="line">        level = color.RedString(level)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fields := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, r.NumAttrs())</span><br><span class="line">    r.Attrs(<span class="function"><span class="keyword">func</span><span class="params">(a slog.Attr)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        fields[a.Key] = a.Value.Any()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    b, err := json.MarshalIndent(fields, <span class="string">&quot;&quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeStr := r.Time.Format(<span class="string">&quot;[15:05:05.000]&quot;</span>)</span><br><span class="line">    msg := color.CyanString(r.Message)</span><br><span class="line"></span><br><span class="line">    h.l.Println(timeStr, level, msg, color.WhiteString(<span class="type">string</span>(b)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPrettyHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    out io.Writer,</span></span></span><br><span class="line"><span class="params"><span class="function">    opts PrettyHandlerOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> *PrettyHandler &#123;</span><br><span class="line">    h := &amp;PrettyHandler&#123;</span><br><span class="line">        Handler: slog.NewJSONHandler(out, &amp;opts.SlogOpts),</span><br><span class="line">        l:       log.New(out, <span class="string">&quot;&quot;</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你在代码中像这样使用 <code>PrettyHandler</code> 时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    opts := PrettyHandlerOptions&#123;</span><br><span class="line">        SlogOpts: slog.HandlerOptions&#123;</span><br><span class="line">            Level: slog.LevelDebug,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    handler := NewPrettyHandler(os.Stdout, opts)</span><br><span class="line">    logger := slog.New(handler)</span><br><span class="line">    logger.Debug(</span><br><span class="line">        <span class="string">&quot;executing database query&quot;</span>,</span><br><span class="line">        slog.String(<span class="string">&quot;query&quot;</span>, <span class="string">&quot;SELECT * FROM users&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    logger.Info(<span class="string">&quot;image upload successful&quot;</span>, slog.String(<span class="string">&quot;image_id&quot;</span>, <span class="string">&quot;39ud88&quot;</span>))</span><br><span class="line">    logger.Warn(</span><br><span class="line">        <span class="string">&quot;storage is 90% full&quot;</span>,</span><br><span class="line">        slog.String(<span class="string">&quot;available_space&quot;</span>, <span class="string">&quot;900.1 MB&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    logger.Error(</span><br><span class="line">        <span class="string">&quot;An error occurred while processing the request&quot;</span>,</span><br><span class="line">        slog.String(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;https://example.com&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当您执行该程序时，您将观察到以下着色的输出：</p>
<p><img src="/images/go/logging/slog_1.png" /></p>
<h2 id="使用-slog-的上下文包">使用 Slog 的上下文包</h2>
<p>到目前为止，我们主要使用了级别方法的标准变体，比如
<code>Info()</code>，<code>Debug()</code> 等，但 Slog 还提供了接受
<code>context.Context</code>
值作为其第一个参数的上下文感知变体。以下是每个方法的签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx context.Context, msg <span class="type">string</span>, args ...any)</span></span></span><br></pre></td></tr></table></figure>
<p>通过这种方法，您可以通过将上下文属性存储在 <code>Context</code>
中，在函数之间传播它们，这样当找到这些值时，它们会被添加到任何生成的记录中。</p>
<p>请考虑以下程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log/slog&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logger := slog.New(slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">    ctx := context.WithValue(context.Background(), <span class="string">&quot;request_id&quot;</span>, <span class="string">&quot;req-123&quot;</span>)</span><br><span class="line"></span><br><span class="line">    logger.InfoContext(ctx, <span class="string">&quot;image uploaded&quot;</span>, slog.String(<span class="string">&quot;image_id&quot;</span>, <span class="string">&quot;img-998&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>request_id</code> 添加到 <code>ctx</code> 变量，并传递给
<code>InfoContext</code> 方法。然而，当程序运行时，
<code>request_id</code> 字段不会出现在日志中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;: &quot;2024-01-02T11:04:28.590527494+01:00&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="line">  &quot;msg&quot;: &quot;image uploaded&quot;,</span><br><span class="line">  &quot;image_id&quot;: &quot;img-998&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使其正常工作，您需要创建一个自定义处理程序，并按照下面所示重新实现
<code>Handle</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ctxKey <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    slogFields ctxKey = <span class="string">&quot;slog_fields&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ContextHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    slog.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加上下文属性到 Record 中，然后调用底层的 handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h ContextHandler)</span></span> Handle(ctx context.Context, r slog.Record) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> attrs, ok := ctx.Value(slogFields).([]slog.Attr); ok &#123;</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> attrs &#123;</span><br><span class="line">            r.AddAttrs(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h.Handler.Handle(ctx, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AppendCtx 将 slog 属性添加到提供的上下文中，</span></span><br><span class="line"><span class="comment">// 以便在使用此类上下文创建的任何 Record 中都会包含该属性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AppendCtx</span><span class="params">(parent context.Context, attr slog.Attr)</span></span> context.Context &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        parent = context.Background()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v, ok := parent.Value(slogFields).([]slog.Attr); ok &#123;</span><br><span class="line">        v = <span class="built_in">append</span>(v, attr)</span><br><span class="line">        <span class="keyword">return</span> context.WithValue(parent, slogFields, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v := []slog.Attr&#123;&#125;</span><br><span class="line">    v = <span class="built_in">append</span>(v, attr)</span><br><span class="line">    <span class="keyword">return</span> context.WithValue(parent, slogFields, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该 <code>ContextHandler</code> 结构嵌入了 <code>slog.Handler</code>
接口，并实现了 <code>Handle</code> 方法，以提取存储在提供的上下文中的
<code>Slog</code> 属性。如果找到，它们将被添加到 <code>Record</code>
中，然后调用底层的 <code>Handler</code> 来格式化和输出记录。</p>
<p>另一方面， <code>AppendCtx</code> 函数使用 <code>slogFields</code>
键向 <code>context.Context</code> 添加 <code>Slog</code> 属性，以便
<code>ContextHandler</code> 可访问。</p>
<p>这是如何同时使用它们的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h := &amp;ContextHandler&#123;slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>)&#125;</span><br><span class="line"></span><br><span class="line">    logger := slog.New(h)</span><br><span class="line"></span><br><span class="line">    ctx := AppendCtx(context.Background(), slog.String(<span class="string">&quot;request_id&quot;</span>, <span class="string">&quot;req-123&quot;</span>))</span><br><span class="line"></span><br><span class="line">    logger.InfoContext(ctx, <span class="string">&quot;image uploaded&quot;</span>, slog.String(<span class="string">&quot;image_id&quot;</span>, <span class="string">&quot;img-998&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您现在将会观察到，<code>request_id</code> 将包含在使用
<code>ctx</code> 参数创建的任何记录中：</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;: &quot;2024-01-02T11:29:15.229984723+01:00&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="line">  &quot;msg&quot;: &quot;image uploaded&quot;,</span><br><span class="line">  &quot;image_id&quot;: &quot;img-998&quot;,</span><br><span class="line">  &quot;request_id&quot;: &quot;req-123&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-slog-进行错误日志记录">使用 Slog 进行错误日志记录</h2>
<p>在记录错误时，大多数框架都没有为 <code>error</code>
类型提供辅助程序，因此您必须像这样使用 <code>slog.Any()</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;something happened&quot;</span>)</span><br><span class="line"></span><br><span class="line">logger.ErrorContext(ctx, <span class="string">&quot;upload failed&quot;</span>, slog.Any(<span class="string">&quot;error&quot;</span>, err))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;: &quot;2024-01-02T14:13:44.41886393+01:00&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;ERROR&quot;,</span><br><span class="line">  &quot;msg&quot;: &quot;upload failed&quot;,</span><br><span class="line">  &quot;error&quot;: &quot;something happened&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要获取和记录错误堆栈跟踪，您可以使用类似 <code>xerrors</code>
的库来创建带有堆栈跟踪的错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err := xerrors.New(<span class="string">&quot;something happened&quot;</span>)</span><br><span class="line"></span><br><span class="line">logger.ErrorContext(ctx, <span class="string">&quot;upload failed&quot;</span>, slog.Any(<span class="string">&quot;error&quot;</span>, err))</span><br></pre></td></tr></table></figure>
<p>在你能够观察错误日志中的堆栈跟踪之前，你还需要提取、格式化并通过之前演示的
<code>ReplaceAttr()</code> 函数将其添加到相应的 <code>Record</code>
中。</p>
<p>这是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log/slog&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/mdobak/go-xerrors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stackFrame <span class="keyword">struct</span> &#123;</span><br><span class="line">    Func   <span class="type">string</span> <span class="string">`json:&quot;func&quot;`</span></span><br><span class="line">    Source <span class="type">string</span> <span class="string">`json:&quot;source&quot;`</span></span><br><span class="line">    Line   <span class="type">int</span>    <span class="string">`json:&quot;line&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceAttr</span><span class="params">(_ []<span class="type">string</span>, a slog.Attr)</span></span> slog.Attr &#123;</span><br><span class="line">    <span class="keyword">switch</span> a.Value.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> slog.KindAny:</span><br><span class="line">        <span class="keyword">switch</span> v := a.Value.Any().(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">error</span>:</span><br><span class="line">            a.Value = fmtErr(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// marshalStack 从错误中提取堆栈帧</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">marshalStack</span><span class="params">(err <span class="type">error</span>)</span></span> []stackFrame &#123;</span><br><span class="line">    trace := xerrors.StackTrace(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(trace) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frames := trace.Frames()</span><br><span class="line"></span><br><span class="line">    s := <span class="built_in">make</span>([]stackFrame, <span class="built_in">len</span>(frames))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> frames &#123;</span><br><span class="line">        f := stackFrame&#123;</span><br><span class="line">            Source: filepath.Join(</span><br><span class="line">                filepath.Base(filepath.Dir(v.File)),</span><br><span class="line">                filepath.Base(v.File),</span><br><span class="line">            ),</span><br><span class="line">            Func: filepath.Base(v.Function),</span><br><span class="line">            Line: v.Line,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s[i] = f</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmtErr 返回一个 slog.Value，其中包含键 `msg` 和 `trace`。如果错误没有实现</span></span><br><span class="line"><span class="comment">// interface &#123; StackTrace() errors.StackTrace &#125;，则省略 `trace` 键。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fmtErr</span><span class="params">(err <span class="type">error</span>)</span></span> slog.Value &#123;</span><br><span class="line">    <span class="keyword">var</span> groupValues []slog.Attr</span><br><span class="line"></span><br><span class="line">    groupValues = <span class="built_in">append</span>(groupValues, slog.String(<span class="string">&quot;msg&quot;</span>, err.Error()))</span><br><span class="line"></span><br><span class="line">    frames := marshalStack(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> frames != <span class="literal">nil</span> &#123;</span><br><span class="line">        groupValues = <span class="built_in">append</span>(groupValues,</span><br><span class="line">            slog.Any(<span class="string">&quot;trace&quot;</span>, frames),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slog.GroupValue(groupValues...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions&#123;</span><br><span class="line">        ReplaceAttr: replaceAttr,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    logger := slog.New(h)</span><br><span class="line"></span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    err := xerrors.New(<span class="string">&quot;something happened&quot;</span>)</span><br><span class="line"></span><br><span class="line">    logger.ErrorContext(ctx, <span class="string">&quot;image uploaded&quot;</span>, slog.Any(<span class="string">&quot;error&quot;</span>, err))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个设置，使用 <code>xerrors.New()</code>
创建的任何错误都将被记录为格式良好的堆栈跟踪，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;: &quot;2024-01-03T07:09:31.013954119+01:00&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;ERROR&quot;,</span><br><span class="line">  &quot;msg&quot;: &quot;image uploaded&quot;,</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;something happened&quot;,</span><br><span class="line">    &quot;trace&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;func&quot;: &quot;main.main&quot;,</span><br><span class="line">        &quot;source&quot;: &quot;slog/main.go&quot;,</span><br><span class="line">        &quot;line&quot;: 82</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;func&quot;: &quot;runtime.main&quot;,</span><br><span class="line">        &quot;source&quot;: &quot;runtime/proc.go&quot;,</span><br><span class="line">        &quot;line&quot;: 267</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;func&quot;: &quot;runtime.goexit&quot;,</span><br><span class="line">        &quot;source&quot;: &quot;runtime/asm_amd64.s&quot;,</span><br><span class="line">        &quot;line&quot;: 1650</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在您可以轻松追踪导致应用程序中任何意外错误的执行路径。</p>
<h2 id="使用-logvaluer-接口隐藏敏感字段">使用 LogValuer
接口隐藏敏感字段</h2>
<p>该接口允许您通过指定自定义类型的日志记录方式来标准化日志输出。以下是其签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogValuer <span class="keyword">interface</span> &#123;</span><br><span class="line">    LogValue() Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现此接口的主要用例是隐藏自定义类型中的敏感字段。例如，这是一个未实现该接口的类型。注意当实例被记录时，敏感细节是如何暴露的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User 没有实现 `LogValuer` 接口</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">string</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">    FirstName <span class="type">string</span> <span class="string">`json:&quot;first_name&quot;`</span></span><br><span class="line">    LastName  <span class="type">string</span> <span class="string">`json:&quot;last_name&quot;`</span></span><br><span class="line">    Email     <span class="type">string</span> <span class="string">`json:&quot;email&quot;`</span></span><br><span class="line">    Password  <span class="type">string</span> <span class="string">`json:&quot;password&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handler := slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>)</span><br><span class="line">    logger := slog.New(handler)</span><br><span class="line"></span><br><span class="line">    u := &amp;User&#123;</span><br><span class="line">        ID:        <span class="string">&quot;user-12234&quot;</span>,</span><br><span class="line">        FirstName: <span class="string">&quot;Jan&quot;</span>,</span><br><span class="line">        LastName:  <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">        Email:     <span class="string">&quot;jan@example.com&quot;</span>,</span><br><span class="line">        Password:  <span class="string">&quot;pass-12334&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.Info(<span class="string">&quot;info&quot;</span>, <span class="string">&quot;user&quot;</span>, u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;: &quot;2023-02-26T22:11:30.080656774+01:00&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="line">  &quot;msg&quot;: &quot;info&quot;,</span><br><span class="line">  &quot;user&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;user-12234&quot;,</span><br><span class="line">    &quot;first_name&quot;: &quot;Jan&quot;,</span><br><span class="line">    &quot;last_name&quot;: &quot;Doe&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;jan@example.com&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;pass-12334&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是有问题的，因为该类型包含不应出现在日志中的秘密字段（如电子邮件和密码），还会使您的日志变得不必要地冗长。</p>
<p>您可以通过指定日志中要表示的类型来解决此问题。例如，您可以指定仅将
<code>ID</code> 字段记录如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User 实现 LogValuer 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> LogValue() slog.Value &#123;</span><br><span class="line">    <span class="keyword">return</span> slog.StringValue(u.ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您现在将观察到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;: &quot;2023-02-26T22:43:28.184363059+01:00&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="line">  &quot;msg&quot;: &quot;info&quot;,</span><br><span class="line">  &quot;user&quot;: &quot;user-12234&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您也可以像这样对多个属性进行分组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> LogValue() slog.Value &#123;</span><br><span class="line">    <span class="keyword">return</span> slog.GroupValue(</span><br><span class="line">        slog.String(<span class="string">&quot;id&quot;</span>, u.ID),</span><br><span class="line">        slog.String(<span class="string">&quot;name&quot;</span>, u.FirstName+<span class="string">&quot; &quot;</span>+u.LastName),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot;: &quot;2023-03-15T14:44:24.223381036+01:00&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="line">  &quot;msg&quot;: &quot;info&quot;,</span><br><span class="line">  &quot;user&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;user-12234&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;Jan Doe&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-slog-与第三方日志后端">使用 Slog 与第三方日志后端</h2>
<p><code>Slog</code> 的主要设计目标之一是为 Go
应用程序提供统一的日志前端（<code>slog.Logger</code>），而后端（<code>slog.Handler</code>）可以根据程序的不同进行定制。</p>
<p>这样一来，即使后端不同，日志记录 API
在所有依赖项中保持一致。这也避免了将日志记录实现与特定包耦合，因为在项目中要求更改时，可以轻松切换到不同的后端。</p>
<p>这是一个使用 <code>Slog</code> 前端和 <code>Zap</code>
后端的示例，可能会提供两全其美的效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get go.uber.org/zap</span><br><span class="line">go get go.uber.org/zap/exp/zapslog</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log/slog&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line">    <span class="string">&quot;go.uber.org/zap/exp/zapslog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    zapL := zap.Must(zap.NewProduction())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> zapL.Sync()</span><br><span class="line"></span><br><span class="line">    logger := slog.New(zapslog.NewHandler(zapL.Core(), <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">    logger.Info(</span><br><span class="line">        <span class="string">&quot;incoming request&quot;</span>,</span><br><span class="line">        slog.String(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;GET&quot;</span>),</span><br><span class="line">        slog.String(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;/api/user&quot;</span>),</span><br><span class="line">        slog.Int(<span class="string">&quot;status&quot;</span>, <span class="number">200</span>),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个新的 <code>Zap</code> 生产日志记录器，随后被用作
<code>Slog</code> 包的处理程序。有了这个，你只需要使用
<code>slog.Logger</code>
上提供的方法来编写日志，但生成的记录将根据提供的 <code>zapL</code>
配置进行处理。</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1697453912.4535635,&quot;msg&quot;:&quot;incoming request&quot;,&quot;method&quot;:&quot;GET&quot;,&quot;path&quot;:&quot;/api/user&quot;,&quot;status&quot;:200&#125;</span><br></pre></td></tr></table></figure>
<p>切换到不同的日志记录非常简单，因为日志记录是根据
<code>slog.Logger</code> 完成的。例如，您可以像这样从 <code>Zap</code>
切换到 <code>Zerolog</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/rs/zerolog</span><br><span class="line">go get github.com/samber/slog-zerolog</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log/slog&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/rs/zerolog&quot;</span></span><br><span class="line">    slogzerolog <span class="string">&quot;github.com/samber/slog-zerolog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    zerologL := zerolog.New(os.Stdout).Level(zerolog.InfoLevel)</span><br><span class="line"></span><br><span class="line">    logger := slog.New(</span><br><span class="line">        slogzerolog.Option&#123;Logger: &amp;zerologL&#125;.NewZerologHandler(),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    logger.Info(</span><br><span class="line">        <span class="string">&quot;incoming request&quot;</span>,</span><br><span class="line">        slog.String(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;GET&quot;</span>),</span><br><span class="line">        slog.String(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;/api/user&quot;</span>),</span><br><span class="line">        slog.Int(<span class="string">&quot;status&quot;</span>, <span class="number">200</span>),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;time&quot;:&quot;2023-10-16T13:22:33+02:00&quot;,&quot;method&quot;:&quot;GET&quot;,&quot;path&quot;:&quot;/api/user&quot;,&quot;status&quot;:200,&quot;message&quot;:&quot;incoming request&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码片段中，<code>Zap</code> 处理程序已被自定义的
<code>Zerolog</code> 处理程序替换。由于日志记录不是使用任何库的自定义
API 进行的，迁移过程只需要几分钟，而不是在整个应用程序中切换一个日志记录
API 到另一个的情况。</p>
<h2 id="编写和存储-go-日志的最佳实践">编写和存储 Go 日志的最佳实践</h2>
<p>一旦您配置了 <code>Slog</code> 或您偏爱的第三方 Go
日志框架，就有必要采用以下最佳实践，以确保您充分利用应用程序日志：</p>
<h3 id="标准化您的日志接口">1. 标准化您的日志接口</h3>
<p>实现 <code>LogValuer</code>
接口可以使您标准化应用程序中各种类型的日志记录，确保它们在日志中的表示在整个应用程序中保持一致。这也是一种有效的策略，可以确保敏感字段不会出现在应用程序日志中，正如我们在本文中之前所探讨的那样。</p>
<h3 id="在错误日志中添加堆栈跟踪">2. 在错误日志中添加堆栈跟踪</h3>
<p>为了提高您在生产环境中调试意外问题的能力，您应该在错误日志中添加堆栈跟踪。这样，就能更容易地确定错误在代码库中的起源位置以及导致问题的程序流程。</p>
<p><code>Slog</code>
目前没有内置的方法来向错误添加堆栈跟踪，但正如我们之前所演示的，可以使用
<code>pkgerrors</code> 或 <code>go-xerrors</code>
等包以及一些辅助函数来实现这个功能。</p>
<h3 id="对您的-slog-语句进行检查以确保一致性">3. 对您的 Slog
语句进行检查，以确保一致性</h3>
<p><code>Slog</code> API
的主要缺点之一是它允许两种不同类型的参数，这可能导致代码库中的不一致性。除此之外，您还希望强制执行一致的键名约定（<code>snake_case</code>、<code>camelCase</code>
等），或者确定日志调用是否应始终包括上下文参数。</p>
<p>像 <code>sloglint</code> 这样的 <code>linter</code>
可以帮助您根据您喜欢的代码风格强制执行 <code>Slog</code>
的各种规则。以下是在通过 <code>golangci-lint</code>
使用时的示例配置：</p>
<p><code>.golangci.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">linters-settings:</span></span><br><span class="line">  <span class="attr">sloglint:</span></span><br><span class="line">    <span class="comment"># Enforce not mixing key-value pairs and attributes.</span></span><br><span class="line">    <span class="comment"># Default: true</span></span><br><span class="line">    <span class="attr">no-mixed-args:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Enforce using key-value pairs only (overrides no-mixed-args, incompatible with attr-only).</span></span><br><span class="line">    <span class="comment"># Default: false</span></span><br><span class="line">    <span class="attr">kv-only:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Enforce using attributes only (overrides no-mixed-args, incompatible with kv-only).</span></span><br><span class="line">    <span class="comment"># Default: false</span></span><br><span class="line">    <span class="attr">attr-only:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Enforce using methods that accept a context.</span></span><br><span class="line">    <span class="comment"># Default: false</span></span><br><span class="line">    <span class="attr">context-only:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Enforce using static values for log messages.</span></span><br><span class="line">    <span class="comment"># Default: false</span></span><br><span class="line">    <span class="attr">static-msg:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Enforce using constants instead of raw keys.</span></span><br><span class="line">    <span class="comment"># Default: false</span></span><br><span class="line">    <span class="attr">no-raw-keys:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Enforce a single key naming convention.</span></span><br><span class="line">    <span class="comment"># Values: snake, kebab, camel, pascal</span></span><br><span class="line">    <span class="comment"># Default: &quot;&quot;</span></span><br><span class="line">    <span class="attr">key-naming-case:</span> <span class="string">snake</span></span><br><span class="line">    <span class="comment"># Enforce putting arguments on separate lines.</span></span><br><span class="line">    <span class="comment"># Default: false</span></span><br><span class="line">    <span class="attr">args-on-sep-lines:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="集中管理日志但首先将它们持久化到本地文件">4.
集中管理日志，但首先将它们持久化到本地文件</h3>
<p>通常最好将编写日志的任务与将其发送到集中式日志管理系统分离。首先将日志写入本地文件可确保在日志管理系统或网络出现问题时备份，防止关键数据的潜在丢失。比如存储到本地，然后通过阿里云的日志客户端上传到阿里云、又或者通过
<code>Logstash</code> 上传到 <code>Elasticsearch</code>。</p>
<p>此外，在发送日志之前将其存储在本地有助于缓冲日志，从而实现批量传输，有助于优化网络带宽使用，并最大程度减少对应用程序性能的影响。</p>
<p>本地日志存储还提供了更大的灵活性，因此，如果需要转换到不同的日志管理系统，只需要在传输方法中进行修改，而不是整个应用程序日志记录机制。</p>
<h3 id="采样你的日志">5. 采样你的日志</h3>
<p>日志抽样是仅记录日志条目的代表性子集的做法，而不是每个日志事件都记录。这种技术在高流量环境中非常有益，因为系统会产生大量的日志数据，处理每个条目可能会非常昂贵，因为集中式日志记录解决方案通常根据数据流入速度或存储数据量收费。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log/slog&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    slogmulti <span class="string">&quot;github.com/samber/slog-multi&quot;</span></span><br><span class="line">    slogsampling <span class="string">&quot;github.com/samber/slog-sampling&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Will print 20% of entries.</span></span><br><span class="line">    option := slogsampling.UniformSamplingOption&#123;</span><br><span class="line">        Rate: <span class="number">0.2</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger := slog.New(</span><br><span class="line">        slogmulti.</span><br><span class="line">            Pipe(option.NewMiddleware()).</span><br><span class="line">            Handler(slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>)),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        logger.Info(fmt.Sprintf(<span class="string">&quot;a message from the gods: %d&quot;</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2023-10-18T19:14:09.820090798+02:00&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;msg&quot;:&quot;a message from the gods: 4&quot;&#125;</span><br><span class="line">&#123;&quot;time&quot;:&quot;2023-10-18T19:14:09.820117844+02:00&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;msg&quot;:&quot;a message from the gods: 5&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用日志管理服务">6. 使用日志管理服务</h3>
<p>将日志集中在日志管理系统中，可以轻松搜索、分析和监控应用程序在多个服务器和环境中的行为。所有日志都集中在一个地方，您可以更快速地识别和诊断问题，不再需要在不同服务器之间跳转以收集有关您的服务的信息。</p>
<p>目前我们使用的是阿里云的日志，但是它的前端性能很差，所以用起来体验较差，优点是部署简单，功能较全。你也可以使用
ElasticSearch 和 <code>Kiabana</code>
来搭建自己的日志系统，但是这个需要自己搭建，成本较高。</p>
<h2 id="总结">总结</h2>
<p>在本文中，我们探讨了 Go 语言中日志记录的最佳实践，以及如何使用
<code>Slog</code> 包来实现它们。我们还讨论了如何使用 <code>Slog</code>
与第三方日志后端，以及如何使用 <code>LogValuer</code>
接口标准化日志输出。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/70/">70</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">eleven26</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eleven26" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
