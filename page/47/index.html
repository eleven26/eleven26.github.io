<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eleven26.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="eleven26">
<meta property="og:url" content="https://eleven26.github.io/page/47/index.html">
<meta property="og:site_name" content="eleven26">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="eleven26">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="PHP">
<meta property="article:tag" content="Laravel">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://eleven26.github.io/page/47/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/47/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>eleven26</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">eleven26</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">100</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">346</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eleven26</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eleven26" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eleven26" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2020/02/24/git/mac%20%E4%B8%8B%E6%96%B0%E7%89%88%20GitKraken%20%E4%B8%8D%E8%83%BD%E6%89%93%E5%BC%80%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/24/git/mac%20%E4%B8%8B%E6%96%B0%E7%89%88%20GitKraken%20%E4%B8%8D%E8%83%BD%E6%89%93%E5%BC%80%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">mac 下新版 GitKraken 不能打开私有仓库解决方案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-02-24 15:06:00" itemprop="dateCreated datePublished" datetime="2020-02-24T15:06:00+08:00">2020-02-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文只是说 mac 下的解决方案，其他系统可以依样画葫芦，毕竟用 electron
就是为了它的跨平台特性，各个平台代码基本上一样的。</p>
</blockquote>
<blockquote>
<p>觉得太长而且是 mac 的话，可以直接使用文末的脚本。</p>
</blockquote>
<p>mac 下的破解方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.githubusercontent.com/eleven26/blog/master/scripts/gitkraken.py | python</span><br></pre></td></tr></table></figure>
<p>今天打开 GitKraken 的时候突然发现，提示我
<code>The free version of GitKraken does not support opening private or self-hosted repositories.</code>。</p>
<p><code>GitKraken</code> 是一个用 <code>electron</code>
开发的客户端应用，正好之前用 <code>electron</code>
写过一点东西，去看看源码有没有什么解决方法。</p>
<p>源码位于：<code>/Applications/GitKraken.app/Contents/Resources</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /Applications/GitKraken.app/Contents/Resources</span><br></pre></td></tr></table></figure>
<p>我们会看到一个 <code>app.asar</code>
文件，这个其实就是应用的核心所在，我们可以看作类似与 zip
之类的东西，它把所有源码打包到了一个文件中，我们解压开来看看源码：</p>
<blockquote>
<p>想了解 asar 是什么的可以看 <a
target="_blank" rel="noopener" href="https://www.electronjs.org/docs/tutorial/application-packaging">https://www.electronjs.org/docs/tutorial/application-packaging</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Applications/GitKraken.app/Contents/Resources</span><br><span class="line">asar e app.asar unpacked  # 解压 app.asar 到 unpacked 文件夹中</span><br></pre></td></tr></table></figure>
<p>asar 需要通过 npm 安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g asar</span><br></pre></td></tr></table></figure>
<p>我们可以直接用 WebStorm 之类的 IDE 打开这个文件夹，我们可以看到一个
<code>initializeGlobals.js</code>
文件，在里面发现一行对于开发人员来说比较敏感的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.env.NODE_ENV = loadSettings.mode === &#x27;development&#x27; ? &#x27;development&#x27; : &#x27;production&#x27;;</span><br></pre></td></tr></table></figure>
<p>一般开发中，我们常常定义 env
环境变量，然后在开发环境我们通常会少一些限制，想到此，可能修改为
<code>development</code>
模式会可以解决现在遇到的问题，然后找到定义的地方，在另外一个文件中：</p>
<p>clientType.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#x27;production&#x27;;</span><br></pre></td></tr></table></figure>
<p>我们把这一行修改为 <code>module.exports = 'development';</code>
看看。</p>
<p>修改完之后，重新打包。</p>
<ol type="1">
<li>先把旧的文件备份：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /Applications/GitKraken.app/Contents/Resources/app.asar /Applications/GitKraken.app/Contents/Resources/app.asar.bak</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>打包之后，我们就可以将修改后的代码重新打包</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Applications/GitKraken.app/Contents/Resources</span><br><span class="line">rm app.asar &amp;&amp; asar pack unpacked app.asar</span><br></pre></td></tr></table></figure>
<p>这里的 <code>unpacked</code> 就是刚刚上面解压出来的文件夹。</p>
<ol start="3" type="1">
<li>重启 <code>GitKraken</code></li>
</ol>
<p>重启之后，弹窗没有了，各项功能正常使用。应该没什么问题了，就先用着了。</p>
<h2 id="py脚本">py脚本</h2>
<p>觉得上面太长不想看的可以执行下面的脚本：</p>
<p>保存为 <code>gitkraken.py</code>，然后运行
<code>chmod +x gitkraken.py &amp;&amp; ./gitkraken.py</code>
即可破解。</p>
<p>下面的代码 Gitkraken 7.4.0 可用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">d = &#x27;/Applications/GitKraken.app/Contents/Resources&#x27;</span><br><span class="line">if not os.path.isdir(d):</span><br><span class="line">    print(&quot;GitKraken 尚未安装&quot;)</span><br><span class="line">    exit(-1)</span><br><span class="line"></span><br><span class="line">print(&quot;切换目录到 %s...&quot; % d)</span><br><span class="line">os.chdir(d)</span><br><span class="line">if os.path.isdir(d + &quot;/unpacked&quot;):</span><br><span class="line">    os.system(&quot;rm -rf &quot; + d + &quot;/unpacked&quot;)</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">print(&quot;解压 app.asar...&quot;)</span><br><span class="line">os.system(&quot;cp app.asar app.asar.bak&quot;)</span><br><span class="line">os.system(&quot;asar e app.asar unpacked&quot;)</span><br><span class="line"></span><br><span class="line"># 替换文件</span><br><span class="line">print(&quot;替换文件...&quot;)</span><br><span class="line">f = open(d + &quot;/unpacked/src/main/clientType.js&quot;, mode=&#x27;wb&#x27;)</span><br><span class="line">content = &quot;&quot;&quot;// This file is auto-generated by the set-client-type.js script</span><br><span class="line">module.exports = &#x27;development&#x27;;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">f.write(bytes(content))</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(d + &quot;/unpacked/src/main/static/clientType.js&quot;, mode=&#x27;wb&#x27;)</span><br><span class="line">content = &quot;&quot;&quot;// This file is auto-generated by the set-client-type.js script</span><br><span class="line">module.exports = &#x27;development&#x27;;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">f.write(bytes(content))</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(d + &quot;/unpacked/src/main/static/mode.js&quot;, mode=&#x27;wb&#x27;)</span><br><span class="line">content = &quot;&quot;&quot;// This file is auto-generated by the set-run-mode.js script</span><br><span class="line">module.exports = &#x27;development&#x27;;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">f.write(bytes(content))</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"># 重新打包</span><br><span class="line">print(&quot;重新打包...&quot;)</span><br><span class="line">os.system(&quot;rm app.asar &amp;&amp; asar pack unpacked app.asar&quot;)</span><br><span class="line"></span><br><span class="line"># 清理操作</span><br><span class="line">os.system(&quot;rm -rf unpacked&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;破解成功!&quot;)</span><br><span class="line"></span><br><span class="line"># 打开 Gitkraken</span><br><span class="line">script = &quot;&quot;&quot;tell application &quot;GitKraken&quot;</span><br><span class="line">    activate</span><br><span class="line">    # set frontmost to true</span><br><span class="line"></span><br><span class="line">    try</span><br><span class="line">        set miniaturized of windows to false -- most apps</span><br><span class="line">    end try</span><br><span class="line">end tell&quot;&quot;&quot;</span><br><span class="line">os.system(&quot;osascript -e &#x27;%s&#x27;&quot; % script)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考链接：</p>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://www.electronjs.org/docs/tutorial/application-packaging">application-packaging</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2020/02/24/mongodb/laravel%20jenssegers%20mongodb%20%E9%81%8D%E5%8E%86%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%20collection%20%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/24/mongodb/laravel%20jenssegers%20mongodb%20%E9%81%8D%E5%8E%86%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%20collection%20%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">laravel jenssegers mongodb 遍历大数据量 collection 优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-02-24 15:06:00" itemprop="dateCreated datePublished" datetime="2020-02-24T15:06:00+08:00">2020-02-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="环境">环境:</h2>
<ul>
<li><p><code>Lumen 5.5.*</code></p></li>
<li><p><code>PHP 7.1.14</code></p></li>
<li><p><code>ext-mongodb 1.5.2</code></p></li>
</ul>
<h2 id="背景">背景</h2>
<p>线上 Mongo 的某个 Collection
数据量过大(400w+)，导致某些搜索操作很慢，所以考虑对其进行拆分，拆分之后可能平均每个
Collection 2w 左右数据。</p>
<p>所以写了一个脚本来遍历该
Collection，把拿到的数据根据其中一个字段拆分到不同的 Collection 中。</p>
<p>跑这个脚本的时候发现，开始的时候挺快的，然后跑着跑着就越来越慢了。</p>
<h2 id="代码">代码</h2>
<p>大致做法，每次获取 1000 条数据（避免占用过大内存），处理完这 1000
条数据之后，再获取 1000 条，直到处理完所有数据。</p>
<h3 id="第一版">第一版</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app(xx::class)</span><br><span class="line">    -&gt;withTrashed()</span><br><span class="line">    -&gt;chunk(1000, function($xxs) &#123;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>总运行时间（150w 数据）：&gt; 1h</strong></p>
<p>这个脚本对有 150w 数据的 Collection
的时候就遇到了严重的性能问题，跑到一半的时候，脚本报告跑完这个脚本可能总共要
1 个小时。</p>
<p>因此，在它跑的过程中，Google
了一下为什么这么慢，并且做了一些测试，发现 <code>jenssegers</code>
使用的方法是 <a
target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/aggregation/">aggregate</a>，另外发现
<code>jenssegers</code> 上有个 issue 质疑为什么用
<code>aggregate</code>（<a
target="_blank" rel="noopener" href="https://github.com/jenssegers/laravel-mongodb/issues/1056">Why use
aggregation to paginate?</a>）。有一位仁兄提到 "mongodb is used for
performance mainly, but using aggregate instead of find is killing the
purpose."。</p>
<p>显然，大家对此都不太满意。我也是。所以有了第二版。</p>
<h3 id="第二版">第二版</h3>
<p>这版写法来自上面提到的那个 issue（（<a
target="_blank" rel="noopener" href="https://github.com/jenssegers/laravel-mongodb/issues/1056">Why use
aggregation to paginate?</a>））。</p>
<p>既然这个人说
<code>db.&#123;dbname&#125;.find().sort(&#123;"_id":-1&#125;).skip(2).limit(2)</code>
这种写法更优，那必须得尝试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app(xx::class)</span><br><span class="line">    -&gt;withTrashed()</span><br><span class="line">    -&gt;skip($page * $pageSize)</span><br><span class="line">    -&gt;limit($pageSize)</span><br><span class="line">    -&gt;get();</span><br></pre></td></tr></table></figure>
<p><strong>总运行时间（150w 数据）：0.5h</strong></p>
<p>总的来说，快了很多很多，但是这种解决方法也还是存在同样的一个问题，就是越到后面就越慢。如果数据量更多的话，没有办法确保执行时间在可控范围之内。</p>
<h3 id="第三版">第三版</h3>
<p>我们知道，对于一些数据库，提供了游标这种东西，可能大部分人没有去用过。出现上面这种状况，我想大概是因为，分页的操作实际上是，一条条数据数过去，直到某一条数据吧。</p>
<p>为了证实这个想法，百度了一下 MySQL
版本的，大概底层实现其实就是一条条数过去的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM users ORDER BY id DESC LIMIT 10000, 20\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 10020  # 扫描了 10020 行</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>
<p><code>LIMIT 10000, 20</code> 意味着 MySQL 已经读取了 10020
条数据，并且丢弃了前 10000 行，然后返回接下来的 20 行。</p>
<p>参考链接: <a
target="_blank" rel="noopener" href="https://www.slideshare.net/Eweaver/efficient-pagination-using-mysql">Efficient
Pagination Using MySQL</a></p>
<blockquote>
<p>也就是说，我们遍历的时候越到后面的数据，每次获取就需要丢弃越来越多的数据，简单来说，越到后面，吃力不讨好的操作越来越多，所以也就越来越慢。</p>
</blockquote>
<ul>
<li><strong>有没有办法让它下次不再重新找？</strong></li>
</ul>
<p>所以我们在这种场景下需要解决的问题是，让 mongo
不要每次都从头找，你已经到这了，不用回头再来。想到这，想起了有
<code>cursor</code> 这个东西，就是游标。MySQL
里面也有，它可以在查询的过程中给你一个游标，然后再自己一条条地拿数据。</p>
<p>使用 <code>cursor</code> 版本的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 获取游标</span><br><span class="line">/** @var \MongoDB\Driver\Cursor $cursor */</span><br><span class="line">$cursor = DB::connection(&#x27;&lt;connection_name&gt;&#x27;)</span><br><span class="line">    -&gt;collection(&#x27;&lt;collection_name&gt;&#x27;)-&gt;raw(function ($collection) &#123;</span><br><span class="line">        return $collection-&gt;find();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">$count = 0;</span><br><span class="line">$data = [];</span><br><span class="line">/** @var \MongoDB\Model\BSONDocument $bsonDocument */</span><br><span class="line">foreach ($cursor as $bsonDocument) &#123;</span><br><span class="line">    $json = \MongoDB\BSON\toJSON(\MongoDB\BSON\fromPHP($bsonDocument));</span><br><span class="line">    $model = app(xx::class);</span><br><span class="line">    $attributes = json_decode($json, true);</span><br><span class="line"></span><br><span class="line">    foreach ($attributes as $attribute =&gt; $value) &#123;</span><br><span class="line">        $model-&gt;setAttribute($attribute, $bsonDocument[$attribute]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $data[] = $model;</span><br><span class="line">    $count++;</span><br><span class="line">    if ($count == 1000) &#123;</span><br><span class="line">        $this-&gt;insertDocuments($data);</span><br><span class="line">        $data = [];</span><br><span class="line">        $count = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($count &gt; 0) &#123;</span><br><span class="line">    $this-&gt;insertDocuments($data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作起来繁琐了很多，我们需要先获取
<code>cursor</code>，然后在循环中手动控制每次处理的量。</p>
<p><strong>总运行时间（150w 数据）：9min</strong></p>
<p>总的运行时间少了很多，而且不存在处理到后面的时候越来越慢，匀速处理，这个方案目前来看算是最优的了。</p>
<h2 id="总结">总结</h2>
<ul>
<li>使用 cursor 遍历大数据量 collection
的时候可以避免处理到后面的数据越来越慢。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2020/02/23/kubernetes/minikube%20%E5%88%9D%E4%BD%93%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/23/kubernetes/minikube%20%E5%88%9D%E4%BD%93%E9%AA%8C/" class="post-title-link" itemprop="url">Minikube 初体验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-02-23 09:45:00" itemprop="dateCreated datePublished" datetime="2020-02-23T09:45:00+08:00">2020-02-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="minikube-是什么">Minikube 是什么 ？</h2>
<p>minikube 相当于一个运行在本地的 Kubernetes 单节点，我们可以在里面创建
Pods 来创建对应的服务。</p>
<p>官网描述: Minikube is a tool that makes it easy to run Kubernetes
locally. Minikube runs a single-node Kubernetes cluster inside a Virtual
Machine (VM) on your laptop for users looking to try out Kubernetes or
develop with it day-to-day.</p>
<p>简单来说，就是给你本地开发、测试用的，它在虚拟机里面启用
Kubernetes，这个 Kubernetes 只有一个节点，就是虚拟机本身。</p>
<h2 id="国内使用的一些问题">国内使用的一些问题</h2>
<ol type="1">
<li>k8s.gcr.io 在 minikube 里面无法正常使用</li>
</ol>
<p>解决方法：</p>
<ul>
<li>使用阿里云的镜像启动 minikube</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --vm-driver=virtualbox --registry-mirror=https://registry.docker-cn.com --image-mirror-country=cn --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure>
<ul>
<li>创建服务的时候需要替换镜像地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment hello-minikube --image=k8s.gcr.io/echoserver:1.10 ## 无法使用</span><br></pre></td></tr></table></figure>
<p>这里的 <code>k8s.gcr.io</code> 需要替换成
<code>registry.aliyuncs.com/google_containers</code>，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment hello-minikube --image=registry.aliyuncs.com/google_containers/echoserver:1.10</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>拿到了 service 的 url，无法正常打开</li>
</ol>
<p>这就是因为 service 没有被成功创建，但是 minikube 在运行
<code>kubectl create deployment</code>
之类的命令的时候并没有明确的报错，我们可以使用
<code>minikube logs</code> 来查看错误日志。</p>
<p>解决了网络问题，其实基本上没什么问题了，访问
<code>minikube service hello-minikube --url</code> 得到的 url
可以正常打开了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Hostname: hello-minikube-6db89b59b4-dh6bh</span><br><span class="line"></span><br><span class="line">Pod Information:</span><br><span class="line">	-no pod information available-</span><br><span class="line"></span><br><span class="line">Server values:</span><br><span class="line">	server_version=nginx: 1.13.3 - lua: 10008</span><br><span class="line"></span><br><span class="line">Request Information:</span><br><span class="line">	client_address=172.17.0.1</span><br><span class="line">	method=GET</span><br><span class="line">	real path=/</span><br><span class="line">	query=</span><br><span class="line">	request_version=1.1</span><br><span class="line">	request_scheme=http</span><br><span class="line">	request_uri=http://192.168.99.100:8080/</span><br><span class="line"></span><br><span class="line">Request Headers:</span><br><span class="line">	accept=text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">	accept-encoding=gzip, deflate</span><br><span class="line">	accept-language=zh-CN,zh;q=0.9,zh-TW;q=0.8,en;q=0.7</span><br><span class="line">	connection=keep-alive</span><br><span class="line">	host=192.168.99.100:31663</span><br><span class="line">	upgrade-insecure-requests=1</span><br><span class="line">	user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36</span><br><span class="line"></span><br><span class="line">Request Body:</span><br><span class="line">	-no body in request-</span><br></pre></td></tr></table></figure>
<h2 id="参考链接">参考链接：</h2>
<ol type="1">
<li><p><a
target="_blank" rel="noopener" href="https://kubernetes.io/docs/setup/learning-environment/minikube/">Installing
Kubernetes with Minikube</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://www.inlighting.org/2020/install-minikube-in-china.html">Kubernetes
之 Minikube 国内安装</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/liyuanhong/p/10143157.html">minikube是什么</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/minikube/issues/5860">! VM
is unable to access k8s.gcr.io, you may need to configure a proxy or set
--image-repository</a></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2020/02/22/mac/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/22/mac/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">黑苹果安装的两个问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-02-22 20:12:02" itemprop="dateCreated datePublished" datetime="2020-02-22T20:12:02+08:00">2020-02-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>需要完全断开网络执行以下操作。</p>
<p>这大概是因为苹果禁止安装旧版本的系统，联网的时候如果安装旧版本的都会有下面的这些问题。</p>
<ol type="1">
<li>This copy of the Install macOS High Sierra application is damaged,
and can't be used to install macOS.</li>
</ol>
<p>解决方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date 051015512018</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>macOS could not be installed on your computer.</li>
</ol>
<p>The installer resources have expired.</p>
<p>Quit the installer to restart your computer and try again.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2020/02/16/tcp_ip/tcp%20ip%20%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/16/tcp_ip/tcp%20ip%20%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">TCP/IP 基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-02-16 20:47:30" itemprop="dateCreated datePublished" datetime="2020-02-16T20:47:30+08:00">2020-02-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="计算机网络体系结构分层">计算机网络体系结构分层</h2>
<ul>
<li>OSI 七层模型</li>
</ul>
<p>应用层</p>
<p>表示层</p>
<p>回话层</p>
<p>传输层</p>
<p>网络层</p>
<p>数据链路层</p>
<p>物理层</p>
<p>OSI 参考模型中定义了每一层的 "作用"，定义每一层作用的是
"协议"，"协议" 是约定，其具体内容为
"规范"，我们日常所使用的就是遵循各个协议具体 "规范"
的产品和通信手段。</p>
<ul>
<li>TCP/IP 概念层模型</li>
</ul>
<p>应用层</p>
<p>传输层</p>
<p>网络层</p>
<p>链路层</p>
<p>OSI 参考模型注重 "通信协议必要的功能是什么"，而 TCP/IP 则更强调
"在计算机上实现协议应该开发哪种程序"。</p>
<h2 id="tcpip-基础">TCP/IP 基础</h2>
<ol type="1">
<li>TCP/IP 的具体含义</li>
</ol>
<p>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP
两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用
IP 进行通信时必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或
UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP/IP
的关系紧密，是互联网必不可少的组成部分。TCP/IP
一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。</p>
<p>互联网进行通信时，需要相应的网络协议，TCP/IP
原本就是为使用互联网开发制定的协议族。因此，互联网的协议就是
TCP/IP，TCP/IP 就是互联网协议。</p>
<p>应用协议：HTTP、SMTP、FTP、TELNET、SNMP</p>
<p>传输协议：TCP、UDP</p>
<p>路由控制协议：RIP、OSPF、BGP</p>
<p>网际协议：IP、ICMP、ARP</p>
<ol start="2" type="1">
<li>数据包</li>
</ol>
<p>包、帧、数据包、段、消息</p>
<p>以上 5 个术语都用来表述数据的单位，大致区分如下：</p>
<ul>
<li><p>包可以说是全能性术语</p></li>
<li><p>帧用于表示数据链路层中包的单位</p></li>
<li><p>数据包是 IP 和 UDP 等网络层以上的分层包中的单位</p></li>
<li><p>段则表示 TCP 数据流中的信息</p></li>
<li><p>消息是指应用协议中数据的单位。</p></li>
</ul>
<p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。</p>
<ol start="3" type="1">
<li>数据处理流程</li>
</ol>
<p>下图以用户 a 向用户 b 发送邮件的例子：</p>
<figure>
<img src="/images/tcp_ip/1.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<ul>
<li>应用程序处理</li>
</ul>
<p>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；</p>
<p>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于
OSI 的会话层的功能。</p>
<ul>
<li>TCP 模块的处理</li>
</ul>
<p>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP
提供将应用层发来的数据顺利发送至对端的可靠传输。</p>
<p>为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</p>
<ul>
<li>IP 模块的处理</li>
</ul>
<p>IP 将 TCP 传过来的 TCP 首部和 TCP 数据结合起来当作自己的数据，并在
TCP 首部的前端加上自己的 IP 首部。</p>
<p>IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</p>
<ul>
<li>网络接口（以太网驱动）的处理</li>
</ul>
<p>从 IP 传过来的 IP
包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</p>
<ul>
<li>网络接口（以太网驱动）的处理</li>
</ul>
<p>主机接收到以太网包后，首先从以太网包首部找到 MAC
地址判断是否为发送给自己的包，若不是则丢弃数据。</p>
<p>如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如
IP、ARP 等。这里的例子则是 IP。</p>
<ul>
<li>IP 模块的处理</li>
</ul>
<p>IP 模块接收到数据后也做类似的处理。从包首部中判断此 IP
地址地址是否与自己的 IP
地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如
TCP、UDP。这里的例子则是 TCP。</p>
<p>另外，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</p>
<ul>
<li>TCP 模块的处理</li>
</ul>
<p>在 TCP
模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别地应用程序。</p>
<ul>
<li>应用程序的处理</li>
</ul>
<p>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p>
<h2 id="传输层中的-tcp-和-udp">传输层中的 TCP 和 UDP</h2>
<p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p>
<ul>
<li><p>TCP
是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP
发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP
为提供可靠性传输，实现 "顺序控制" 或 "重发控制" 机制。此外还具备
"流控制（流量控制）"、"拥塞控制"、提高网络利用率等众多功能。</p></li>
<li><p>UDP
是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP
的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p></li>
<li><p>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP
用于在传输层有必要实现可靠传输的情况；而在另一方面，UDP
主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP
应该根据应用的目的按需使用。</p></li>
</ul>
<ol type="1">
<li>端口号</li>
</ol>
<p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP
地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP
网络中互连的主机和路由器。在传输层也有类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被成为程序地址。</p>
<p>1.1 根据端口号识别应用</p>
<p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>
<figure>
<img src="/images/tcp_ip/2.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<p>1.2 通过 IP 地址、端口号、协议号进行通信识别</p>
<ul>
<li>仅凭目标端口号识别某一个通信是远远不够的</li>
</ul>
<figure>
<img src="/images/tcp_ip/3.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<figure>
<img src="/images/tcp_ip/4.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<p>① 和 ② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是
80。这里可以根据源端口号加以区分。</p>
<p>③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP
地址不同。</p>
<p>此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP
和 UDP）。</p>
<p>1.3 端口号的确定</p>
<ul>
<li><p>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如
HTTP、FTP、TELNET
等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被成为知名端口号，分布在
0～1023 之间；除知名端口号外，还有一些端口号被正式注册，它们分布在
1024～49151 之间，不过这些端口号可用于任何通信用途。</p></li>
<li><p>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口范围在
49152~65535 之间。</p></li>
</ul>
<p>1.4 端口号与协议</p>
<ul>
<li><p>端口号由其使用的传输层协议决定。因此，不同的传输层协议使用相同的端口号。</p></li>
<li><p>此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</p></li>
</ul>
<ol start="2" type="1">
<li>UDP</li>
</ol>
<ul>
<li><p>UDP 不提供复杂的控制机制，利用 IP
提供面向无连接的通信服务。</p></li>
<li><p>并且它是将应用程序发来的数据在接收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP
也无法进行流量控制等避免网络拥堵行为。</p></li>
<li><p>此外，传输途中出现丢包，UDP 也不负责重发。</p></li>
<li><p>甚至当包的到达顺序出现乱序时也没有纠正的功能。</p></li>
<li><p>如果需要以上的细节控制，不得不交由采用 UDP
的应用程序去处理。</p></li>
<li><p>UDP 常用于以下几个方面：1. 包总量较少的通信（DNS、SNMP等）；2.
视频、音频等多媒体通信（即时通信）；3. 限定于 LAN
等特定网络中的应用通信；4. 广播通信（广播、多播）</p></li>
</ul>
<ol start="3" type="1">
<li>TCP</li>
</ol>
<ul>
<li><p>TCP 与 UDP
的区别相当大。它充分地实现了数据传输时的各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在
UDP 中都没有。</p></li>
<li><p>此外，TCP
作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p></li>
<li><p>根据 TCP 的这些机制，在 IP
这种无连接的网络上也能够实现高可靠性的通信（主要通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</p></li>
</ul>
<p>3.1 三次握手（重点）</p>
<ul>
<li><p>TCP
提供面向有连接的通信控制。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。</p></li>
<li><p>所谓三次握手是指建立一个 TCP
连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在 socket
编程中，这一过程由客户端执行 connect 来触发。</p></li>
</ul>
<p>下面来看看三次握手的流程图：</p>
<figure>
<img src="/images/tcp_ip/5.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<ul>
<li><p>第一次握手：客户端将标志位 SYN 置为 1，随机产生一个值 seq =
J，并将该数据包发送给服务器端，客户端进入 SYN_SENT
状态，等待服务器端确认。</p></li>
<li><p>第二次握手：服务器端收到数据包后由标志位 SYN=1
知道客户端请求建立连接，服务器端将标志位 SYN 和 ACK 都置为
1，ack=J+1，随机产生一个值
seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RECVD
状态。</p></li>
<li><p>第三次握手：客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为
1，如果正确则将标志位 ACNK 置为
1，ack=K+1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 K+1，ACK
是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED
状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p></li>
</ul>
<p>3.2 四次挥手（重点）</p>
<ul>
<li><p>四次挥手即终止 TCP 连接，就是指断开一个 TCP
连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。在 socket
编程中，这一过程由客户端或服务端任一方执行 close 来触发。</p></li>
<li><p>由于 TCP
连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个
FIN 来终止这一方向的连接，收到一个 FIN
只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP
连接上仍然能够发送数据，直到这一方向也发送了
FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p></li>
</ul>
<p>下面来看看四次挥手的流程图：</p>
<figure>
<img src="/images/tcp_ip/6.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<ul>
<li><p>中断连接端可以是客户端，也可以是服务器端</p></li>
<li><p>第一次挥手：客户端发送一个
FIN=M，用来关闭客户端到服务端的数据传送，客户端进入 FIN_WAIT_1
状态。意思是说
"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</p></li>
<li><p>第二次挥手：服务器端收到 FIN 后，先发送
ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，
请继续你等我的消息。这个时候客户端就进入 FIN_WAIT_2
状态，继续等待服务器端的 FIN 报文。</p></li>
<li><p>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送 FIN=N
报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入
LAST_ACK 状态。</p></li>
<li><p>第四次挥手：客户端收到 FIN=N
报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送
ack=N+1 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK
则可以重传。服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL
后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次挥手。</p></li>
</ul>
<p>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况。</p>
<p>具体流程如下图：</p>
<figure>
<img src="/images/tcp_ip/7.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<p>3.3 通过序列号与确认应答提高可靠性</p>
<ul>
<li><p>在 TCP
中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。</p></li>
<li><p>在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够达到对端，实现可靠传输。</p></li>
<li><p>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</p></li>
<li><p>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</p></li>
<li><p>对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。</p></li>
<li><p>序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据
TCP
首部中的序列号和数据的长度，将自己下一步应该接收到的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP
能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</p></li>
</ul>
<figure>
<img src="/images/tcp_ip/8.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<p>3.4 重发超时的确定</p>
<ul>
<li><p>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证
"确认应答一定能在这个时间内返回"。</p></li>
<li><p>TCP
要求不论处在何种网络环境下都要提高通信性能，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间以及偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</p></li>
<li><p>在 BSD 的 Unix 以及 Windows 系统中，超时都以 0.5
秒为单位进行控制，因此重发超时都是 0.5
秒的整数倍。不过，最初其重发超时的默认值一般设置为 6 秒左右。</p></li>
<li><p>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以
2 倍、4 倍的指数函数延长。</p></li>
<li><p>此外，数据也不会被反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接，并且通知应用通信异常强行终止。</p></li>
</ul>
<p>3.5 以段为单位发送数据</p>
<ul>
<li><p>在建立 TCP
连接的同时，也可以确定发送数据包的单位，我们也可以称其为
"最大报文段长度"（MSS）。最理想的情况是，最大报文长度正好是 IP
中不会被分片处理的数据长度。</p></li>
<li><p>TCP 在传送大量数据时，是以 MSS
的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。</p></li>
<li><p>MSS
在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在
TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS
的大小。然后会在两者之间选择一个较小的值投入使用。</p></li>
</ul>
<p>3.6 利用窗口控制提高速度</p>
<ul>
<li><p>TCP 以 1
个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。</p></li>
<li><p>为了解决这个问题，TCP
引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待应答，而是继续发送。如下图所示：</p></li>
</ul>
<figure>
<img src="/images/tcp_ip/9.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<ul>
<li><p>窗口控制</p></li>
<li><p>窗口大小就是指无需等待确认应答可以继续发送数据的值。上图中窗口大小为
4
个段。这个机制实现了使用最大量的缓冲区，同时对多个段同时进行确认应答的功能。</p></li>
</ul>
<p>3.7 滑动窗口控制</p>
<figure>
<img src="/images/tcp_ip/10.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<ul>
<li><p>上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些被重传的数据，直到收到他们的确认应答。</p></li>
<li><p>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p></li>
<li><p>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的未知。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口机制。</p></li>
</ul>
<p>3.8 窗口控制中的重发控制</p>
<p>在使用窗口控制中，出现丢包一般分为两种情况：</p>
<ul>
<li>确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</li>
</ul>
<figure>
<img src="/images/tcp_ip/11.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<ul>
<li>某个报文段丢失的情况。接收主机如果收到一个自己应该收到的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一段报文丢失后，发送端会一直收到序号为
1001
的确认应答，因此，在窗口比较大，又出现报文丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续
3
次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发机制。</li>
</ul>
<figure>
<img src="/images/tcp_ip/12.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<h2 id="网络层中的-ip-协议">网络层中的 IP 协议</h2>
<ul>
<li><p>IP（IPv4、IPv6）相当于 OSI 参考模型中的第 3 层 --
网络层。网络层的主要作用是
"实现终端节点之间的通信"。这种终端节点之间的通信也叫
"点对点通信"。</p></li>
<li><p>网络的下一层 --
数据链路层的主要作用是在互连同一数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p></li>
<li><p>IP 大致分为三大作用模块，它们是
IP寻址、路由（最终节点为止的转发）以及 IP 分包与组包。</p></li>
</ul>
<ol type="1">
<li>IP 地址</li>
</ol>
<p>1.1 IP 地址概述</p>
<ul>
<li><p>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的
MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</p></li>
<li><p>作为网络层的 IP，也有这种地址信息，一般叫做 IP 地址。IP
地址用于在 "连接到网络中的所有主机中识别出进行通信的目标地址"。因此，在
TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</p></li>
<li><p>不论一台主机与哪种数据链路连接，其 IP
地址的形式都保持不变。</p></li>
<li><p>IP地址（IPv4 地址）由 32 位正整数来表示。IP
地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将
32 位的 IP 地址以每 8 位为一组，分为 4 组，每组以 "."
隔开，再将每组数转换成十进制数。如下：</p></li>
</ul>
<figure>
<img src="/images/tcp_ip/13.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<p>1.2 IP 地址由网络和主机两部分标识组成</p>
<ul>
<li>如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内的主机必须有相同的网络地址。IP
地址的
"主机标识"则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的
IP 地址都不会相互重叠。即 IP 地址具有了唯一性。</li>
</ul>
<figure>
<img src="/images/tcp_ip/14.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<ul>
<li>如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP
地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</li>
</ul>
<figure>
<img src="/images/tcp_ip/15.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<p>1.3 IP 地址的分类</p>
<ul>
<li><p>IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP
地址中从第 1 位到第 4
位的比特列对其网络标识和主机标识进行区分。</p></li>
<li><p>A 类 IP 地址是首位以 "0" 开头的地址。从第 1 位到第 8
位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A
类的网络地址。A 类地址的后 24
位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 16777214
个。</p></li>
<li><p>B 类 IP 地址是前两位 "10" 的地址。从第 1 位到第 16
位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B
类的网络地址。B 类地址的后 16
位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 65534
个。</p></li>
<li><p>C 类 IP 地址是前三位为 "110" 的地址。从第 1 位到第 24
位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C
类的网络地址。C 类地址的后 8
位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 254
个。</p></li>
<li><p>D 类 IP地址是前四位为 "1110" 的地址。从第 1 位到第 32
位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D
类的网络地址。D 类地址没有主机标识，常用于多播。</p></li>
<li><p>在分配 IP
地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为
0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或IP
地址不可以获知的情况下才使用。而全部为 1
的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么
C 类地址每个网段最多只能有 254 个主机地址的原因。</p></li>
</ul>
<p>1.4 广播地址</p>
<ul>
<li><p>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP
地址中的主机地址部分全部设置为 1，就成了广播地址。</p></li>
<li><p>广播分为本地广播和直接广播。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。</p></li>
</ul>
<p>1.5 IP 多播</p>
<ul>
<li><p>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP
地址，因此也不存在可靠传输。</p></li>
<li><p>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</p></li>
</ul>
<figure>
<img src="/images/tcp_ip/16.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<ul>
<li><p>IP 多播</p></li>
<li><p>多播使用 D 类地址。因此，如果从首位开始到第 4 位是
"1110"，就可以认为是多播地址。而剩下的 28
位可以成为多播的组编号。</p></li>
<li><p>此外，对于多播，所有的主机（路由器以外的主机和终端主机）必须属于
224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。</p></li>
</ul>
<p>1.6 子网掩码</p>
<ul>
<li><p>现在一个 IP
地址的网络标识和主机标识已不再受限于该类地址的类别，而是由一个叫做
"子网掩码" 的识别码通过子网网络地址细分出比 A类、B类、C类
更小粒度的网络。这种方式实际上就是将原来 A类、B类、C类
等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</p></li>
<li><p>子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP
地址网络标识部分全部为 "1"，对应 IP 地址主机标识的部分则全部为
"0"。由此，一个 IP
地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是
IP 地址的首位开始连续的 "1"。</p></li>
<li><p>对于子网掩码，目前有两种表示方式。第一种是，将 IP
地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26
位是网络地址的情况为例，如下：</p></li>
</ul>
<figure>
<img src="/images/tcp_ip/17.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<ul>
<li>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 "/"
隔开，如下：</li>
</ul>
<figure>
<img src="/images/tcp_ip/18.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<ol start="2" type="1">
<li>路由</li>
</ol>
<ul>
<li><p>发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP
地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于
"指明路由器或主机"
的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</p></li>
<li><p>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。</p></li>
<li><p>IP 协议始终认为路由表是正确的。然后，IP
本身并没有定义制作路由控制表的协议。即 IP
没有制作路由控制表的机制。该表由一个叫做 "路由协议"
的协议制作而成。</p></li>
</ul>
<p>2.1 IP 地址与路由控制</p>
<ul>
<li><p>IP 地址的网络地址部分用于进行路由控制。</p></li>
<li><p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</p></li>
<li><p>在发送 IP 包时，首先要确定 IP
包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将
IP
包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</p></li>
</ul>
<figure>
<img src="/images/tcp_ip/19.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<ol start="3" type="1">
<li>IP 分包与组包</li>
</ol>
<ul>
<li><p>每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的
MTU 也就不同。</p></li>
<li><p>任何一台主机都有必要对 IP
分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</p></li>
<li><p>经过分片之后的 IP
数据报在被重组的时候，只能由目标主机进行进行。路由器虽然做分片但不会进行重组。</p></li>
</ul>
<p>3.1 路径 MTU 发现</p>
<ul>
<li><p>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行
IP 数据包分片处理的。</p></li>
<li><p>为了应对分片机制的不足，"路径 MTU 发现" 技术应运而生。路径 MTU
指的是，从发送端主机到接收端主机不需要分片时 MTU
的大小。即路径中存在的所有数据链路中最小的 MTU。</p></li>
<li><p>进行路径 MTU
发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP
中发送更大的包。</p></li>
</ul>
<ol start="4" type="1">
<li>IPv6</li>
</ol>
<ul>
<li>IPv6 是为了根本解决 IPv4 地址耗尽的问题而被标准化的网络协议。IPv4
的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4
倍，即 128 比特，一般写成 8 个 16 位字节。</li>
</ul>
<p>4.1 IPv6 的特点</p>
<ul>
<li><p>IP 得知的扩大与路由控制表的聚合。</p></li>
<li><p>性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</p></li>
<li><p>支持即插即用功能。即使没有 DHCP 服务器也可以实现自动分配 IP
地址。</p></li>
<li><p>采用认证与加密功能。应对伪造 IP
地址的网络安全功能以及防止线路窃听的功能。</p></li>
<li><p>多播、Mobile IP 成为扩展功能。</p></li>
</ul>
<p>4.2 IPv6 中 IP 地址的标记方法</p>
<ul>
<li><p>一般人们将 128 比特 IP 地址以每 16
比特为一组，每组用冒号隔开进行标记。</p></li>
<li><p>而且如果出现连续的 0 时还可以将这些 0
省略，并且用两个冒号隔开。但是，一个 IP
地址中只允许出现一次两个连续的冒号。</p></li>
</ul>
<p>4.3 IPv6 地址的结构</p>
<ul>
<li><p>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP
地址的种类。</p></li>
<li><p>在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配
IP 地址。</p></li>
</ul>
<figure>
<img src="/images/tcp_ip/20.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<p>4.4 全局单播地址</p>
<ul>
<li><p>全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个
IPv6 地址。</p></li>
<li><p>格式如下图所示，现在 IPv6 的网络中所使用的格式为，n=48，m=16 以及
128-n-m = 64。即前 64 比特为网络标识，后 64 位为主机标识。</p></li>
</ul>
<figure>
<img src="/images/tcp_ip/21.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<p>4.5 链路本地单播地址</p>
<ul>
<li>链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口
ID 保存 64 比特版的 MAC 地址。</li>
</ul>
<figure>
<img src="/images/tcp_ip/22.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<p>4.6 唯一本地地址</p>
<ul>
<li><p>唯一本地地址是不进行互联网通信时所用的地址。</p></li>
<li><p>唯一本地地址虽然不会与互联网连接，但是也会尽可能地生成一个唯一的全局
ID。</p></li>
<li><p>L 通常被置为 1。</p></li>
<li><p>全局 ID 的值随机决定。</p></li>
<li><p>子网 ID 是该域子网地址。</p></li>
<li><p>接口 ID 即为接口的 ID。</p></li>
</ul>
<figure>
<img src="/images/tcp_ip/23.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<p>4.7 IPv6 分段处理</p>
<ul>
<li><p>IPv6
的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</p></li>
<li><p>IPv6 中最小 MTU 为 1280
字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行
"路径 MTU 发现"，而是在发送 IP 包时直接以 1280
字节为单位分片送出。</p></li>
</ul>
<p>4.8 IP 首部</p>
<ol start="5" type="1">
<li>IP 协议相关技术</li>
</ol>
<ul>
<li>IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP
是无法实现通信的。必须还有能够解析主机名称和 MAC
地址的功能，以及数据包在发送过程中异常情况处理的功能。</li>
</ul>
<p>5.1 DNS</p>
<ul>
<li><p>我们平常在访问某个网站时不适用 IP
地址，而是用一串由罗马字和电号组成的字符串。而一般用户在使用 TCP/IP
进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS 功能的支持。DNS
可以将那串字符串自动转换为具体的 IP 地址。</p></li>
<li><p>这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</p></li>
</ul>
<p>5.2 ARP</p>
<ul>
<li><p>只要确定了 IP 地址，就可以向这个目标地址发送 IP
数据包。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP
地址所对应的 MAC 地址。</p></li>
<li><p>ARP 是一种解决地址问题的协议。以目标 IP
地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC
地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代
ARP 发送邻居探索消息。</p></li>
<li><p>RARP 是将 ARP 反过来，从 MAC 地址定位 IP
地址的一种协议。</p></li>
</ul>
<p>5.3 ICMP</p>
<ul>
<li><p>ICMP 的主要功能包括，确认 IP
包是否成功送达目标地址，通知在发送过程当中 IP
包被废弃的具体原因，改善网络设置等。</p></li>
<li><p>IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4
时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP
的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。</p></li>
</ul>
<p>5.4 DHCP</p>
<ul>
<li><p>如果逐一为每一台主机设置 IP
地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置
IP 地址。</p></li>
<li><p>于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了
DHCP（Dynamic Host Configuration Protocol）协议。有了
DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP
让即插即用变得可能。</p></li>
<li><p>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</p></li>
</ul>
<p>5.5 NAT</p>
<ul>
<li><p>NAT(Network Address Translator)
是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP
地址的技术。</p></li>
<li><p>除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的
NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP
地址与多个主机的通信。</p></li>
<li><p>NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4
而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和
IPv6 之间的相互通信当中常常使用 NATPT。</p></li>
</ul>
<p>5.6 IP 隧道</p>
<figure>
<img src="/images/tcp_ip/24.jpeg" alt="x" />
<figcaption aria-hidden="true">x</figcaption>
</figure>
<ul>
<li><p>如上图的网络环境中，网络 A 与网络 B
之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP
隧道的功能。</p></li>
<li><p>IP 隧道可以将那些从网络 A 发送过来的 IPv6
的统合为一个数据，再为之追加一个 IPv4 首部以后转发给网络 C。</p></li>
<li><p>一般情况下，紧接着 IP 首部的是 TCP 或 UDP
的首部。然而，现在的应用当中 "IP首部的后面还是IP首部" 或
"IP首部的后面是IPv6的首部"
等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做
"IP隧道"。</p></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/46/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/46/">46</a><span class="page-number current">47</span><a class="page-number" href="/page/48/">48</a><span class="space">&hellip;</span><a class="page-number" href="/page/70/">70</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/48/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">eleven26</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eleven26" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
