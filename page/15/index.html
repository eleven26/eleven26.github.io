<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eleven26.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="eleven26">
<meta property="og:url" content="https://eleven26.github.io/page/15/index.html">
<meta property="og:site_name" content="eleven26">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="eleven26">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="PHP">
<meta property="article:tag" content="Laravel">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://eleven26.github.io/page/15/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/15/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>eleven26</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">eleven26</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">100</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">346</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eleven26</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eleven26" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eleven26" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2023/01/02/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20reflect%20-%20%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BC%A0%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/02/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20reflect%20-%20%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BC%A0%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">深入理解 go reflect - 要不要传指针</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-01-02 20:28:30" itemprop="dateCreated datePublished" datetime="2023-01-02T20:28:30+08:00">2023-01-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在我们看一些使用反射的代码的时候，会发现，<code>reflect.ValueOf</code>
或 <code>reflect.TypeOf</code>
的参数有些地方使用的是指针参数，有些地方又不是指针参数，
但是好像这两者在使用上没什么区别，比如下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">v1 := reflect.ValueOf(a)</span><br><span class="line">v2 := reflect.ValueOf(&amp;a)</span><br><span class="line"></span><br><span class="line">fmt.Println(v1.Int())        <span class="comment">// 1</span></span><br><span class="line">fmt.Println(v2.Elem().Int()) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>它们的区别貌似只是需不需要使用 <code>Elem()</code>
方法，但这个跟我们是否传递指针给 <code>reflect.ValueOf</code>
其实关系不大， 相信没有人为了使用一下 <code>Elem()</code>
方法，就去传递指针给 <code>reflect.ValueOf</code> 吧。</p>
<p>那我们什么时候应该传递指针参数呢？</p>
<h2 id="什么时候传递指针">什么时候传递指针？</h2>
<p>要回答这个问题，我们可以思考一下以下列出的几点内容：</p>
<ol type="1">
<li>是否要修改变量的值，要修改就要用指针</li>
<li>结构体类型：是否要修改<strong>结构体里的字段</strong>，要修改就要用指针</li>
<li>结构体类型：是否要调用<strong>指针接收值方法</strong>，要调用就要用指针</li>
<li>对于 <code>chan</code>、<code>map</code>、<code>slice</code>
类型，我们传递值和传递指针都可以修改其内容</li>
<li>对于非 <code>interface</code> 类型，传递给 <code>TypeOf</code> 和
<code>ValueOf</code> 的时候都会转换为 <code>interface</code>
类型，如果本身就是 <code>interface</code> 类型，则不需转换。</li>
<li>指针类型不可修改，但是可以修改指针指向的值。（<code>v := reflect.ValueOf(&amp;a)</code>，<code>v.CanSet()</code>
是 <code>false</code>，<code>v.Elem().CanSet()</code> 是
<code>true</code>）</li>
<li>字符串：我们可以对字符串进行替换，但不能修改字符串的某一个字符</li>
</ol>
<p>大概总结下来，就是：如果我们想修改变量的内容，就传递指针，否则就传递值。对于某些复合类型如果其内部包含了底层数据的指针，
也是可以通过传值来修改其底层数据的，这些类型有
<code>chan</code>、<code>map</code>、<code>slice</code>。
又或者如果我们想修改结构体类型里面的指针类型字段，传递结构体的拷贝也能实现。</p>
<h2 id="通过传递指针修改变量的值">1. 通过传递指针修改变量的值</h2>
<p>对于一些基础类型的变量，如果我们想修改其内容，就要传递指针。这是因为在
go 里面参数传递都是值传递，如果我们不传指针，
那么在函数内部拿到的只是参数的拷贝，对其进行修改，不会影响到外部的变量（事实上在对这种反射值进行修改的时候会直接
<code>panic</code>）。</p>
<h3 id="传值无法修改变量本身">传值无法修改变量本身</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>v</code> 中保存的是 <code>x</code>
的拷贝，对这份拷贝在反射的层面上做修改其实是没有实际意义的，因为对拷贝进行修改并不会影响到
<code>x</code> 本身。
我们在通过反射来修改变量的时候，我们的预期行为往往是修改变量本身。鉴于实际的使用场景，go
的反射系统已经帮我们做了限制了，
在我们对拷贝类型的反射对象进行修改的时候，会直接
<code>panic</code>。</p>
<figure>
<img src="/images/go/reflect1/reflect_1.png" alt="reflect_1" />
<figcaption aria-hidden="true">reflect_1</figcaption>
</figure>
<h3 id="传指针可以修改变量">传指针可以修改变量</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(&amp;x).Elem()</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们传递了 <code>x</code> 的指针到
<code>reflect.ValueOf</code> 中，这样一来，<code>v</code> 指向的就是
<code>x</code> 本身了。 在这种情况下，我们对 <code>v</code>
的修改就会影响到 <code>x</code> 本身。</p>
<figure>
<img src="/images/go/reflect1/reflect_2.png" alt="reflect_2" />
<figcaption aria-hidden="true">reflect_2</figcaption>
</figure>
<h2 id="通过传递指针修改结构体的字段">2.
通过传递指针修改结构体的字段</h2>
<p>对于结构体类型，如果我们想修改其字段的值，也是要传递指针的。这是因为结构体类型的字段是值类型，如果我们不传递指针，
<code>reflect.ValueOf</code>
拿到的也是一份拷贝，对其进行修改并不会影响到结构体本身。当然，这种情况下，我们修改它的时候也会
<code>panic</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := person&#123;</span><br><span class="line">    Name: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    Age:  <span class="number">30</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// v 本质上是指向 p 的指针</span></span><br><span class="line">v := reflect.ValueOf(&amp;p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// v.CanSet() 为 false，v 是指针，指针本身是不能修改的</span></span><br><span class="line"><span class="comment">// v.Elem() 是 p 本身，是可以修改的</span></span><br><span class="line"></span><br><span class="line">fmt.Println(v.Elem().FieldByName(<span class="string">&quot;Name&quot;</span>).CanSet()) <span class="comment">// true</span></span><br><span class="line">fmt.Println(v.Elem().FieldByName(<span class="string">&quot;Age&quot;</span>).CanSet())  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/images/go/reflect1/reflect_3.png" alt="reflect_3" />
<figcaption aria-hidden="true">reflect_3</figcaption>
</figure>
<h2 id="结构体获取指针接收值方法">3. 结构体：获取指针接收值方法</h2>
<p><strong>对于结构体而言，如果我们想通过反射来调用指针接收者方法，那么我们需要传递指针。</strong></p>
<p>在开始讲解这一点之前，需要就以下内容达成共识：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> M1() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> M2() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPerson</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	p := person&#123;&#125;</span><br><span class="line">	v1 := reflect.ValueOf(p)</span><br><span class="line">	v2 := reflect.ValueOf(&amp;p)</span><br><span class="line"></span><br><span class="line">	assert.Equal(t, <span class="number">1</span>, v1.NumMethod())</span><br><span class="line">	assert.Equal(t, <span class="number">2</span>, v2.NumMethod())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// v1 和 v2 都有 M1 方法</span></span><br><span class="line">	assert.True(t, v1.MethodByName(<span class="string">&quot;M1&quot;</span>).IsValid())</span><br><span class="line">	assert.True(t, v2.MethodByName(<span class="string">&quot;M1&quot;</span>).IsValid())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// v1 没有 M2 方法</span></span><br><span class="line">	<span class="comment">// v2 有 M2 方法</span></span><br><span class="line">	assert.False(t, v1.MethodByName(<span class="string">&quot;M2&quot;</span>).IsValid())</span><br><span class="line">	assert.True(t, v2.MethodByName(<span class="string">&quot;M2&quot;</span>).IsValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>p</code> 只有一个方法 <code>M1</code>，而
<code>&amp;p</code> 有两个方法 <code>M1</code> 和 <code>M2</code>。
<strong>但是在实际使用中，我们使用 p 来调用 M2 也是可以的</strong>，
<code>p</code> 之所以能调用 <code>M2</code>
是因为编译器帮我们做了一些处理，将 <code>p</code> 转换成了
<code>&amp;p</code>，然后调用 <code>M2</code>。</p>
<figure>
<img src="/images/go/reflect1/reflect_4.png" alt="reflect_4" />
<figcaption aria-hidden="true">reflect_4</figcaption>
</figure>
<p>但是在反射的时候，我们是无法做到这一点的，这个需要特别注意。如果我们想通过反射来调用指针接收者的方法，就需要传递指针。</p>
<h2 id="变量本身包含指向数据的指针">4. 变量本身包含指向数据的指针</h2>
<blockquote>
<p>最好不要通过值的反射对象来修改值的数据，就算有些类型可以实现这种功能。</p>
</blockquote>
<p>对于 <code>chan</code>、<code>map</code>、<code>slice</code>
这三种类型，我们可以通过 <code>reflect.ValueOf</code> 来获取它们的值，
但是这个值本身包含了指向数据的指针，因此我们依然可以通过反射系统修改其数据。但是，<strong>我们最好不这么用，从规范的角度，这是一种错误的操作。</strong></p>
<h3 id="通过值反射对象修改-chanmap-和-slice">通过值反射对象修改
chan、map 和 slice</h3>
<figure>
<img src="/images/go/reflect1/reflect_5.png" alt="reflect_5" />
<figcaption aria-hidden="true">reflect_5</figcaption>
</figure>
<p>在 go 中，<code>chan</code>、<code>map</code>、<code>slice</code>
这几种数据结构中，存储数据都是通过一个 <code>unsafe.Pointer</code>
类型的变量来指向实际存储数据的内存。
这是因为，这几种类型能够存储的元素个数都是不确定的，都需要根据我们指定的大小和存储的元素类型来进行内存分配。</p>
<p>正因如此，我们复制
<code>chan</code>、<code>map</code>、<code>slice</code>
的时候，虽然值被复制了一遍，但是存储数据的指针也被复制了，
这样我们依然可以通过拷贝的数据指针来修改其数据，如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPointer1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 数组需要传递引用才能修改其元素</span></span><br><span class="line">	arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	v1 := reflect.ValueOf(&amp;arr)</span><br><span class="line">	v1.Elem().Index(<span class="number">1</span>).SetInt(<span class="number">100</span>)</span><br><span class="line">	assert.Equal(t, <span class="number">100</span>, arr[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// chan 传值也可以修改其元素</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	v2 := reflect.ValueOf(ch)</span><br><span class="line">	v2.Send(reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">	assert.Equal(t, <span class="number">10</span>, &lt;-ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// map 传值也可以修改其元素</span></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	v3 := reflect.ValueOf(m)</span><br><span class="line">	v3.SetMapIndex(reflect.ValueOf(<span class="number">1</span>), reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">	assert.Equal(t, <span class="number">10</span>, m[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// slice 传值也可以修改其元素</span></span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	v4 := reflect.ValueOf(s)</span><br><span class="line">	v4.Index(<span class="number">1</span>).SetInt(<span class="number">20</span>)</span><br><span class="line">	assert.Equal(t, <span class="number">20</span>, s[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slice-反射对象扩容的影响">slice 反射对象扩容的影响</h3>
<p>但是，我们需要注意的是，对于 <code>map</code> 和 <code>slice</code>
类型，在其分配的内存容纳不下新的元素的时候，会进行<strong>扩容</strong>，
<strong>扩容之后，保存数据字段的指针就指向了一片新的内存了</strong>。
这意味着什么呢？这意味着，我们通过 <code>map</code> 和
<code>slice</code> 的值创建的反射值对象中拿到的那份数据指针已经跟旧的
<code>map</code> 和 <code>slice</code> 指向的内存不一样了。</p>
<figure>
<img src="/images/go/reflect1/reflect_6.png" alt="reflect_6" />
<figcaption aria-hidden="true">reflect_6</figcaption>
</figure>
<p>说明：在上图中，我们在反射对象中往 <code>slice</code>
追加元素后，导致反射对象 <code>slice</code> 的 <code>array</code>
指针指向了一片新的内存区域了，
这个时候我们再对反射对象进行修改的时候，不会影响到原
<code>slice</code>。这也就是我们不能通过 <code>slice</code> 或
<code>map</code> 的拷贝的反射对象来修改 <code>slice</code> 或
<code>map</code> 的原因。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPointer1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	v4 := reflect.ValueOf(s)</span><br><span class="line">	v4.Index(<span class="number">1</span>).SetInt(<span class="number">20</span>)</span><br><span class="line">	assert.Equal(t, <span class="number">20</span>, s[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里发生了扩容</span></span><br><span class="line">	<span class="comment">// v5 的 array 跟 s 的 array 指向的是不同的内存区域了。</span></span><br><span class="line">	v5 := reflect.Append(v4, reflect.ValueOf(<span class="number">4</span>))</span><br><span class="line">	fmt.Println(s) <span class="comment">// [1 20 3]</span></span><br><span class="line">	fmt.Println(v5.Interface().([]<span class="type">int</span>)) <span class="comment">// [1 20 3 4]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里修改 v5 的时候影响不到 s 了</span></span><br><span class="line">	v5.Index(<span class="number">1</span>).SetInt(<span class="number">30</span>)</span><br><span class="line">	fmt.Println(s) <span class="comment">// [1 20 3]</span></span><br><span class="line">	fmt.Println(v5.Interface().([]<span class="type">int</span>)) <span class="comment">// [1 30 3 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：在上面的代码中，<code>v5</code> 实际上是 <code>v4</code>
扩容后的切片，底层的 <code>array</code> 指针指向的是跟 <code>s</code>
不一样的 <code>array</code> 了， 因此在我们修改 <code>v5</code>
的时候，会发现原来的 <code>s</code> 并没有发生改变。</p>
<blockquote>
<p>虽然通过值反射对象可以修改 slice 的数据，但是如果通过反射对象 append
元素到 slice 的反射对象的时候， 可能会触发 slice
扩容，这个时候再修改反射对象的时候，就影响不了原来的 slice 了。</p>
</blockquote>
<h3 id="slice-容量够的话是不是就可以正常追加元素了">slice
容量够的话是不是就可以正常追加元素了？</h3>
<p>只能说，能，也不能。我们看看下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPointer000</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">	s1[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	s1[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">	s1[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">	fmt.Println(s1) <span class="comment">// [1 2 3]</span></span><br><span class="line"></span><br><span class="line">	v6 := reflect.ValueOf(s1)</span><br><span class="line">	v7 := reflect.Append(v6, reflect.ValueOf(<span class="number">4</span>))</span><br><span class="line">	<span class="comment">// 虽然 s1 的容量足够大，但是 s1 还是看不到追加的元素</span></span><br><span class="line">	fmt.Println(s1)                     <span class="comment">// [1 2 3]</span></span><br><span class="line">	fmt.Println(v7.Interface().([]<span class="type">int</span>)) <span class="comment">// [1 2 3 4]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// s1 和 s2 底层数组还是同一个</span></span><br><span class="line">	<span class="comment">// array1 是 s1 底层数组的内存地址</span></span><br><span class="line">	array1 := (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1))).Data</span><br><span class="line">	s2 := v7.Interface().([]<span class="type">int</span>)</span><br><span class="line">    <span class="comment">// array2 是 s2 底层数组的内存地址</span></span><br><span class="line">	array2 := (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2))).Data</span><br><span class="line">	assert.Equal(t, array1, array2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这是因为 s1 的长度并没有发生改变，</span></span><br><span class="line">	<span class="comment">// 所以 s1 看不到追加的那个元素</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1)) <span class="comment">// 3 6</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2)) <span class="comment">// 4 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们给 <code>slice</code>
分配了足够大的容量，但是我们通过反射对象来追加元素的时候，
虽然数据被正常追加到了 <code>s1</code>
底层数组，但是由于在反射对象以外的 <code>s1</code> 的 <code>len</code>
并没有发生改变， 因此 <code>s1</code>
还是看不到反射对象追加的元素。所以上面说<strong>可以正常追加元素</strong>。</p>
<p>但是，外部由于 <code>len</code>
没有发生改变，因此外部看不到反射对象追加的元素，所以上面也说<strong>不能正常追加元素</strong>。</p>
<p>因此，虽然理论上修改的是同一片内存，我们依然不能通过传值的方式来通过反射对象往
<code>slice</code> 中追加元素。 但是修改 <code>[0, len(s))</code>
范围内的元素在反射对象外部是可以看到的。</p>
<h3 id="map-也不能通过值反射对象来修改其元素">map
也不能通过值反射对象来修改其元素。</h3>
<p>跟 <code>slice</code> 类似，通过 <code>map</code>
的值反射对象来<strong>追加</strong>元素的时候，同样可能导致扩容，
扩容之后，保存数据的内存区域会发生改变。</p>
<p>但是，从另一个角度看，如果我们只是<strong>修改</strong>其元素的话，是可以正常修改的。</p>
<h3 id="chan-没有追加">chan 没有追加</h3>
<p><code>chan</code> 跟 <code>slice</code>、<code>map</code>
有个不一样的地方，它的长度是我们创建 <code>chan</code>
的时候就已经固定的了，
因此，<strong>不存在扩容导致指向内存区域发生改变的问题。</strong></p>
<p>因此，对于 <code>chan</code> 类型的元素，我们传 <code>ch</code> 或者
<code>&amp;ch</code> 给 <code>reflect.ValueOf</code> 都可以实现修改
<code>ch</code>。</p>
<h3 id="结构体字段包含指针的情况">结构体字段包含指针的情况</h3>
<p>如果结构体里面包含了指针字段，我们也只是想通过反射对象来修改这个指针字段的话，
那么我们也还是可以通过传值给 <code>reflect.ValueOf</code>
来创建反射对象来修改这个指针字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name *<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPointerPerson</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	name := <span class="string">&quot;foo&quot;</span></span><br><span class="line">	p := person&#123;Name: &amp;name&#125;</span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(p)</span><br><span class="line">	fmt.Println(v.Field(<span class="number">0</span>).Elem().CanAddr())</span><br><span class="line">	fmt.Println(v.Field(<span class="number">0</span>).Elem().CanSet())</span><br><span class="line"></span><br><span class="line">	name1 := <span class="string">&quot;bar&quot;</span></span><br><span class="line">	v.Field(<span class="number">0</span>).Elem().Set(reflect.ValueOf(name1))</span><br><span class="line">	<span class="comment">// p 的 Name 字段已经被成功修改</span></span><br><span class="line">	fmt.Println(*p.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们虽然使用了 <code>p</code> 而不是
<code>&amp;p</code> 来创建反射对象， 但是我们依然可以修改
<code>Name</code> 字段，因为反射对象拿到了 <code>Name</code>
的指针的拷贝， 通过这个拷贝是可以定位到 <code>p</code> 的
<code>Name</code> 字段本身指向的内存的。</p>
<p><strong>但是我们依然是不能修改 <code>p</code>
中的其他字段。</strong></p>
<h2 id="interface-类型处理">5. interface 类型处理</h2>
<p>对于 <code>interface</code>
类型的元素，我们可以将以下两种操作看作是等价的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v1 跟 v2 都拿到了 a 的拷贝</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">v1 := reflect.ValueOf(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line">v2 := reflect.ValueOf(b)</span><br></pre></td></tr></table></figure>
<p>我们可以通过下面的断言来证明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert.Equal(t, v1.Kind(), v2.Kind())</span><br><span class="line">assert.Equal(t, v1.CanAddr(), v2.CanAddr())</span><br><span class="line">assert.Equal(t, v1.CanSet(), v2.CanSet())</span><br><span class="line">assert.Equal(t, v1.Interface(), v2.Interface())</span><br></pre></td></tr></table></figure>
<p>当然，对于指针类型也是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v1 跟 v2 都拿到了 a 的指针</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">v1 := reflect.ValueOf(&amp;a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = &amp;a</span><br><span class="line">v2 := reflect.ValueOf(b)</span><br></pre></td></tr></table></figure>
<p>同样的，我们可以通过下面的断言来证明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assert.Equal(t, v1.Kind(), v2.Kind())</span><br><span class="line">assert.Equal(t, v1.Elem().Kind(), v2.Elem().Kind())</span><br><span class="line">assert.Equal(t, v1.Elem().CanAddr(), v2.Elem().CanAddr())</span><br><span class="line">assert.Equal(t, v1.Elem().Addr(), v2.Elem().Addr())</span><br><span class="line">assert.Equal(t, v1.Interface(), v2.Interface())</span><br><span class="line">assert.Equal(t, v1.Elem().Interface(), v2.Elem().Interface())</span><br></pre></td></tr></table></figure>
<h3 id="interface-底层类型是值">interface 底层类型是值</h3>
<p><code>interface</code> 类型的底层类型是值的时候，我们将其传给
<code>reflect.ValueOf</code> 跟直接传值是一样的。 是没有办法修改
<code>interface</code>
底层数据的值的（除了指针类型字段，因为反射对象也拿到了指针字段的地址）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name *<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInterface1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	name := <span class="string">&quot;foo&quot;</span></span><br><span class="line">	p := person&#123;Name: &amp;name&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// v 拿到的是 p 的拷贝</span></span><br><span class="line">    <span class="comment">// 下面两行等价于 v := reflect.ValueOf(p)</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = p</span><br><span class="line">	v := reflect.ValueOf(i)</span><br><span class="line">	assert.False(t, v.CanAddr())</span><br><span class="line">	assert.Equal(t, reflect.Struct, v.Kind())</span><br><span class="line">	assert.True(t, v.Field(<span class="number">0</span>).Elem().CanAddr())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中 <code>v := reflect.ValueOf(i)</code> 其实等价于
<code>v := reflect.ValueOf(p)</code>， 因为在我们调用
<code>reflect.ValueOf(p)</code> 的时候，go 语言本身会帮我们将
<code>p</code> 转换为 <code>interface&#123;&#125;</code> 类型。 在我们赋值给
<code>i</code> 的时候，go 语言也会帮我们将 <code>p</code> 转换为
<code>interface&#123;&#125;</code> 类型。 这样再调用 <code>reflect.ValueOf</code>
的时候就不需要再做转换了。</p>
<figure>
<img src="/images/go/reflect1/reflect_7.png" alt="reflect_7" />
<figcaption aria-hidden="true">reflect_7</figcaption>
</figure>
<h3 id="interface-底层类型是指针">interface 底层类型是指针</h3>
<p>传递底层数据是指针类型的 <code>interface</code> 给
<code>reflect.ValueOf</code> 的时候，我们可以修改 <code>interface</code>
底层指针指向的值， 效果等同于直接传递指针给
<code>reflect.ValueOf</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInterface</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">	v1 := reflect.ValueOf(&amp;a)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = &amp;a</span><br><span class="line">	v2 := reflect.ValueOf(b)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// v1 和 v2 本质上都接收了一个 interface 参数，</span></span><br><span class="line">	<span class="comment">// 这个 interface 参数的数据部分都是 &amp;a</span></span><br><span class="line"></span><br><span class="line">	v1.Elem().SetInt(<span class="number">10</span>)</span><br><span class="line">	assert.Equal(t, <span class="number">10</span>, a)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过 v1 修改 a 的值，v2 也能看到</span></span><br><span class="line">	assert.Equal(t, <span class="number">10</span>, v2.Elem().Interface())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同样的，通过 v2 修改 a 的值，v1 也能看到</span></span><br><span class="line">	v2.Elem().SetInt(<span class="number">20</span>)</span><br><span class="line">	assert.Equal(t, <span class="number">20</span>, a)</span><br><span class="line">	assert.Equal(t, <span class="number">20</span>, v1.Elem().Interface())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不要再对接口类型取地址">不要再对接口类型取地址</h3>
<blockquote>
<p>能不能通过反射 Value
对象来修改变量只取决于，能不能根据反射对象拿到最初变量的内存地址。
如果拿到的只是原始值的拷贝，不管我们怎么做都无法修改原始值。</p>
</blockquote>
<p>对于初学者另外一个令人困惑的地方可能是下面这样的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInterface</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line">	v1 := reflect.ValueOf(&amp;a)</span><br><span class="line">	v2 := reflect.ValueOf(&amp;i)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// v1 和 v2 的类型都是 reflect.Ptr</span></span><br><span class="line">	assert.Equal(t, reflect.Ptr, v1.Kind())</span><br><span class="line">	assert.Equal(t, reflect.Ptr, v2.Kind())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 但是两者的 Elem() 类型不同，</span></span><br><span class="line">	<span class="comment">// v1 的 Elem() 是 reflect.Int，</span></span><br><span class="line">	<span class="comment">// v2 的 Elem() 是 reflect.Interface</span></span><br><span class="line">	assert.Equal(t, reflect.Int, v1.Elem().Kind())</span><br><span class="line">	assert.Equal(t, reflect.Interface, v2.Elem().Kind())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>困惑的源头在于，<code>reflect.ValueOf()</code> 这个函数的参数是
<code>interface&#123;&#125;</code> 类型的，
这意味着我们可以传递任意类型的值给它，包括指针类型的值。</p>
<p>正因如此，如果我们不懂得 <code>reflect</code> 包的工作原理的话，
就会传错变量到 <code>reflect.ValueOf()</code> 函数中，导致程序出错。</p>
<p>对于上面例子的 <code>v2</code>，它是一个指向 <code>interface&#123;&#125;</code>
类型的指针的反射对象，它也能找到最初的变量 <code>a</code>：</p>
<blockquote>
<p>但是能不能修改 <code>a</code>，还是取决于 <code>a</code>
是否是可寻址的。也就是最初传递给 <code>i</code>
的值是不是一个指针类型。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert.Equal(t, <span class="string">&quot;&lt;*interface &#123;&#125; Value&gt;&quot;</span>, v2.String())</span><br><span class="line">assert.Equal(t, <span class="string">&quot;&lt;interface &#123;&#125; Value&gt;&quot;</span>, v2.Elem().String())</span><br><span class="line">assert.Equal(t, <span class="string">&quot;&lt;int Value&gt;&quot;</span>, v2.Elem().Elem().String())</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们传递给 <code>i</code> 的是 <code>a</code>
的值，而不是 <code>a</code> 的指针，所以 <code>i</code>
是不可寻址的，也就是说 <code>v2</code> 是不可寻址的。</p>
<figure>
<img src="/images/go/reflect1/reflect_8.png" alt="reflect_8" />
<figcaption aria-hidden="true">reflect_8</figcaption>
</figure>
<p>上图说明：</p>
<ul>
<li><code>i</code> 是接口类型，它的数据部分是 <code>a</code>
的拷贝，它的类型部分是 <code>int</code> 类型。</li>
<li><code>&amp;i</code> 是指向接口的指针，它指向了上图的
<code>eface</code>。</li>
<li><code>v2</code> 是指向 <code>eface</code> 的指针的反射对象。</li>
<li>最终，我们通过 <code>v2</code> 找到 <code>i</code>
这个接口，然后通过 <code>i</code> 找到 <code>a</code>
这个变量的<strong>拷贝</strong>。</li>
</ul>
<p>所以，绕了一大圈，我们最终还是修改不了 <code>a</code>
的值。到最后我们只拿到了 <code>a</code> 的拷贝。</p>
<h2 id="指针类型反射对象不可修改其指向地址">6.
指针类型反射对象不可修改其指向地址</h2>
<p>其实这一点上面有些地方也有涉及到，但是这里再强调一下。一个例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPointer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> b = &amp;a</span><br><span class="line">	v := reflect.ValueOf(b)</span><br><span class="line"></span><br><span class="line">	assert.False(t, v.CanAddr())</span><br><span class="line">	assert.False(t, v.CanSet())</span><br><span class="line"></span><br><span class="line">	assert.True(t, v.Elem().CanAddr())</span><br><span class="line">	assert.True(t, v.Elem().CanSet())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/images/go/reflect1/reflect_9.png" alt="reflect_9" />
<figcaption aria-hidden="true">reflect_9</figcaption>
</figure>
<p>说明：</p>
<ul>
<li><code>v</code> 是指向 <code>&amp;a</code> 的指针的反射对象。</li>
<li>通过这个反射对象的 <code>Elem()</code> 方法，我们可以找到原始的变量
<code>a</code>。</li>
<li>反射对象本身不能修改，但是它的 <code>Elem()</code>
方法返回的反射对象可以修改。</li>
</ul>
<blockquote>
<p>对于指针类型的反射对象，其本身不能修改，但是它的 <code>Elem()</code>
方法返回的反射对象可以修改。</p>
</blockquote>
<h2 id="反射也不能修改字符串中的字符">7.
反射也不能修改字符串中的字符</h2>
<p>这是因为，go 中的字符串本身是不可变的，我们无法像在 C
语言中那样修改其中某一个字符。 其实不止是
go，其实很多编程语言的字符串都是不可变的，比如 Java 中的
<code>String</code> 类型。</p>
<p>在 go 中，字符串是用一个结构体来表示的，大概长下面这个样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Data</code> 是指向字符串的指针。</li>
<li><code>Len</code> 是字符串的长度（单位为字节）。</li>
</ul>
<p>在 go 中 <code>str[1] = 'a'</code>
这样的操作是不允许的，因为字符串是不可变的。</p>
<h3 id="相同的字符串只有一个实例">相同的字符串只有一个实例</h3>
<p>假设我们定义了两个相同的字符串，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>这两个字符串的值是相同的，但是它们的地址是不同的。那既然如此，为什么我们还是不能修改它的其中某一个字符呢？
这是因为，虽然 <code>s1</code> 和 <code>s2</code>
的地址不一样，但是它们实际保存 <code>hello</code>
这个字符串的地址是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v1 := (*reflect.StringHeader)(unsafe.Pointer(&amp;s1))</span><br><span class="line">v2 := (*reflect.StringHeader)(unsafe.Pointer(&amp;s2))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个字符串实例保存字符串的内存地址是一样的</span></span><br><span class="line">assert.Equal(t, v1.Data, v2.Data)</span><br></pre></td></tr></table></figure>
<p>两个字符串内存表示如下：</p>
<figure>
<img src="/images/go/reflect1/reflect_10.png" alt="reflect_10" />
<figcaption aria-hidden="true">reflect_10</figcaption>
</figure>
<p>所以，我们可以看到，<code>s1</code> 和 <code>s2</code>
实际上是指向同一个字符串的指针，所以我们无法修改其中某一个字符。
<strong>因为如果允许这种行为存在的话，我们对其中一个字符串实例修改，也会影响到另外一个字符串实例。</strong></p>
<h3 id="字符串本身可以替换">字符串本身可以替换</h3>
<p>虽然我们不能修改字符串中的某一个字符，但是我们可以通过反射对象把整个字符串替换掉：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStirng</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(&amp;s)</span><br><span class="line">	fmt.Println(v.Elem().CanAddr())</span><br><span class="line">	fmt.Println(v.Elem().CanSet())</span><br><span class="line"></span><br><span class="line">	v.Elem().SetString(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">	fmt.Println(s) <span class="comment">// world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实际上是把 <code>s</code> 中保存字符串的地址替换成了指向
<code>world</code> 这个字符串的地址，而不是将 <code>hello</code>
指向的内存修改成 <code>world</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStirng</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">	oldAddr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Data</span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(&amp;s)</span><br><span class="line">	v.Elem().SetString(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">	newAddr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Data</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改之后，实际保存字符串的内存地址发生了改变</span></span><br><span class="line">	assert.NotEqual(t, oldAddr, newAddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以用下图表示：</p>
<figure>
<img src="/images/go/reflect1/reflect_10.png" alt="reflect_10" />
<figcaption aria-hidden="true">reflect_10</figcaption>
</figure>
<h2 id="总结">总结</h2>
<ul>
<li>如果我们需要通过反射对象来修改变量的值，那么我们必须得有办法拿到变量实际存储的内存地址。这种情况下，很多时候都是通过传递指针给
<code>reflect.ValueOf()</code> 方法来实现的。</li>
<li>但是对于 <code>chan</code>、<code>map</code> 和 <code>slice</code>
或者其他类似的数据结构，它们通过指针来引用实际存储数据的内存，这种数据结构是通过通过传值给
<code>reflect.ValueOf()</code>
方法来实现修改其中的元素的。因为这些数据结构的数据部分可以通过指针的拷贝来修改。</li>
<li>但是 <code>map</code> 和 <code>slice</code>
有可能会扩容，如果通过反射对象来追加元素，可能导致追加失败。这是因为，通过反射对象追加元素的时候，如果扩容了，那么原来的内存地址就会失效，这样我们其实就修改不了原来的
<code>map</code> 和 <code>slice</code> 了。</li>
<li>同样的，<strong>结构体传值</strong>来创建反射对象的时候，如果其中有指针类型的字段，那么我们也可以通过指针来修改其中的元素。但是其他字段也还是修改不了的。</li>
<li>如果我们创建反射对象的参数是 <code>interface</code>
类型，那么能不能修改元素的变量还是取决于我们这个 <code>interface</code>
类型变量的数据部分是值还是指针。如果 <code>interface</code>
变量中存储的是值，那么我们就不能修改其中的元素了。如果
<code>interface</code> 变量中存储的是指针，就可以修改。</li>
<li>我们无法修改字符串的某一个字符，通过反射也不能，因为字符串本身是不可变的。不同的
<code>stirng</code>
类型的变量，如果它们的值是一样的，那么它们会共享实际存储字符串的内存。</li>
<li>但是我们可以直接用一个新的字符串替代旧的字符串。</li>
</ul>
<p>但其实说了那么多，简单来说只有一点，就是我们<strong>只能通过反射对象来修改指针类型的变量</strong>。如果拿不到实际存储数据的指针，那么我们就无法通过反射对象来修改其中的元素了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/12/31/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20reflect%20-%20%E5%8F%8D%E5%B0%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/31/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20reflect%20-%20%E5%8F%8D%E5%B0%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">深入理解 go reflect - 反射基本原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-31 20:08:30" itemprop="dateCreated datePublished" datetime="2022-12-31T20:08:30+08:00">2022-12-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="反射概述">反射概述</h2>
<p><strong>反射</strong>是这样一种机制，它是可以让我们在程序运行时（runtime）访问、检测和修改对象本身状态或行为的一种能力。
比如，从一个变量推断出其类型信息、以及存储的数据的一些信息，又或者获取一个对象有什么方法可以调用等。
反射经常用在一些需要同时处理不同类型变量的地方，比如序列化、反序列化、<code>ORM</code>
等等，如标准库里面的 <code>json.Marshal</code>。</p>
<h2 id="反射基础---go-的-interface-是怎么存储的">反射基础 - go 的
interface 是怎么存储的？</h2>
<p>在正式开始讲解反射之前，我们有必要了解一下 go
里的接口（<code>interface</code>）是怎么存储的。
关于这个问题，在我的另外一篇文章中已经做了很详细的讲解 <a
target="_blank" rel="noopener" href="https://blog.baiguiren.com/2022/12/06/golang/go%20interface%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">go
interface 设计与实现</a>， 这里不再赘述。但还是简单说一下，go
的接口是由两部分组成的，一部分是类型信息，另一部分是数据信息，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = a</span><br></pre></td></tr></table></figure>
<p>对于这个例子，<code>b</code> 的类型信息是
<code>int</code>，数据信息是 <code>1</code>，这两部分信息都是存储在
<code>b</code> 里面的。<code>b</code> 的内存结构如下：</p>
<figure>
<img src="/images/go/reflect/reflect_1.png" alt="reflect_1" />
<figcaption aria-hidden="true">reflect_1</figcaption>
</figure>
<p>在上图中，<code>b</code> 的类型实际上是
<code>eface</code>，它是一个空接口，它的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，<strong>一个 interface{}
中实际上既包含了变量的类型信息，也包含了类型的数据。</strong>
正因为如此，我们才可以通过反射来获取到变量的类型信息，以及变量的数据信息。</p>
<h2 id="反射对象---reflect.type-和-reflect.value">反射对象 -
reflect.Type 和 reflect.Value</h2>
<p>知道了 <code>interface&#123;&#125;</code>
的内存结构之后，我们就可以开始讲解反射了。反射的核心是两个对象，分别是
<code>reflect.Type</code> 和 <code>reflect.Value</code>。 它们分别代表了
go 语言中的类型和值。我们可以通过 <code>reflect.TypeOf</code> 和
<code>reflect.ValueOf</code> 来获取到一个变量的类型和值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">t := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;hello&quot;</span></span><br><span class="line">t1 := reflect.ValueOf(b)</span><br></pre></td></tr></table></figure>
<p>我们去看一下 <code>TypeOf</code> 和 <code>ValueOf</code>
的源码会发现，这两个方法都接收一个 <code>interface&#123;&#125;</code>
类型的参数，然后返回一个 <code>reflect.Type</code> 和
<code>reflect.Value</code> 类型的值。这也就是为什么我们可以通过
<code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code>
来获取到一个变量的类型和值的原因。</p>
<figure>
<img src="/images/go/reflect/reflect_2.png" alt="reflect_2" />
<figcaption aria-hidden="true">reflect_2</figcaption>
</figure>
<h2 id="反射定律">反射定律</h2>
<p>在 go 官方博客中关于反射的文章 <a
target="_blank" rel="noopener" href="https://go.dev/blog/laws-of-reflection">laws-of-reflection</a>
中，提到了三条反射定律：</p>
<ol type="1">
<li>反射可以将 <code>interface</code> 类型变量转换成反射对象。</li>
<li>反射可以将反射对象还原成 <code>interface</code> 对象。</li>
<li>如果要修改反射对象，那么反射对象必须是可设置的（<code>CanSet</code>）。</li>
</ol>
<p>关于这三条定律，官方博客已经有了比较完整的阐述，感兴趣的可以去看一下官方博客的文章。这里简单阐述一下：</p>
<h3 id="反射可以将-interface-类型变量转换成反射对象">反射可以将
<code>interface</code> 类型变量转换成反射对象。</h3>
<p>其实也就是上面的 <code>reflect.Type</code> 和
<code>reflect.Value</code>，我们可以通过 <code>reflect.TypeOf</code> 和
<code>reflect.ValueOf</code> 来获取到一个变量的反射类型和反射值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">typeOfA := reflect.TypeOf(a)</span><br><span class="line">valueOfA := reflect.ValueOf(a)</span><br></pre></td></tr></table></figure>
<h3
id="反射可以将反射对象还原成-interface-对象">反射可以将反射对象还原成
<code>interface</code> 对象。</h3>
<p>我们可以通过 <code>reflect.Value.Interface</code> 来获取到反射对象的
<code>interface</code> 对象，也就是传递给 <code>reflect.ValueOf</code>
的那个变量本身。 不过返回值类型是
<code>interface&#123;&#125;</code>，所以我们需要进行类型断言。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := valueOfA.Interface()</span><br><span class="line">fmt.Println(i.(<span class="type">int</span>))</span><br></pre></td></tr></table></figure>
<h3
id="如果要修改反射对象那么反射对象必须是可设置的canset">如果要修改反射对象，那么反射对象必须是可设置的（<code>CanSet</code>）。</h3>
<p>我们可以通过 <code>reflect.Value.CanSet</code>
来判断一个反射对象是否是可设置的。如果是可设置的，我们就可以通过
<code>reflect.Value.Set</code> 来修改反射对象的值。
这其实也是非常场景的使用反射的一个场景，通过反射来修改变量的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(&amp;x)</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet()) <span class="comment">// false</span></span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.Elem().CanSet()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>那什么情况下一个反射对象是可设置的呢？前提是这个反射对象是一个指针，然后这个指针指向的是一个可设置的变量。
在我们传递一个值给 <code>reflect.ValueOf</code>
的时候，如果这个值只是一个普通的变量，那么 <code>reflect.ValueOf</code>
会返回一个不可设置的反射对象。
因为这个值实际上被拷贝了一份，我们如果通过反射修改这个值，那么实际上是修改的这个拷贝的值，而不是原来的值。
所以 go 语言在这里做了一个限制，如果我们传递进
<code>reflect.ValueOf</code>
的变量是一个普通的变量，那么在我们设置反射对象的值的时候，会报错。
所以在上面这个例子中，我们传递了 <code>x</code>
的指针变量作为参数。这样，运行时就可以找到 <code>x</code> 本身，而不是
<code>x</code> 的拷贝，所以就可以修改 <code>x</code> 的值了。</p>
<p>但同时我们也注意到了，在上面这个例子中，<code>v.CanSet()</code>
返回的是 <code>false</code>，而 <code>v.Elem().CanSet()</code> 返回的是
<code>true</code>。 这是因为，<code>v</code> 是一个指针，而
<code>v.Elem()</code>
是指针指向的值，对于这个指针本身，我们修改它是没有意义的，我们可以设想一下，
如果我们修改了指针变量（也就是修改了指针变量指向的地址），那会发生什么呢？那样我们的指针变量就不是指向
<code>x</code> 了， 而是指向了其他的变量，这样就不符合我们的预期了。所以
<code>v.CanSet()</code> 返回的是 <code>false</code>。</p>
<p>而 <code>v.Elem().CanSet()</code> 返回的是
<code>true</code>。这是因为 <code>v.Elem()</code> 才是 <code>x</code>
本身，通过 <code>v.Elem()</code> 修改 <code>x</code>
的值是没有问题的。</p>
<figure>
<img src="/images/go/reflect/reflect_3.png" alt="reflect_3" />
<figcaption aria-hidden="true">reflect_3</figcaption>
</figure>
<h2 id="elem-方法">Elem 方法</h2>
<p>不知道有多少读者和我一样，在初次使用 go 的反射的时候，被
<code>Elem</code> 这个方法搞得一头雾水。 <code>Elem</code>
方法的作用是什么呢？在回答这个问题之前，我们需要明确一点：<code>reflect.Value</code>
和 <code>reflect.Type</code> 这两个反射对象都有 <code>Elem</code>
方法，既然是不同的对象，那么它们的作用自然是不一样的。</p>
<h3 id="reflect.value-的-elem-方法">reflect.Value 的 Elem 方法</h3>
<p><code>reflect.Value</code> 的 <code>Elem</code>
方法的作用是<strong>获取指针指向的值，或者获取接口的动态值</strong>。也就是说，能调用
<code>Elem</code> 方法的反射对象，必须是一个指针或者一个接口。
在使用其他类型的 <code>reflect.Value</code> 来调用 <code>Elem</code>
方法的时候，会 <code>panic</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// panic: reflect: call of reflect.Value.Elem on int Value</span></span><br><span class="line">reflect.ValueOf(a).Elem()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> b = &amp;a</span><br><span class="line">reflect.ValueOf(b).Elem()</span><br></pre></td></tr></table></figure>
<p>对于指针很好理解，其实作用类似解引用。而对于接口，还是要回到
<code>interface</code> 的结构本身，因为接口里包含了类型和数据本身，所以
<code>Elem</code> 方法就是获取接口的数据部分（也就是 <code>iface</code>
或 <code>eface</code> 中的 <code>data</code> 字段）。</p>
<p>指针类型：</p>
<figure>
<img src="/images/go/reflect/reflect_4.png" alt="reflect_4" />
<figcaption aria-hidden="true">reflect_4</figcaption>
</figure>
<p>接口类型：</p>
<figure>
<img src="/images/go/reflect/reflect_5.png" alt="reflect_5" />
<figcaption aria-hidden="true">reflect_5</figcaption>
</figure>
<h3 id="reflect.type-的-elem-方法">reflect.Type 的 Elem 方法</h3>
<p><code>reflect.Type</code> 的 <code>Elem</code>
方法的作用是<strong>获取数组、chan、map、指针、切片关联元素的类型信息</strong>，也就是说，对于
<code>reflect.Type</code> 来说， 能调用 <code>Elem</code>
方法的反射对象，必须是<strong>数组、chan、map、指针、切片中的一种</strong>，其他类型的
<code>reflect.Type</code> 调用 <code>Elem</code> 方法会
<code>panic</code>。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 := reflect.TypeOf([<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) <span class="comment">// 数组 [3]int</span></span><br><span class="line">fmt.Println(t1.String()) <span class="comment">// [3]int</span></span><br><span class="line">fmt.Println(t1.Elem().String()) <span class="comment">// int</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果我们要获取 map 类型 key 的类型信息，需要使用
<code>Key</code> 方法，而不是 <code>Elem</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">t1 := reflect.TypeOf(m)</span><br><span class="line">fmt.Println(t1.Key().String()) <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
<h2 id="interface-方法">Interface 方法</h2>
<p>这也是非常常用的一个方法，<code>reflect.Value</code> 的
<code>Interface</code>
方法的作用是<strong>获取反射对象的动态值</strong>。
也就是说，如果反射对象是一个指针，那么 <code>Interface</code>
方法会返回指针指向的值。</p>
<p>简单来说，如果 <code>var i interface&#123;&#125; = x</code>，那么
<code>reflect.ValueOf(x).Interface()</code> 就是 <code>i</code>
本身，只不过其类型是 <code>interface&#123;&#125;</code> 类型。</p>
<h2 id="kind">Kind</h2>
<p>说到反射，不得不提的另外一个话题就是 go
的类型系统，对于开发者来说，我们可以基于基本类型来定义各种新的类型，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kind 是 int</span></span><br><span class="line"><span class="keyword">type</span> myIny <span class="type">int</span></span><br><span class="line"><span class="comment">// Kind 是 Struct</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是不管我们定义了多少种类型，在 go
看来都是下面的基本类型中的一个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Kind <span class="type">uint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Invalid Kind = <span class="literal">iota</span></span><br><span class="line">	Bool</span><br><span class="line">	Int</span><br><span class="line">	Int8</span><br><span class="line">	Int16</span><br><span class="line">	Int32</span><br><span class="line">	Int64</span><br><span class="line">	Uint</span><br><span class="line">	Uint8</span><br><span class="line">	Uint16</span><br><span class="line">	Uint32</span><br><span class="line">	Uint64</span><br><span class="line">	Uintptr</span><br><span class="line">	Float32</span><br><span class="line">	Float64</span><br><span class="line">	Complex64</span><br><span class="line">	Complex128</span><br><span class="line">	Array</span><br><span class="line">	Chan</span><br><span class="line">	Func</span><br><span class="line">	Interface</span><br><span class="line">	Map</span><br><span class="line">	Pointer</span><br><span class="line">	Slice</span><br><span class="line">	String</span><br><span class="line">	Struct</span><br><span class="line">	UnsafePointer</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>也就是说，我们定义的类型在 go
的类型系统中都是基本类型的一种，这个基本类型就是 <code>Kind</code>。
也正因为如此，我们可以通过<strong>有限的</strong>
<code>reflect.Type</code> 的 <code>Kind</code> 来进行类型判断。
也就是说，我们在通过反射来判断变量的类型的时候，只需要枚举
<code>Kind</code> 中的类型，然后通过 <code>reflect.Type</code> 的
<code>Kind</code> 方法来判断即可。</p>
<blockquote>
<p>Type 表示的是反射对象（Type 对象是某一个 Kind，通过 Kind()
方法可以获取 Type 的 Kind），Kind 表示的是 go 底层类型系统中的类型。</p>
</blockquote>
<p>比如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(path <span class="type">string</span>, v reflect.Value)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s = invalid\n&quot;</span>, path)</span><br><span class="line">	<span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.Len(); i++ &#123;</span><br><span class="line">			display(fmt.Sprintf(<span class="string">&quot;%s[%d]&quot;</span>, path, i), v.Index(i))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Struct:</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">			fieldPath := fmt.Sprintf(<span class="string">&quot;%s.%s&quot;</span>, path, v.Type().Field(i).Name)</span><br><span class="line">			display(fieldPath, v.Field(i))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Map:</span><br><span class="line">		<span class="keyword">for</span> _, key := <span class="keyword">range</span> v.MapKeys() &#123;</span><br><span class="line">			display(fmt.Sprintf(<span class="string">&quot;%s[%s]&quot;</span>, path, formatAny(key)), v.MapIndex(key))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Pointer:</span><br><span class="line">		<span class="keyword">if</span> v.IsNil() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s = nil\n&quot;</span>, path)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			display(fmt.Sprintf(<span class="string">&quot;(*%s)&quot;</span>, path), v.Elem())</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Interface:</span><br><span class="line">		<span class="keyword">if</span> v.IsNil() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s = nil\n&quot;</span>, path)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s.type = %s\n&quot;</span>, path, v.Elem().Type())</span><br><span class="line">			display(path+<span class="string">&quot;.value&quot;</span>, v.Elem())</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s = %s\n&quot;</span>, path, formatAny(v))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们在开发的时候非常常用的结构体，在 go 的类型系统中，通通都是
<code>Struct</code> 这种类型的。</p>
</blockquote>
<h2 id="addressable">addressable</h2>
<p>go 反射中最后一个很重要的话题是 <code>addressable</code>。在 go
的反射系统中有两个关于寻址的方法：<code>CanAddr</code> 和
<code>CanSet</code>。</p>
<p><code>CanAddr</code>
方法的作用是判断反射对象是否可以寻址，也就是说，如果
<code>CanAddr</code> 返回 <code>true</code>，那么我们就可以通过
<code>Addr</code> 方法来获取反射对象的地址。 如果 <code>CanAddr</code>
返回 <code>false</code>，那么我们就不能通过 <code>Addr</code>
方法来获取反射对象的地址。对于这种情况，我们就无法通过反射对象来修改变量的值。</p>
<p>但是，<code>CanAddr</code> 是 <code>true</code> 并不是说
<code>reflect.Value</code> 一定就能修改变量的值了。
<code>reflect.Value</code> 还有一个方法 <code>CanSet</code>，只有
<code>CanSet</code> 返回
<code>true</code>，我们才能通过反射对象来修改变量的值。</p>
<p>那么 <code>CanAddr</code> 背后的含义是什么呢？它意味着我们传递给
<code>reflect.ValueOf</code> 的变量是不是可以寻址的。
<strong>也就是说，我们的反射值对象拿到的是不是变量本身，而不是变量的副本。</strong>
如果我们是通过 <code>&amp;v</code> 这种方式来创建反射对象的，那么
<code>CanAddr</code> 就会返回 <code>true</code>， 反之，如果我们是通过
<code>v</code> 这种方式来创建反射对象的，那么 <code>CanAddr</code>
就会返回 <code>false</code>。</p>
<p>如果想更详细的了解可以参考一下鸟窝的这篇文章 <a
target="_blank" rel="noopener" href="https://colobu.com/2018/02/27/go-addressable/">go addressable
详解</a>。</p>
<h2 id="获取类型信息---reflect.type">获取类型信息 - reflect.Type</h2>
<h3 id="概述">概述</h3>
<p><code>reflect.Type</code> 是一个接口，它代表了一个类型。我们可以通过
<code>reflect.TypeOf</code> 来获取一个类型的 <code>reflect.Type</code>
对象。 我们使用 <code>reflect.Type</code>
的目的通常是为了获取类型的信息，比如类型是什么、类型的名称、类型的字段、类型的方法等等。
又或者最常见的场景：结构体中的 <code>json</code> 的
<code>tag</code>，它是没有语义的，它的作用就是为了在序列化的时候，生成我们想要的字段名。
而这个 <code>tag</code> 就是需要通过反射来获取的。</p>
<h3 id="通用的-type-方法">通用的 Type 方法</h3>
<p>在 go 的反射系统中，是使用 <code>reflect.Type</code>
这个接口来获取类型信息的。<code>reflect.Type</code>
这个接口有很多方法，下面这些方法是所有的类型通用的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type 是 Go 类型的表示。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 并非所有方法都适用于所有类型。</span></span><br><span class="line"><span class="comment">// 在调用 kind 具体方法之前，先使用 Kind 方法找出类型的种类。因为调用一个方法如果类型不匹配会导致 panic</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Type 类型值是可以比较的，比如用 == 操作符。所以它可以用做 map 的 key</span></span><br><span class="line"><span class="comment">// 如果两个 Type 值代表相同的类型，那么它们一定是相等的。</span></span><br><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Align 返回该类型在内存中分配时，以字节数为单位的字节数</span></span><br><span class="line">	Align() <span class="type">int</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// FieldAlign 返回该类型在结构中作为字段使用时，以字节数为单位的字节数</span></span><br><span class="line">	FieldAlign() <span class="type">int</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Method 这个方法返回类型方法集中的第 i 个方法。</span></span><br><span class="line">	<span class="comment">// 如果 i 不在[0, NumMethod()]范围内，就会 panic。</span></span><br><span class="line">	<span class="comment">// 对于非接口类型 T 或 *T，返回的 Method 的 Type 和 Func 字段描述了一个函数，</span></span><br><span class="line">	<span class="comment">// 其第一个参数是接收者，并且只能访问导出的方法。</span></span><br><span class="line">	<span class="comment">// 对于一个接口类型，返回的 Method 的 Type 字段给出的是方法签名，没有接收者，Func字段为nil。</span></span><br><span class="line">	<span class="comment">// 方法是按字典序顺序排列的。</span></span><br><span class="line">	Method(<span class="type">int</span>) Method</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MethodByName 返回类型的方法集中具有该名称的方法和一个指示是否找到该方法的布尔值。</span></span><br><span class="line">	<span class="comment">// 对于非接口类型 T 或 *T，返回的 Method 的 Type 和 Func 字段描述了一个函数，</span></span><br><span class="line">	<span class="comment">// 其第一个参数是接收者。</span></span><br><span class="line">	<span class="comment">// 对于一个接口类型，返回的 Method 的 Type 字段给出的是方法签名，没有接收者，Func字段为nil。</span></span><br><span class="line">	MethodByName(<span class="type">string</span>) (Method, <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumMethod 返回使用 Method 可以访问的方法数量。</span></span><br><span class="line">	<span class="comment">// 对于非接口类型，它返回导出方法的数量。</span></span><br><span class="line">	<span class="comment">// 对于接口类型，它返回导出和未导出方法的数量。</span></span><br><span class="line">	NumMethod() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Name 返回定义类型在其包中的类型名称。</span></span><br><span class="line">	<span class="comment">// 对于其他（未定义的）类型，它返回空字符串。</span></span><br><span class="line">	Name() <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// PkgPath 返回一个定义类型的包的路径，也就是导入路径，导入路径是唯一标识包的类型，如 &quot;encoding/base64&quot;。</span></span><br><span class="line">	<span class="comment">// 如果类型是预先声明的(string, error)或者没有定义(*T, struct&#123;&#125;, []int，或 A，其中 A 是一个非定义类型的别名），包的路径将是空字符串。</span></span><br><span class="line">	PkgPath() <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Size 返回存储给定类型的值所需的字节数。它类似于 unsafe.Sizeof.</span></span><br><span class="line">	Size() <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// String 返回该类型的字符串表示。</span></span><br><span class="line">	<span class="comment">// 字符串表示法可以使用缩短的包名。</span></span><br><span class="line">	<span class="comment">// (例如，使用 base64 而不是 &quot;encoding/base64&quot;)并且它并不能保证类型之间是唯一的。如果是为了测试类型标识，应该直接比较类型 Type。</span></span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Kind 返回该类型的具体种类。</span></span><br><span class="line">	Kind() Kind</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Implements 表示该类型是否实现了接口类型 u。</span></span><br><span class="line">	Implements(u Type) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// AssignableTo 表示该类型的值是否可以分配给类型 u。</span></span><br><span class="line">	AssignableTo(u Type) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ConvertibleTo 表示该类型的值是否可转换为 u 类型。</span></span><br><span class="line">	ConvertibleTo(u Type) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Comparable 表示该类型的值是否具有可比性。</span></span><br><span class="line">	Comparable() <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="某些类型特定的-type-方法">某些类型特定的 Type 方法</h3>
<p>下面是某些类型特定的方法，对于这些方法，如果我们使用的类型不对，则会
<code>panic</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Bits 以 bits 为单位返回类型的大小。</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不属于：sized 或者 unsized Int, Uint, Float, 或者 Complex，会 panic。</span></span><br><span class="line">	Bits() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ChanDir 返回一个通道类型的方向。</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不是 Chan，会 panic。</span></span><br><span class="line">	ChanDir() ChanDir</span><br><span class="line"></span><br><span class="line">	<span class="comment">// IsVariadic 表示一个函数类型的最终输入参数是否为一个 &quot;...&quot; 可变参数。如果是，t.In(t.NumIn() - 1) 返回参数的隐式实际类型 []T.</span></span><br><span class="line">	<span class="comment">// 更具体的，如果 t 代表 func(x int, y ... float64)，那么：</span></span><br><span class="line">	<span class="comment">// t.NumIn() == 2</span></span><br><span class="line">	<span class="comment">// t.In(0)是 &quot;int&quot; 的 reflect.Type 反射类型。</span></span><br><span class="line">	<span class="comment">// t.In(1)是 &quot;[]float64&quot; 的 reflect.Type 反射类型。</span></span><br><span class="line">	<span class="comment">// t.IsVariadic() == true</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不是 Func，IsVariadic 会 panic</span></span><br><span class="line">	IsVariadic() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Elem 返回一个 type 的元素类型。</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不是 Array、Chan、Map、Ptr 或 Slice，就会 panic</span></span><br><span class="line">	Elem() Type</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Field 返回一个结构类型的第 i 个字段。</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不是 Struct，就会 panic。</span></span><br><span class="line">	<span class="comment">// 如果 i 不在 [0, NumField()) 范围内也会 panic。</span></span><br><span class="line">	Field(i <span class="type">int</span>) StructField</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FieldByIndex 返回索引序列对应的嵌套字段。它相当于对每一个 index 调用 Field。</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不是 Struct，就会 panic。</span></span><br><span class="line">	FieldByIndex(index []<span class="type">int</span>) StructField</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FieldByName 返回给定名称的结构字段和一个表示是否找到该字段的布尔值。</span></span><br><span class="line">	FieldByName(name <span class="type">string</span>) (StructField, <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FieldByNameFunc 返回一个能满足 match 函数的带有名称的 field 字段。布尔值表示是否找到。</span></span><br><span class="line">	FieldByNameFunc(match <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">bool</span>) (StructField, <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// In 返回函数类型的第 i 个输入参数的类型。</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不是 Func 类型会 panic。</span></span><br><span class="line">	<span class="comment">// 如果 i 不在 [0, NumIn()) 的范围内，会 panic。</span></span><br><span class="line">	In(i <span class="type">int</span>) Type</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Key 返回一个 map 类型的 key 类型。</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不是 Map，会 panic。</span></span><br><span class="line">	Key() Type</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Len 返回一个数组类型的长度。</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不是 Array，会 panic。</span></span><br><span class="line">	Len() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumField 返回一个结构类型的字段数目。</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不是 Struct，会 panic。</span></span><br><span class="line">	NumField() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumIn 返回一个函数类型的输入参数数。</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不是Func.NumIn()，会 panic。</span></span><br><span class="line">	NumIn() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumOut 返回一个函数类型的输出参数数。</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不是 Func.NumOut()，会 panic。</span></span><br><span class="line">	NumOut() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Out 返回一个函数类型的第 i 个输出参数的类型。</span></span><br><span class="line">	<span class="comment">// 如果类型的 Kind 不是 Func，会 panic。</span></span><br><span class="line">	<span class="comment">// 如果 i 不在 [0, NumOut()) 的范围内，会 panic。</span></span><br><span class="line">	Out(i <span class="type">int</span>) Type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建-reflect.type-的方式">创建 reflect.Type 的方式</h3>
<p>我们可以通过下面的方式来获取变量的类型信息（创建
<code>reflect.Type</code> 的方式）：</p>
<figure>
<img src="/images/go/reflect/reflect_6.png" alt="reflect_6" />
<figcaption aria-hidden="true">reflect_6</figcaption>
</figure>
<h2 id="获取值信息---reflect.value">获取值信息 - reflect.Value</h2>
<h3 id="概述-1">概述</h3>
<p><code>reflect.Value</code> 是一个结构体，它代表了一个值。 我们使用
<code>reflect.Value</code>
可以实现一些接收多种类型参数的函数，又或者可以让我们在运行时针对值的一些信息来进行修改。
常常用在接收 <code>interface&#123;&#125;</code>
类型参数的方法中，因为参数是接口类型，所以我们可以通过
<code>reflect.ValueOf</code> 来获取到参数的值信息。
比如类型、大小、结构体字段、方法等等。</p>
<p>同时，我们可以对这些获取到的反射值进行修改。这也是反射的一个重要用途。</p>
<h3 id="reflect.value-的方法">reflect.Value 的方法</h3>
<p><code>reflect.Value</code> 这个 <code>Sreuct</code>
同样有很多方法：具体可以分为以下几类：</p>
<ol type="1">
<li>设置值的方法：<code>Set*</code>：<code>Set</code>、<code>SetBool</code>、<code>SetBytes</code>、<code>SetCap</code>、<code>SetComplex</code>、<code>SetFloat</code>、<code>SetInt</code>、<code>SetLen</code>、<code>SetMapIndex</code>、<code>SetPointer</code>、<code>SetString</code>、<code>SetUint</code>。通过这类方法，我们可以修改反射值的内容，前提是这个反射值得是合适的类型。<strong>CanSet
返回 true 才能调用这类方法</strong></li>
<li>获取值的方法：<code>Interface</code>、<code>InterfaceData</code>、<code>Bool</code>、<code>Bytes</code>、<code>Complex</code>、<code>Float</code>、<code>Int</code>、<code>String</code>、<code>Uint</code>。通过这类方法，我们可以获取反射值的内容。前提是这个反射值是合适的类型，比如我们不能通过
<code>complex</code> 反射值来调用 <code>Int</code> 方法（我们可以通过
<code>Kind</code> 来判断类型）。</li>
<li>map
类型的方法：<code>MapIndex</code>、<code>MapKeys</code>、<code>MapRange</code>、<code>MapSet</code>。</li>
<li>chan
类型的方法：<code>Close</code>、<code>Recv</code>、<code>Send</code>、<code>TryRecv</code>、<code>TrySend</code>。</li>
<li>slice
类型的方法：<code>Len</code>、<code>Cap</code>、<code>Index</code>、<code>Slice</code>、<code>Slice3</code>。</li>
<li>struct
类型的方法：<code>NumField</code>、<code>NumMethod</code>、<code>Field</code>、<code>FieldByIndex</code>、<code>FieldByName</code>、<code>FieldByNameFunc</code>。</li>
<li>判断是否可以设置为某一类型：<code>CanConvert</code>、<code>CanComplex</code>、<code>CanFloat</code>、<code>CanInt</code>、<code>CanInterface</code>、<code>CanUint</code>。</li>
<li>方法类型的方法：<code>Method</code>、<code>MethodByName</code>、<code>Call</code>、<code>CallSlice</code>。</li>
<li>判断值是否有效：<code>IsValid</code>。</li>
<li>判断值是否是 <code>nil</code>：<code>IsNil</code>。</li>
<li>判断值是否是零值：<code>IsZero</code>。</li>
<li>判断值能否容纳下某一类型的值：<code>Overflow</code>、<code>OverflowComplex</code>、<code>OverflowFloat</code>、<code>OverflowInt</code>、<code>OverflowUint</code>。</li>
<li>反射值指针相关的方法：<code>Addr</code>（<code>CanAddr</code> 为
<code>true</code>
才能调用）、<code>UnsafeAddr</code>、<code>Pointer</code>、<code>UnsafePointer</code>。</li>
<li>获取类型信息：<code>Type</code>、<code>Kind</code>。</li>
<li>获取指向元素的值：<code>Elem</code>。</li>
<li>类型转换：<code>Convert</code>。</li>
</ol>
<blockquote>
<p><code>Len</code> 也适用于
<code>slice</code>、<code>array</code>、<code>chan</code>、<code>map</code>、<code>string</code>
类型的反射值。</p>
</blockquote>
<h3 id="创建-reflect.value-的方式">创建 reflect.Value 的方式</h3>
<p>我们可以通过下面的方式来获取变量的值信息（创建
<code>reflect.Value</code> 的方式）：</p>
<figure>
<img src="/images/go/reflect/reflect_7.png" alt="reflect_7" />
<figcaption aria-hidden="true">reflect_7</figcaption>
</figure>
<h2 id="总结">总结</h2>
<ul>
<li><code>reflect</code>
包提供了反射机制，可以在运行时获取变量的类型信息、值信息、方法信息等等。</li>
<li>go 中的 <code>interface&#123;&#125;</code>
实际上包含了两个指针，一个指向类型信息，一个指向值信息。正因如此，我们可以在运行时通过
<code>interface&#123;&#125;</code> 来获取变量的类型信息、值信息。</li>
<li><code>reflect.Type</code> 代表一个类型，<code>reflect.Value</code>
代表一个值。通过 <code>reflect.Type</code> 可以获取类型信息，通过
<code>reflect.Value</code> 可以获取值信息。</li>
<li>反射三定律：
<ul>
<li>反射可以将 <code>interface</code> 类型变量转换成反射对象。</li>
<li>反射可以将反射对象还原成 <code>interface</code> 对象。</li>
<li>如果要修改反射对象，那么反射对象必须是可设置的（<code>CanSet</code>）。</li>
</ul></li>
<li><code>reflect.Value</code> 和 <code>reflect.Type</code> 里面都有
<code>Elem</code> 方法，但是它们的作用不一样：
<ul>
<li><code>reflect.Type</code> 的 <code>Elem</code>
方法返回的是元素类型，只适用于 array、chan、map、pointer 和 slice 类型的
<code>reflect.Type</code>。</li>
<li><code>reflect.Value</code> 的 <code>Elem</code>
方法返回的是值，只适用于接口或指针类型的
<code>reflect.Value</code>。</li>
</ul></li>
<li>通过 <code>reflect.Value</code> 的 <code>Interface</code>
方法可以获取到反射对象的原始变量，但是是 <code>interface&#123;&#125;</code>
类型的。</li>
<li><code>Type</code> 和 <code>Kind</code> 都表示类型，但是
<code>Type</code> 是类型的反射对象，<code>Kind</code> 是 go
类型系统中最基本的一些类型，比如
<code>int</code>、<code>string</code>、<code>struct</code> 等等。</li>
<li>如果我们想通过 <code>reflect.Value</code> 来修改变量的值，那么
<code>reflect.Value</code>
必须是可设置的（<code>CanSet</code>）。同时如果想要 <code>CanSet</code>
为 true，那么我们的变量必须是可寻址的。</li>
<li>我们有很多方法可以创建 <code>reflect.Type</code> 和
<code>reflect.Value</code>，我们需要根据具体的场景来选择合适的方法。</li>
<li><code>reflect.Type</code> 和 <code>reflect.Value</code>
里面，都有一部分方法是通用的，也有一部分只适用于特定的类型。如果我们想要调用那些适用于特定类型的方法，那么我们必须先判断
<code>reflect.Type</code> 或 <code>reflect.Value</code>
的类型（这里说的是 <code>Kind</code>），然后再调用。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/12/27/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20sync.WaitGroup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/27/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20sync.WaitGroup/" class="post-title-link" itemprop="url">深入理解 go sync.Waitgroup</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-27 20:28:30" itemprop="dateCreated datePublished" datetime="2022-12-27T20:28:30+08:00">2022-12-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文基于 Go 1.19。</p>
</blockquote>
<p>go 里面的 <code>WaitGroup</code>
是非常常见的一种并发控制方式，它可以让我们的代码等待一组 goroutine
的结束。 比如在主协程中等待几个子协程去做一些耗时的操作，如发起几个 HTTP
请求，然后等待它们的结果。</p>
<h2 id="waitgroup-示例">WaitGroup 示例</h2>
<p>下面的代码展示了一个 goroutine 等待另外 2 个 goroutine
结束的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWaitgroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="comment">// 计数器 +2</span></span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		sendHttpRequest(<span class="string">&quot;https://baidu.com&quot;</span>)</span><br><span class="line">		<span class="comment">// 计数器 -1</span></span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		sendHttpRequest(<span class="string">&quot;https://baidu.com&quot;</span>)</span><br><span class="line">		<span class="comment">// 计数器 -1</span></span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 阻塞。计数器为 0 的时候，Wait 返回</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起 HTTP GET 请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendHttpRequest</span><span class="params">(url <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	method := <span class="string">&quot;GET&quot;</span></span><br><span class="line"></span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	req, err := http.NewRequest(method, url, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err := client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"></span><br><span class="line">	body, err := io.ReadAll(res.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(body), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们做了如下事情：</p>
<ul>
<li>定义了一个 <code>WaitGroup</code> 对象 <code>wg</code>，调用
<code>wg.Add(2)</code> 将其计数器 <code>+2</code>。</li>
<li>启动两个新的 goroutine，在这两个 goroutine 中，使用
<code>sendHttpRequest</code> 函数发起了一个 HTTP 请求。</li>
<li>在 HTTP 请求返回之后，调用 <code>wg.Done</code> 将计数器
<code>-1</code>。</li>
<li>在函数的最后，我们调用了 <code>wg.Wait</code>，这个方法会阻塞，直到
<code>WaitGroup</code> 的计数器的值为 0 才会解除阻塞状态。</li>
</ul>
<h2 id="waitgroup-基本原理">WaitGroup 基本原理</h2>
<p><code>WaitGroup</code>
内部通过一个计数器来统计有多少协程被等待。这个计数器的值在我们启动
goroutine 之前先写入（使用 <code>Add</code> 方法）， 然后在 goroutine
结束的时候，将这个计数器减 1（使用 <code>Done</code>
方法）。除此之外，在启动这些 goroutine 的协程中， 会调用
<code>Wait</code> 来进行等待，在 <code>Wait</code>
调用的地方会阻塞，直到 <code>WaitGroup</code> 内部的计数器减到 0。
<strong>也就实现了等待一组 goroutine 的目的</strong></p>
<h2 id="背景知识">背景知识</h2>
<p>在操作系统中，有多种实现进程/线程间同步的方式，如：<code>test_and_set</code>、<code>compare_and_swap</code>、互斥锁等。
除此之外，还有一种是<strong>信号量</strong>，它的功能类似于互斥锁，但是它能提供更为高级的方法，以便进程能够同步活动。</p>
<h3 id="信号量">信号量</h3>
<p>一个<strong>信号量（semaphore）S</strong>是一个整型变量，它除了初始化外只能通过两个标准的原子操作：<code>wait()</code>
和 <code>signal()</code> 来访问。 操作 <code>wait()</code> 最初称为
<code>P</code>（荷兰语 <code>proberen</code>，测试）；操作
<code>signal()</code> 最初称为 <code>V</code>（荷兰语
<code>verhogen</code>，增加），可按如下来定义 <code>wait()</code>：</p>
<blockquote>
<p>PV 原语。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line">    while (S &lt;= 0)</span><br><span class="line">        ; // 忙等待</span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可按如下来定义 <code>signal()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S) &#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>wait()</code> 和 <code>signal()</code>
操作中，信号量整数值的修改应不可分割地执行。也就是说，当一个进程修改信号量值时，没有其他进程能够同时修改同一信号量的值。</p>
<p>简单来说，信号量实现的功能是：</p>
<ul>
<li>当信号量&gt;0 时，表示资源可用，则 <code>wait</code>
会对信号量执行减 1 操作。</li>
<li>当信号量&lt;=0
时，表示资源暂时不可用，获取信号量时，当前的进程/线程会阻塞，直到信号量为正时被唤醒。</li>
</ul>
<h3 id="waitgroup-中的信号量">WaitGroup 中的信号量</h3>
<p>在 <code>WaitGroup</code> 中，使用了信号量来实现 goroutine
的阻塞以及唤醒：</p>
<ul>
<li>在调用 <code>Wait</code> 的地方，goroutine
会陷入阻塞，直到信号量大于等于 0 的时候解除阻塞状态，得以继续执行。</li>
<li>在调用 <code>Done</code> 的时候，如果 <code>WaitGroup</code>
内的等待协程的计数器减到 0
的时候，信号量会进行递增，这样那些阻塞的协程会进行执行下去。</li>
</ul>
<h2 id="waitgroup-数据结构">WaitGroup 数据结构</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 高 32 位为计数器，低 32 位为等待者数量</span></span><br><span class="line">	state atomic.Uint64</span><br><span class="line">	sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="nocopy">noCopy</h3>
<p>我们发现，<code>WaitGroup</code> 中有一个字段
<code>noCopy</code>，顾名思义，它的目的是防止复制。
这个字段在运行时是没有什么影响的，但是我们通过 <code>go vet</code>
可以发现我们对 <code>WaitGroup</code> 的复制。
为什么不能复制呢？因为一旦复制，<code>WaitGroup</code>
内的计数器就不再准确了，比如下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWaitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	test(wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>go 里面的函数参数传递是值传递。调用 test(wg) 的时候将
<code>WaitGroup</code> 复制了一份。</p>
</blockquote>
<p>在这个例子中，程序会永远阻塞下去，因为 <code>test</code> 中调用
<code>wg.Done()</code> 的时候，只是将 <code>WaitGroup</code>
副本的计数器减去了 1， 而 <code>TestWaitGroup</code> 里面的
<code>WaitGroup</code> 的计数器并没有发生改变，因此 <code>Wait</code>
会永远阻塞。</p>
<p>我们如果需要将 <code>WaitGroup</code> 作为参数，请传递指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递指针之后，我们在 <code>test</code> 中调用 <code>wg.Done()</code>
修改的就是 <code>TestWaitGroup</code> 里面同一个
<code>WaitGroup</code>。 从而，<code>Wait</code> 方法可以正常返回。</p>
<h3 id="state">state</h3>
<p><code>WaitGroup</code> 里面的 <code>state</code> 是一个 64 位的
<code>atomic.Uint64</code> 类型，它的高 32 位用来保存
<code>counter</code>（也就是上面说的计数器），低 32 位用来保存
<code>waiter</code>（也就是阻塞在 <code>Wait</code> 上的 goroutine
数量。）</p>
<figure>
<img src="/images/go/sync/waitgroup_1.png" alt="waitgroup_1" />
<figcaption aria-hidden="true">waitgroup_1</figcaption>
</figure>
<h3 id="sema">sema</h3>
<p><code>WaitGroup</code> 通过 <code>sema</code> 来记录信号量：</p>
<ul>
<li><code>runtime_Semrelease</code> 表示将信号量递增（对应信号量中的
<code>signal</code> 操作）</li>
<li><code>runtime_Semacquire</code> 表示将信号量递减（对应信号量中的
<code>wait</code> 操作）</li>
</ul>
<p>简单来说，在调用 <code>runtime_Semacquire</code> 的时候 goroutine
会阻塞，而调用 <code>runtime_Semrelease</code>
会唤醒阻塞在同一个信号量上的 goroutine。</p>
<h2 id="waitgroup-的三个基本操作">WaitGroup 的三个基本操作</h2>
<ul>
<li><code>Add</code>: 这会将 <code>WaitGroup</code> 里面的
<code>counter</code> 加上一个整数（也就是传递给 <code>Add</code>
的函数参数）。</li>
<li><code>Done</code>: 这会将 <code>WaitGroup</code> 里面的
<code>counter</code> 减去 1。</li>
<li><code>Wait</code>: 这会将 <code>WaitGroup</code> 里面的
<code>waiter</code> 加上 1，并且调用 <code>Wait</code>
的地方会阻塞。（<strong>有可能会有多个 goroutine 等待一个
<code>WaitGroup</code></strong>）</li>
</ul>
<h2 id="waitgroup-的实现">WaitGroup 的实现</h2>
<h3 id="add-的实现">Add 的实现</h3>
<p><code>Add</code> 做了下面两件事：</p>
<ol type="1">
<li>将 <code>delta</code> 加到 <code>state</code> 的高 32 位上</li>
<li>如果 <code>counter</code> 为 <code>0</code> 了，并且
<code>waiter</code> 大于 0，表示所有被等待的 goroutine
都完成了，而还有在等待的 goroutine，这会唤醒那些阻塞在 <code>Wait</code>
上的 goroutine。</li>
</ol>
<p>源码实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// wg.state 的计数器加上 delta</span></span><br><span class="line">	<span class="comment">//（加到 state 的高 32 上）</span></span><br><span class="line">	state := wg.state.Add(<span class="type">uint64</span>(delta) &lt;&lt; <span class="number">32</span>) <span class="comment">// 高 32 位加上 delta</span></span><br><span class="line">	v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)                    <span class="comment">// 高 32 位（counter）</span></span><br><span class="line">	w := <span class="type">uint32</span>(state)                         <span class="comment">// 低 32 位（waiter）</span></span><br><span class="line">	<span class="comment">// 计数器不能为负数（加上 delta 之后不能为负数，最小只能到 0）</span></span><br><span class="line">	<span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 正常使用情况下，是先调用 Add 再调用 Wait 的，这种情况下，w 是 0，v &gt; 0</span></span><br><span class="line">	<span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="type">int32</span>(delta) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// v &gt; 0，计数器大于 0</span></span><br><span class="line">	<span class="comment">// w == 0，没有在 Wait 的协程</span></span><br><span class="line">	<span class="comment">// 说明还没有到唤醒 waiter 的时候</span></span><br><span class="line">	<span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add 负数的时候，v 会减去对应的数值，减到最后 v 是 0。</span></span><br><span class="line">	<span class="comment">// 计数器是 0，并且有等待的协程，现在要唤醒这些协程。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存在等待的协程时，goroutine 已将计数器设置为0。</span></span><br><span class="line">	<span class="comment">// 现在不可能同时出现状态突变：</span></span><br><span class="line">	<span class="comment">// - Add 不能与 Wait 同时发生，</span></span><br><span class="line">	<span class="comment">// - 如果看到计数器==0，则 Wait 不会增加等待的协程。</span></span><br><span class="line">	<span class="comment">// 仍然要做一个廉价的健康检查，以检测 WaitGroup 的误用。</span></span><br><span class="line">	<span class="keyword">if</span> wg.state.Load() != state &#123; <span class="comment">// 不能在 Add 的同时调用 Wait</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将等待的协程数量设置为 0。</span></span><br><span class="line">	wg.state.Store(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">		<span class="comment">// signal，调用 Wait 的地方会解除阻塞</span></span><br><span class="line">		runtime_Semrelease(&amp;wg.sema, <span class="literal">false</span>, <span class="number">0</span>) <span class="comment">// goyield</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="done-的实现">Done 的实现</h3>
<p><code>WaitGroup</code> 里的 <code>Done</code> 其实只是对
<code>Add</code> 的调用，但是它的效果是，<strong>将计数器的值减去
<code>1</code></strong>。
背后的含义是：<strong>一个被等待的协程执行完毕了</strong>。</p>
<h3 id="wait-的实现">Wait 的实现</h3>
<p><code>Wait</code> 主要功能是阻塞当前的协程：</p>
<ol type="1">
<li><code>Wait</code> 会先判断计数器是否为 <code>0</code>，为
<code>0</code> 说明没有任何需要等待的协程，那么就可以直接返回了。</li>
<li>如果计数器还不是 <code>0</code>，说明有协程还没执行完，那么调用
<code>Wait</code> 的地方就需要被阻塞起来，等待所有的协程完成。</li>
</ol>
<p>源码实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 获取当前计数器</span></span><br><span class="line">		state := wg.state.Load()</span><br><span class="line">		<span class="comment">// 计数器</span></span><br><span class="line">		v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">		<span class="comment">// waiter 数量</span></span><br><span class="line">		w := <span class="type">uint32</span>(state)</span><br><span class="line">		<span class="comment">// v 为 0，不需要等待，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 计数器是 0，不需要等待</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 增加 waiter 数量。</span></span><br><span class="line">		<span class="comment">// 调用一次 Wait，waiter 数量会加 1。</span></span><br><span class="line">		<span class="keyword">if</span> wg.state.CompareAndSwap(state, state+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 这会阻塞，直到 sema (信号量)大于 0</span></span><br><span class="line">			runtime_Semacquire(&amp;wg.sema) <span class="comment">// goparkunlock</span></span><br><span class="line">			<span class="comment">// state 不等 0</span></span><br><span class="line">			<span class="comment">// wait 还没有返回又继续使用了 WaitGroup</span></span><br><span class="line">			<span class="keyword">if</span> wg.state.Load() != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 解除阻塞状态了，可以返回了</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 状态没有修改成功（state 没有成功 +1），开始下一次尝试。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><code>WaitGroup</code>
使用了信号量来实现了并发资源控制，<code>sema</code>
字段表示信号量。</li>
<li>使用 <code>runtime_Semacquire</code> 会使得 goroutine
阻塞直到计数器减少至 <code>0</code>，而使用
<code>runtime_Semrelease</code>
会使得信号量递增，这等于是通知之前阻塞在信号量上的协程，告诉它们可以继续执行了。</li>
<li><code>WaitGroup</code>
作为参数传递的时候，需要传递指针作为参数，否则在被调用函数内对
<code>Add</code> 或者 <code>Done</code> 的调用，在 <code>caller</code>
里面调用的 <code>Wait</code> 会观测不到。</li>
<li><code>WaitGroup</code> 使用一个 64 位的数来保存计数器（高 32 位）和
<code>waiter</code>（低 32 位，正在等待的协程的数量）。</li>
<li><code>WaitGroup</code> 使用 <code>Add</code> 增加计数器，使用
<code>Done</code> 来将计数器减 <code>1</code>，使用 <code>Wait</code>
来等待 goroutine。<code>Wait</code> 会阻塞直到计数器减少到
<code>0</code>。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/12/26/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20sync.Once/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/26/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20sync.Once/" class="post-title-link" itemprop="url">深入理解 go sync.Once</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-26 20:08:30" itemprop="dateCreated datePublished" datetime="2022-12-26T20:08:30+08:00">2022-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在很多情况下，我们可能需要控制某一段代码只执行一次，比如做某些初始化操作，如初始化数据库连接等。
对于这种场景，go 为我们提供了 <code>sync.Once</code>
对象，它保证了某个动作只被执行一次。 当然我们也是可以自己通过
<code>Mutex</code> 实现 <code>sync.Once</code>
的功能，但是相比来说繁琐了那么一点，
因为我们不仅要自己去控制锁，还要通过一个标识来标志是否已经执行过。</p>
<h2 id="once-的实现">Once 的实现</h2>
<p><code>Once</code> 的实现非常简单，如下，就只有 20
来行代码，但里面包含了 go 并发、同步的一些常见处理方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sync</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	done <span class="type">uint32</span></span><br><span class="line">	m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">		o.doSlow(f)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> doSlow(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	o.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简要说明：</p>
<ul>
<li><code>done</code> 字段指示了操作是否已执行，也就是我们传递给
<code>Do</code> 的函数是否已经被执行。</li>
<li><code>Do</code>
方法接收一个函数参数，这个函数参数只会被执行一次。</li>
<li><code>Once</code> 内部是通过 <code>Mutex</code>
来实现不同协程之间的同步的。</li>
</ul>
<h2 id="使用示例">使用示例</h2>
<p>在下面的例子中，<code>once.Do(test)</code> 被执行了 3 次，但是最终
<code>test</code> 只被执行了一次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sync</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOnce</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// once.Do 会调用 3 次，但最终只会执行一次</span></span><br><span class="line">			once.Do(test)</span><br><span class="line"></span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Println(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="once-的一些工作机制">Once 的一些工作机制</h2>
<ol type="1">
<li><p><code>Once</code> 的 <code>Do</code> 方法可以保证，在多个
goroutine 同时执行 <code>Do</code> 方法的时候， 在第一个抢占到
<code>Do</code> 执行权的 goroutine 执行返回之前，其他 goroutine
都会阻塞在 <code>Once.Do</code> 的调用上， 只有第一个 <code>Do</code>
调用返回的时候，其他 goroutine 才可以继续执行下去，并且其他所有的
goroutine 不会再执行传递给 <code>Do</code>
的函数。（如果是初始化的场景，这可以避免尚未初始化完成就执行其他的操作）</p></li>
<li><p>如果 <code>Once.Do</code> 发生 <code>panic</code> 的时候，传递给
<code>Do</code> 的函数依然被标记为已完成。后续对 <code>Do</code>
的调用也不会再执行传给 <code>Do</code> 的函数参数。</p></li>
<li><p>我们不能简单地通过 <code>atomic.CompareAndSwapUint32</code>
来决定是否执行 <code>f()</code>，因为在多个 goroutine
同时执行的时候，它无法保证 <code>f()</code> 只被执行一次。所以
<code>Once</code> 里面用了
<code>Mutex</code>，这样就可以有效地保护临界区。</p></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误实现，这不能保证 f 只被执行一次</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint32(&amp;o.done, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><code>Once.Do</code>
的函数参数是没有参数的，如果我们需要传递一些参数，可以再对
<code>f</code> 做一层包裹。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; config.init(filename) &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="once-详解">Once 详解</h2>
<h3 id="hotpath">hotpath</h3>
<p>这里说的 <code>hotpath</code> 指的是 <code>Once</code> 里的第一个字段
<code>done</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// hotpath</span></span><br><span class="line">	done <span class="type">uint32</span></span><br><span class="line">	m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Once</code> 结构体的第一个字段是 <code>done</code>，这是因为
<code>done</code> 的访问是远远大于 <code>Once</code> 中另外一个字段
<code>m</code> 的，
放在第一个字段中，编译器就可以做一些优化，因为结构体的地址其实就是结构体第一个字段的地址，
这样一来，在访问 <code>done</code> 字段的时候，就不需要通过结构体地址 +
偏移量的方式来访问， 这在一定程度上提高了性能。</p>
<p>结构体地址计算示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStruct</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p = person&#123;</span><br><span class="line">		name: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">		age:  <span class="number">10</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// p 和 p.name 的地址相同</span></span><br><span class="line">	<span class="comment">// 0xc0000100a8, 0xc0000100a8</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p, %p\n&quot;</span>, &amp;p, &amp;p.name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// p.age 的地址</span></span><br><span class="line">	<span class="comment">// 0xc0000100b8</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;p.age)</span><br><span class="line">	<span class="comment">// p.age 的地址也可以通过：结构体地址 + age 字段偏移量 计算得出。</span></span><br><span class="line">	<span class="comment">// 0xc0000100b8</span></span><br><span class="line">	fmt.Println(unsafe.Add(unsafe.Pointer(&amp;p), unsafe.Offsetof(p.age)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="atomic.loaduint32">atomic.LoadUint32</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">		o.doSlow(f)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Do</code> 方法中，是通过 <code>atomic.LoadUint32</code>
的方式来判断 <code>done</code> 是否等于 0 的， 这是因为，如果直接使用
<code>done == 0</code> 的方式的话，就有可能导致在 <code>doSlow</code>
里面对 <code>done</code> 设置为 1 之后， 在 <code>Do</code>
方法里面无法正常观测到。因此用了 <code>atomic.LoadUint32</code>。</p>
<p>而在 <code>doSlow</code> 里面是可以通过 <code>done == 0</code>
来判断的，这是因为 <code>doSlow</code> 里面已经通过 <code>Mutex</code>
保护起来了。 唯一设置 <code>done = 1</code> 的地方就在临界区里面，所以
<code>doSlow</code> 里面通过 <code>done == 0</code>
来判断是完全没有问题的。</p>
<h3 id="atomic.storeuint32">atomic.StoreUint32</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> doSlow(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	o.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>doSlow</code> 方法中，设置 <code>done</code> 为 1 也是通过
<code>atomic.StoreUint32</code> 来设置的。 这样就可以保证在设置了
<code>done</code> 为 1 之后，可以及时被其他 goroutine 看到。</p>
<h3 id="mutex">Mutex</h3>
<p><code>doSlow</code> 的实现里面，最终还是要通过 <code>Mutex</code>
来保护临界区， 通过 <code>Mutex</code> 可以实现 <code>f</code>
只被执行一次，并且其他的 goroutine 都可以使用这一次 <code>f</code>
的执行结果。 因为其他 goroutine 在第一次 <code>f</code>
调用未返回之前，都阻塞在获取 <code>Mutex</code> 锁的地方， 当它们获取到
<code>Mutex</code> 锁的时候，得以继续往下执行，但这个时候 <code>f</code>
已经执行完毕了， 所以当它们获取到 <code>Mutex</code>
锁之后其实什么也没有干。</p>
<p>但是它们的阻塞状态被解除了，可以继续往下执行。</p>
<h2 id="总结">总结</h2>
<ul>
<li><code>Once</code>
保证了传入的函数只会执行一次，这常常用在一些初始化的场景、或者单例模式。</li>
<li><code>Once</code> 可以保证所有对 <code>Do</code>
的并发调用都是安全的，所有对 <code>Once.Do</code>
调用之后的操作，一定会在第一次对 <code>f</code>
调用之后执行。（没有获取到 <code>f</code> 执行权的 goroutine
会阻塞）</li>
<li>即使 <code>Once.Do</code> 里面的 <code>f</code> 出现了
<code>panic</code>，后续也不会再次调用 <code>f</code>。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/12/21/golang/go%20slice%20%E6%89%A9%E5%AE%B9%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/21/golang/go%20slice%20%E6%89%A9%E5%AE%B9%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">go slice 扩容实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-21 20:28:30" itemprop="dateCreated datePublished" datetime="2022-12-21T20:28:30+08:00">2022-12-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>基于 Go 1.19。</p>
</blockquote>
<p>go
的切片我们都知道可以自动地进行扩容，具体来说就是在切片的容量容纳不下新的元素的时候，
底层会帮我们为切片的底层数组分配更大的内存空间，然后把旧的切片的底层数组指针指向新的内存中：</p>
<figure>
<img src="/images/go/slice/slice_4_1.png" alt="slice_4_1" />
<figcaption aria-hidden="true">slice_4_1</figcaption>
</figure>
<p>目前网上一些关于扩容倍数的文章都是基于相对旧版本的 Go
的，新版本中，现在切片扩容的时候并不是那种准确的小于多少容量的时候就
<code>2</code> 倍扩容， 大于多少容量的时候就 <code>1.25</code>
倍扩容，其实这个数值多少不是非常关键的，我们只需要知道的是：
<strong>在容量较小的时候，扩容的因子更大，容量大的时候，扩容的因子相对来说比较小</strong>。</p>
<h2 id="扩容的示例">扩容的示例</h2>
<p>我们先通过一个简单的示例来感受一下切片扩容是什么时候发生的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line"></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">4</span>)</span><br><span class="line">fmt.Println(slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>slice</code> 切片初始化的时候，长度和容量都是
<code>3</code>（容量不指定的时候默认等于长度）。
因此切片已经容纳不下新的元素了，在我们往 <code>slice</code>
中追加一个新的元素的时候， 我们发现，<code>slice</code>
的长度和容量都变了， 长度增加了 <code>1</code>，而容量变成了原来的
<code>2</code> 倍。</p>
<figure>
<img src="/images/go/slice/slice_4_2.png" alt="slice_4_2" />
<figcaption aria-hidden="true">slice_4_2</figcaption>
</figure>
<blockquote>
<p>在 1.18 版本以后，旧的切片容量小于 256 的时候，会进行 2 倍扩容。</p>
</blockquote>
<h2 id="实际扩容倍数">实际扩容倍数</h2>
<p>其实最新的扩容规则在 1.18
版本中就已经发生改变了，具体可以参考一下这个 <code>commit</code>： <a
target="_blank" rel="noopener" href="https://github.com/golang/go/commit/2dda92ff6f9f07eeb110ecbf0fc2d7a0ddd27f9d">runtime:
make slice growth formula a bit smoother</a>。</p>
<p>大概意思是：</p>
<p>在之前的版本中：对于 <code>&lt;1024</code> 个元素，增加
<code>2</code> 倍，对于 <code>&gt;=1024</code> 个元素，则增加
<code>1.25</code> 倍。 而现在，使用更平滑的增长因子公式。 在 256
个元素后开始降低增长因子，但要缓慢。</p>
<p>它还给了个表格，写明了不同容量下的增长因子：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">starting cap</th>
<th style="text-align: center;">growth factor</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">256</td>
<td style="text-align: center;">2.0</td>
</tr>
<tr class="even">
<td style="text-align: center;">512</td>
<td style="text-align: center;">1.63</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1024</td>
<td style="text-align: center;">1.44</td>
</tr>
<tr class="even">
<td style="text-align: center;">2048</td>
<td style="text-align: center;">1.35</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4096</td>
<td style="text-align: center;">1.30</td>
</tr>
</tbody>
</table>
<p>从这个表格中，我们可以看到，新版本的切片库容，并不是在容量小于
<code>1024</code> 的时候严格按照 <code>2</code> 倍扩容，大于
<code>1024</code> 的时候也不是严格地按照 <code>1.25</code>
倍来扩容。</p>
<h2 id="growslice-实现">growslice 实现</h2>
<p>在 go 中，切片扩容的实现是 <code>growslice</code> 函数，位于
<code>runtime/slice.go</code> 中。</p>
<p><code>growslice</code> 有如下参数：</p>
<ul>
<li><code>oldPtr</code>: 旧的切片的底层数组指针。</li>
<li><code>newLen</code>:
新的切片的长度（<code>= oldLen + num</code>）。</li>
<li><code>oldCap</code>: 旧的切片的容量。</li>
<li><code>num</code>: 添加的元素数。</li>
<li><code>et</code>: 切片的元素类型（也即
<code>element type</code>）。</li>
</ul>
<p>返回一个新的切片，这个返回的切片中，底层数组指针指向新分配的内存空间，长度等于
<code>oldLen + num</code>，容量就是底层数组的大小。</p>
<h3 id="growslice-实现步骤">growslice 实现步骤</h3>
<ol type="1">
<li>一些特殊情况判断：如
<code>et.size == 0</code>，切片元素不需要占用空间的情况下，直接返回。</li>
<li>根据 <code>newLen</code> 计算新的容量，保证新的底层数组至少可以容纳
<code>newLen</code> 个元素。</li>
<li>计算所需要分配的新的容量所需的内存大小。</li>
<li>分配新的切片底层数组所需要的内存。</li>
<li>将旧切片上的底层数组的数据复制到新的底层数组中。</li>
</ol>
<blockquote>
<p>注意：这个函数只是实现扩容，新增的元素没有在这个函数往切片中追加。</p>
</blockquote>
<h3 id="growslice-源码剖析">growslice 源码剖析</h3>
<p>说明：</p>
<ol type="1">
<li>整数有可能会溢出，所以代码里面会判断
<code>newLen &lt; 0</code>。</li>
<li>如果切片的元素是空结构体或者空数组，那么
<code>et.size == 0</code>。</li>
<li>在计算新切片的容量的时候，会根据切片的元素类型大小来做一些优化。</li>
<li>新切片容量所占用的内存大小为 <code>capmem</code>。</li>
<li>新切片所需要的内存分配完成后，会将旧切片的数据复制到新切片中。</li>
<li>最后返回指向新的底层数组的切片，其长度为 <code>newLen</code>，容量为
<code>newcap</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// growtslice 为切片分配新的存储空间。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(oldPtr unsafe.Pointer, newLen, oldCap, num <span class="type">int</span>, et *_type)</span></span> slice &#123;</span><br><span class="line">	<span class="comment">// oldLen 为旧的切片底层数组的长度</span></span><br><span class="line">	oldLen := newLen - num</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配的新的长度不能小于 0（整数溢出的时候会是负数）</span></span><br><span class="line">	<span class="keyword">if</span> newLen &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: len out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果结构或数组类型不包含大小大于零的字段（或元素），则其大小为零。</span></span><br><span class="line">	<span class="comment">//（空数组、空结构体，type b [0]int、type zero struct&#123;&#125;）</span></span><br><span class="line">	<span class="comment">// 两个不同的零大小变量在内存中可能具有相同的地址。</span></span><br><span class="line">	<span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// append 不应创建具有 nil 指针但长度非零的切片。</span></span><br><span class="line">		<span class="comment">// 在这种情况下，我们假设 append 不需要保留 oldPtr。</span></span><br><span class="line">		<span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), newLen, newLen&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// newcap 是新切片底层数组的容量</span></span><br><span class="line">	newcap := oldCap</span><br><span class="line">	<span class="comment">// 两倍容量</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> newLen &gt; doublecap &#123;</span><br><span class="line">		<span class="comment">// 如果追加元素之后，新的切片长度比旧切片 2 倍容量还大，</span></span><br><span class="line">		<span class="comment">// 则将新的切片的容量设置为跟长度一样</span></span><br><span class="line">		newcap = newLen</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">		<span class="keyword">if</span> oldCap &lt; threshold &#123;</span><br><span class="line">			<span class="comment">// 旧的切片容量小于 256 的时候，</span></span><br><span class="line">			<span class="comment">// 进行两倍扩容。</span></span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// oldCap &gt;= 256</span></span><br><span class="line">			<span class="comment">// 检查 0&lt;newcap 以检测溢出并防止无限循环。</span></span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; newLen &#123;</span><br><span class="line">				<span class="comment">// 从小切片的增长 2 倍过渡到大切片的增长 1.25 倍。</span></span><br><span class="line">				newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当 newcap 计算溢出时，将 newcap 设置为请求的上限。</span></span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = newLen</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算实际所需要的内存大小</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否溢出</span></span><br><span class="line">	<span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line">	<span class="comment">// lenmem 表示旧的切片长度所需要的内存大小</span></span><br><span class="line">	<span class="comment">//（lenmem 就是将旧切片数据复制到新切片的时候指定需要复制的内存大小）</span></span><br><span class="line">	<span class="comment">// newlenmem 表示新的切片长度所需要的内存大小</span></span><br><span class="line">	<span class="comment">// capmem 表示新的切片容量所需要的内存大小</span></span><br><span class="line">	<span class="keyword">var</span> lenmem, newlenmem, capmem <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据 et.size 做一些计算上的优化：</span></span><br><span class="line">	<span class="comment">// 对于 1，我们不需要任何除法/乘法。</span></span><br><span class="line">	<span class="comment">// 对于 goarch.PtrSize，编译器会将除法/乘法优化为移位一个常数。</span></span><br><span class="line">	<span class="comment">// 对于 2 的幂，使用可变移位。</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> et.size == <span class="number">1</span>: <span class="comment">// 比如 []byte，所需内存大小 = size</span></span><br><span class="line">		lenmem = <span class="type">uintptr</span>(oldLen)</span><br><span class="line">		newlenmem = <span class="type">uintptr</span>(newLen)</span><br><span class="line">		capmem = roundupsize(<span class="type">uintptr</span>(newcap))</span><br><span class="line">		overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">		newcap = <span class="type">int</span>(capmem)</span><br><span class="line">	<span class="keyword">case</span> et.size == goarch.PtrSize: <span class="comment">// 比如 []*int，所需内存大小 = size * ptrSize</span></span><br><span class="line">		lenmem = <span class="type">uintptr</span>(oldLen) * goarch.PtrSize</span><br><span class="line">		newlenmem = <span class="type">uintptr</span>(newLen) * goarch.PtrSize</span><br><span class="line">		capmem = roundupsize(<span class="type">uintptr</span>(newcap) * goarch.PtrSize)</span><br><span class="line">		overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc/goarch.PtrSize</span><br><span class="line">		newcap = <span class="type">int</span>(capmem / goarch.PtrSize)</span><br><span class="line">	<span class="keyword">case</span> isPowerOfTwo(et.size): <span class="comment">// 比如 []int64，所需内存大小 = size &lt;&lt; shift，也就是 size * 2^shift（2^shift 是 et.size）</span></span><br><span class="line">		<span class="keyword">var</span> shift <span class="type">uintptr</span></span><br><span class="line">		<span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">			<span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">			shift = <span class="type">uintptr</span>(sys.TrailingZeros64(<span class="type">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			shift = <span class="type">uintptr</span>(sys.TrailingZeros32(<span class="type">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">		&#125;</span><br><span class="line">		lenmem = <span class="type">uintptr</span>(oldLen) &lt;&lt; shift</span><br><span class="line">		newlenmem = <span class="type">uintptr</span>(newLen) &lt;&lt; shift</span><br><span class="line">		capmem = roundupsize(<span class="type">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">		overflow = <span class="type">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">		newcap = <span class="type">int</span>(capmem &gt;&gt; shift)</span><br><span class="line">		capmem = <span class="type">uintptr</span>(newcap) &lt;&lt; shift</span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// 没得优化，直接使用乘法了</span></span><br><span class="line">		lenmem = <span class="type">uintptr</span>(oldLen) * et.size</span><br><span class="line">		newlenmem = <span class="type">uintptr</span>(newLen) * et.size</span><br><span class="line">		capmem, overflow = math.MulUintptr(et.size, <span class="type">uintptr</span>(newcap))</span><br><span class="line">		capmem = roundupsize(capmem)</span><br><span class="line">		newcap = <span class="type">int</span>(capmem / et.size)</span><br><span class="line">		capmem = <span class="type">uintptr</span>(newcap) * et.size</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查是否溢出，以及是否超过最大可分配内存</span></span><br><span class="line">	<span class="keyword">if</span> overflow || capmem &gt; maxAlloc &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: len out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配实际所需要的内存</span></span><br><span class="line">	<span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> et.ptrdata == <span class="number">0</span> &#123; <span class="comment">// 不包含指针</span></span><br><span class="line">		<span class="comment">// 分配 capmem 大小的内存，不清零</span></span><br><span class="line">		p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		<span class="comment">// 这里只清空从 add(p, newlenmem) 开始大小为 capmem-newlenmem 的内存，</span></span><br><span class="line">		<span class="comment">// 也就是前面的 newlenmem 长度不清空。</span></span><br><span class="line">		<span class="comment">// 因为最后的 capmem-newlenmem 这块内存，实际上是额外分配的容量。</span></span><br><span class="line">		<span class="comment">// 前面的那部分会被旧切片的数据以及新追加的数据覆盖。</span></span><br><span class="line">		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 分配 capmem 大小的内存，需要进行清零</span></span><br><span class="line">		p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> lenmem &gt; <span class="number">0</span> &amp;&amp; writeBarrier.enabled &#123;</span><br><span class="line">			<span class="comment">// Only shade the pointers in oldPtr since we know the destination slice p</span></span><br><span class="line">			<span class="comment">// only contains nil pointers because it has been cleared during alloc.</span></span><br><span class="line">			bulkBarrierPreWriteSrcOnly(<span class="type">uintptr</span>(p), <span class="type">uintptr</span>(oldPtr), lenmem-et.size+et.ptrdata)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 旧切片数据复制到新切片中，复制的内容大小为 lenmem</span></span><br><span class="line">	<span class="comment">//（从 oldPtr 复制到 p）</span></span><br><span class="line">	memmove(p, oldPtr, lenmem)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, newLen, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>go 的切片在容量较小的情况下，确实会进行 <code>2</code>
倍扩容，但是随着容量的增长，扩容的增长因子会逐渐降低。 新版本的
<code>growslice</code> 实现中，只有容量小于 <code>256</code>
的时候才会进行 <code>2</code> 倍扩容，
然后随着容量的增长，扩容的因子会逐渐降低（但并不是直接降到
<code>1.25</code>，而是一个相对缓慢的下降）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/14/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/70/">70</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/16/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">eleven26</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eleven26" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
