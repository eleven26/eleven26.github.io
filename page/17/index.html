<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eleven26.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="eleven26">
<meta property="og:url" content="https://eleven26.github.io/page/17/index.html">
<meta property="og:site_name" content="eleven26">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="eleven26">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="PHP">
<meta property="article:tag" content="Laravel">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://eleven26.github.io/page/17/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/17/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>eleven26</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">eleven26</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">100</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">346</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eleven26</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eleven26" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eleven26" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/11/26/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20chan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/26/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20chan/" class="post-title-link" itemprop="url">深入理解 go chan</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-26 20:08:30" itemprop="dateCreated datePublished" datetime="2022-11-26T20:08:30+08:00">2022-11-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>go
里面，在实际程序运行的过程中，往往会有很多协程在执行，通过启动多个协程的方式，我们可以更高效地利用系统资源。
而不同协程之间往往需要进行通信，不同于以往多线程程序的那种通信方式，在
go 里面是通过 <code>channel</code> （也就是 <code>chan</code>
类型）来进行通信的， 实现的方式简单来说就是，一个协程往
<code>channel</code> 里面写数据，然后其他的协程可以从
<code>channel</code> 中将其读取出来。 （注意：文中的 <code>chan</code>
表示是 go 语言里面的 <code>chan</code> 关键字，而 <code>channel</code>
只是我们描述它的时候用的一个术语）</p>
<h2 id="通道chan的模型">通道（chan）的模型</h2>
<p>在开始讲 <code>channel</code>
之前，也许了解一下它要解决什么样的问题会比较好，所以先来聊聊一些背景知识。</p>
<p>关于通道，一个比较潦草的图大概是下面这个样子的：</p>
<p><img src="/images/go/channel/chan1.png" /></p>
<p>在图中，协程 <code>A</code> 将消息 <code>msg</code> 写入到
<code>channel</code> 中，然后协程 <code>B</code> 从 <code>channel</code>
中读取消息，如果 <code>B</code> 没来得及从中读取消息，那么消息会在
<code>chan</code> 中存留。</p>
<p>这就是 go
的哲学：<strong>通过通信来实现共享内存</strong>。这不同于以往的多线程程序，在多线程程序中，往往是一块内存在不同线程之间进行共享，
然后通过一些保护机制，保证不允许多个线程同时对这块内存进行读写，比如通过
<code>synchronized</code> 关键字。
可能很多人都没有真正写过多线程的程序，但好像我们都有一种共识，多线程不安全。</p>
<h2 id="多线程为什么不安全">多线程为什么不安全？</h2>
<p>这是因为我们的程序除了通过共享一段内存之外，每一个 CPU
核心都有它本地的缓存，而 CPU 上的缓存是不共享的， 而线程可以同时在不同的
CPU 上执行。CPU 的执行过程是，先从内存中读取数据到 CPU 中，CPU
做完计算再更新到内存中。
这样一来，就有可能存在不同线程对同一段内存同时读写的问题。</p>
<p>这是什么问题呢？比如，<code>A</code>
线程计算完了但是还没有写回内存的时候，<code>B</code> 线程从内存读取出了
<code>A</code> 线程写入计算结果前的数据，
但是按我们的逻辑，<code>B</code> 应该是拿 <code>A</code>
线程的结算结果来进行逻辑运算的，这样就会出现数据不一致了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        main.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 a 加 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 启动两个线程来对 a 进行加 1 的操作</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程结束</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 我们的预期结果是 20000，但是实际运行显示了 14965</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们预期的运行结果是 <code>20000</code>
的，但是实际得到了
<code>14965</code>（实际上，每次执行结果都会不一样），这也就是我上面所说的问题，
其中有一个线程读取到了另一个线程的计算结果写入内存前的数据，也就是说，这个线程的计算结果被覆盖了，
因为线程将计算结果写回内存的时候是相互覆盖的。</p>
<blockquote>
<p>所以我们可以回答刚才的问题了，多线程不安全是因为多个线程可以对同一段内存进行读写，这就存在其中一个线程还没来得及更新内存，
然后另一个线程读取到的数据是旧的。（也即数据竞争的问题）</p>
</blockquote>
<p>具体可以看下图：</p>
<p><img src="/images/go/channel/chan2.png" /></p>
<blockquote>
<p>CPU 执行的时候，会需要将数据从内存读取到 CPU
中，计算完毕之后，再更新内存里面的数据。</p>
</blockquote>
<p>错乱发生的过程大概如下：</p>
<ol type="1">
<li><code>CPU 1</code> 先计算完了，计算的结果是
<code>a = 3</code>，但是还没来得及写入内存</li>
<li><code>CPU 2</code> 也从内存里面获取 <code>a</code>
来进行计算，但是这个时候 <code>a</code> 还没有被 <code>CPU 1</code>
更新，所以 <code>CPU 2</code> 拿到的还是 2</li>
<li><code>CPU 2</code> 进行计算的时候，<code>CPU 1</code>
将它的计算结果写入了内存，所以这个时候内存中的 <code>a</code> 是 3</li>
<li><code>CPU 2</code> 计算完毕，将等于 2 的变量 <code>a</code> 加 1
得到结果 3</li>
<li><code>CPU 2</code> 将结果 3 写入到内存，这个时候 <code>a</code>
的内存被更新，但是结果依然是 3</li>
</ol>
<h2 id="一种可行的办法---锁">一种可行的办法 - 锁</h2>
<p>其中一种可行的办法就是，给 <code>add</code> 方法加上
<code>synchronized</code> 关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，在我们的代码中，对 <code>a</code> 读写的代码都被
<code>synchronized</code>
保护起来了，在这段更新之后的代码中，我们得到了正确的结果
<code>20000</code>。</p>
<blockquote>
<p><code>a++</code> 其实包含了读和写两个操作，程序运行的时候，会先将 a
读取出来，将其加上 1，然后写回到内存中。</p>
</blockquote>
<p><code>synchronized</code>
是同步锁，它修饰的方法不允许多个线程同时执行。<code>synchronized</code>
锁的粒度可大可小，粒度太大的话对性能影响也较大。</p>
<blockquote>
<p>正如我们所看到的那样，<code>synchronized</code>
允许修饰一段代码，但是在实际中我们往往只是想保护其中某一个变量而已，
如果直接使用 <code>synchronized</code>
关键字来修饰一大段代码，那就意味着一个线程在执行这段代码的时候，其他线程就只能等待，
但是实际上，其中那些不涉及数据竞争的代码我们也无法执行，这样效率自然会降低，具体降低多少，取决于我们
<code>synchronized</code> 块的代码有多大。</p>
</blockquote>
<h2 id="go-中的处理办法">go 中的处理办法</h2>
<p>上面我们说到的多线程是通过共享内存来进行通信的，而在 go 里面，采用了
CSP（communicating sequential processes）并发模型， CSP
模型用于描述两个独立的并发实体通过共享
<code>channel</code>（管道）进行通信的并发模型。</p>
<p>CSP 是一套很复杂的东西，go 语言并没有完全实现它，仅仅是实现了
<code>process</code> 和 <code>channel</code>
这两个概念。<code>process</code> 就是 go 语言 中的
<code>goroutine</code>，每个 <code>goroutine</code> 之间是通过
<code>channel</code> 通讯来实现数据共享的。</p>
<p>然后我们上面说到，java 里面的 <code>synchronized</code>
关键字的粒度可能会比较大，这个是相比 go 里面的 <code>channel</code>
而言的， 在 go 里面，我们的代码在通信过程中很常见的一种阻塞场景是：</p>
<ul>
<li><code>goroutine</code> 需要从 <code>channel</code>
读取数据才能继续执行，但是 <code>channel</code> 里面还没数据，这个时候
<code>goroutine</code> 需要等待（会阻塞）另一个 <code>goroutine</code>
往 <code>channel</code> 写入数据。</li>
</ul>
<p>对于这种场景，它隐含的逻辑是，阻塞的这个 <code>goroutine</code>
需要等待其他 <code>goroutine</code> 的结果才能继续往下执行，也就是 CSP
中的 <code>sequential</code>。下图是实际运行中的 <code>chan</code>：</p>
<p><img src="/images/go/channel/chan10.png" /></p>
<p>我们上面的 <code>chan</code>
模型那个图，读和写都只有一个协程，但在实际中，读 <code>chan</code> 和写
<code>chan</code> 的协程都有一个队列来保存。
我们需要明确的一点事实是：<strong>队列中的协程会一个接一个执行，队列头的协程先执行，然后我们对
<code>chan</code> 的读写是按顺序来读写的，先取 <code>chan</code>
队列头的元素，然后下一个元素</strong>。</p>
<p>对应到上面 java 这个例子，我们在 go
里面可以怎么做呢？我们先把没有锁的 java 代码先写成 go 的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>, done <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		a++</span><br><span class="line">	&#125;</span><br><span class="line">	done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ch 充当协程之间同步的角色</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 这里可以传任意数字</span></span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> add(ch, done)</span><br><span class="line">	<span class="keyword">go</span> add(ch, done)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待 2 个协程执行完毕</span></span><br><span class="line">	&lt;-done</span><br><span class="line">	&lt;-done</span><br><span class="line">	fmt.Println(a) <span class="comment">// 15504 每次结果不一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 go 里面，我们可以把 add 方法改成下面这个样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>, done <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 阻塞，只有另外一个协程往 ch 里面写入数据的时候，</span></span><br><span class="line">		<span class="comment">// &lt;-ch 才得以解除阻塞状态</span></span><br><span class="line">		&lt;-ch</span><br><span class="line">		<span class="comment">// 这一行同一时刻只能一个协程执行</span></span><br><span class="line">		a++</span><br><span class="line">		<span class="comment">// 往 ch 写入数据，</span></span><br><span class="line">		<span class="comment">// 等待从 ch 中读取数据的协程得以继续执行</span></span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法看起来很笨拙，我们在实际使用中可能会稍有不同，所以不需要太纠结这个例子的合理性，这里想表达的是：<strong>在
go 中，我们的协程使用 <code>chan</code> 的时候只会阻塞在
<code>chan</code>
读写的地方，其他代码不受影响，当然，这个例子也没能很好体现。</strong></p>
<blockquote>
<p>假设我们有很大一段代码，但是涉及到数据竞争的时候，协程只会阻塞在
<code>chan</code>
读写的那一行代码上。这样一来我们就不用通过锁来覆盖一大段代码。</p>
</blockquote>
<p>这里，我们可以看到 <code>chan</code>
其中一个很明显的优势是，我们没有了 <code>synchronized</code>
那种大粒度的锁，我们的 <code>goroutine</code> 只会阻塞在某一个
<code>channel</code> 上， 在读取 <code>channel</code>
之前的代码，<code>goroutine</code>
都是可以执行的，这样就在语言层面帮我们解决了一个很大的问题，
因为粒度更小，我们的代码自然也就能处理更大的并发请求了。</p>
<h2 id="进程的几种状态">进程的几种状态</h2>
<p>在开始讲述 <code>channel</code>
之前，再来回忆一下进程的几种状态会便于我们理解。</p>
<p>我们知道，我们的电脑上，同一时刻会有很多进程一直在运行，但是我们也发现很多进程的
CPU 占用其实都是 <code>0%</code>，也就是不占用 CPU。
其实进程会有几种状态，进程不是一直在运行的，一般来说，会有
<code>执行</code>、<code>阻塞</code>、<code>就绪</code>
几种状态，进程不是运行态的时候，那它就不会占用你的 CPU，因此会看到 CPU
占用是 <code>0%</code>，它们之间的转换如下图：</p>
<p><img src="/images/go/channel/chan5.png" /></p>
<ul>
<li><code>执行</code>：这表示进程正在运行中，是正在使用 CPU
的进程。在就绪状态的进程会在得到 <code>CPU</code>
时间片的时候得以执行。</li>
<li><code>阻塞</code>：这表示进程因为某些需要的资源得不到满足而挂起了（比如，正在进行磁盘读写），这种状态下，是不用占用
<code>CPU</code> 资源的。</li>
<li><code>就绪</code>：这表示一个状态所需要的资源都准备好了，可以继续执行了。</li>
</ul>
<h2 id="进程的几种状态跟-channel-有什么关系">进程的几种状态跟 channel
有什么关系？</h2>
<p>在 go
里面，其实协程也存在类似的调度机制，在协程需要的资源得不到满足的时候，也会被阻塞，然后协程调度器会去执行其他可以执行的协程。</p>
<p>比如下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// 这个协程在 main 协程序阻塞的时候依然在执行</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 陷入睡眠状态</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">		<span class="comment">// 往 done 这个 chan 写入数据</span></span><br><span class="line">		done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// main 协程陷入阻塞状态</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中 <code>done &lt;- struct&#123;&#125;&#123;&#125;</code> 这一行往
<code>done</code> 这个 <code>chan</code> 写入了数据，之前一直在等待
<code>chan</code> 的 <code>main</code>
协程的阻塞状态解除，得以继续执行。</p>
<blockquote>
<p>goroutine 在等待 chan 返回数据的时候，会陷入阻塞状态。一个因为读取
chan 陷入阻塞状态的 goroutine 在获取到数据的时候，会继续往后执行。</p>
</blockquote>
<h2 id="channel-是什么">channel 是什么？</h2>
<p>我们在文章开头的第一张图，其实不是很准确。在 go
里面，<code>channel</code>
实际上是一个队列（准确来说是环形队列），大概长得像下面这样：</p>
<p><img src="/images/go/channel/chan3.png" /></p>
<p>队列我们都知道，我们可以从队列头读取数据，也可以将数据推入到队列尾。上图中，<code>1</code>
是队列头，当我们从 <code>channel</code> 读取数据的时候， 读取到的是
<code>1</code>，<code>6</code> 是队列尾，当我们往 <code>channel</code>
中写入数据的时候，写入的位置是 <code>6</code> 后面的那个空间。</p>
<blockquote>
<p><code>channel</code> 是一个环形队列，goroutine 通过 channel
通信的方式是，一个 goroutine 将数据写入队列尾，然后另一个 goroutine
将数据从队列头读数据。</p>
</blockquote>
<h2 id="如何使用-channel">如何使用 channel</h2>
<p>我们再仔细看看上面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">		<span class="comment">// 发送取消信号</span></span><br><span class="line">		done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 等待结束信号</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面包含了使用 <code>channel</code> 的基本用法：</p>
<ul>
<li><code>done := make(chan struct&#123;&#125;)</code>：创建
<code>channel</code>，在 go 里面是使用 <code>chan</code>
关键字来代表一个 <code>channel</code> 的。而在这个语句中，创建了一个接收
<code>struct&#123;&#125;</code> 类型数据的 <code>chan</code>。</li>
<li><code>done &lt;- struct&#123;&#125;&#123;&#125;</code>：写入到
<code>chan</code>，这里，我们创建了一个空结构体，然后通过
<code>&lt;-</code> 操作符将这个空结构体写入到了 <code>chan</code>
中。</li>
<li><code>&lt;-done</code>：从 <code>chan</code> 中读取数据，也是使用了
<code>&lt;-</code> 操作符，然后我们丢弃了它的返回结果。</li>
</ul>
<p>这段代码的执行过程如下图：</p>
<p><img src="/images/go/channel/chan4.png" /></p>
<ol type="1">
<li><code>CPU 1</code> 上启动了 <code>main</code> 协程</li>
<li>接着在 <code>main</code> 协程中通过 <code>go func</code>
启动了一个新的协程，go 的调度机制允许不同的协程在不同的线程上执行，所以
<code>main</code> 执行的时候，<code>go func</code> 也在执行，然后，因为
<code>done</code> 这个 <code>chan</code> 中没有数据，所以
<code>main</code> 协程陷入阻塞。</li>
<li><code>go func</code> 在短暂的睡眠之后，输出了
<code>done</code>，然后向名字为 <code>done</code> 这个 <code>chan</code>
中发送了一个空结构体实例。</li>
<li>在 <code>done</code> 里面没有写入数据之前，<code>main</code>
一直阻塞，在 <code>go func</code> 写入数据之后，<code>main</code> 的
<code>&lt;-done</code>，解除了阻塞状态，得以继续执行</li>
<li><code>5</code> 和 <code>6</code>
因为可能是在不同的线程上执行的，所以哪一个先结束其实不一定。</li>
</ol>
<p>下面详细说说 <code>channel</code> 的具体用法</p>
<h3 id="创建-chan">创建 chan</h3>
<blockquote>
<p><code>chan</code> 是 go 的关键字，<code>channel</code> 是我用来描述
<code>chan</code> 所表示的东西的一个术语而已，我们在 go
里面使用的话还是得用 <code>chan</code> 关键字。</p>
</blockquote>
<p>创建 <code>chan</code> 是通过 <code>make</code> 关键字创建的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p><code>make</code> 函数的参数是 <code>chan</code>
然后加一个数据类型，这个数据类型是我们的 <code>chan</code>
这个环形队列里面所能存储的数据类型。 不能传递不同的类型进一个
<code>chan</code> 里面。</p>
<p>也可以传递第二个参数作为 <code>chan</code> 的容量，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这里第二个参数表明了 <code>ch</code> 这个 <code>chan</code>
到底能存储多少个 <code>int</code> 类型的数据。</p>
<blockquote>
<p>不传递或者传 0 表示 <code>chan</code> 本身不能存储数据，go
底层会直接在两个 goroutine 之间传递，而不经过 <code>chan</code> 的复制。
（如果第二个参数大于 0，我们往 <code>chan</code>
写数据的时候，会先复制到 <code>chan</code> 这个数据结构，然后其他的
<code>goroutine</code> 从 <code>chan</code>
中读取数据的时候，<code>chan</code> 会将数据复制到这个
<code>goroutine</code> 中）</p>
</blockquote>
<h3 id="chan-读写的几种操作">chan 读写的几种操作</h3>
<ul>
<li>写：<code>ch &lt;- x</code>，将 <code>x</code> 发送到 channel
中</li>
<li>读：<code>x = &lt;-ch</code>，从 <code>channel</code> 中接收，保存到
<code>x</code> 中</li>
<li>读，但是忽略返回值（用作协程同步，上面的例子就是）：<code>&lt;-ch</code>，从
<code>ch</code> 中接收，但是忽略接收到的结果</li>
<li>读，并且判断是否是关闭前发送的：<code>x, ok := &lt;-ch</code>，这里使用了两个返回值接收，第二个返回值表明了接收到的
<code>x</code> 是不是 <code>chan</code>
关闭之前发送进去的，<code>true</code> 就代表是。</li>
</ul>
<p>需要注意的是 <code>&lt;-ch</code> 和 <code>ch&lt;-</code>
这两个看起来好像一样，但是效果是完全不同的，<code>ch</code> 位于
<code>&lt;-</code> 操作符右边的时候， 表示是</p>
<blockquote>
<p>有一个简单区分的方法是，将 &lt;-
想象为数据流动的方向，具体来说就是看数据是流向 chan 还是从 chan
流出，流向 chan 就是写入到 chan，从 chan 流出就是读取。</p>
</blockquote>
<h3 id="缓冲-chan-与非缓冲-chan">缓冲 chan 与非缓冲 chan</h3>
<p>上面我们说到，创建 <code>chan</code> 的时候可以传递第二个参数表示
<code>chan</code> 的容量是多少，这个容量表示的是， 在没有 goroutine
从这个 <code>chan</code> 读取数据的时候，<code>chan</code>
能存放多少数据，也就是 <code>chan</code> 底层环形队列的长度。</p>
<p>下面描述了缓冲的实际场景：</p>
<h3 id="无缓冲-chan">无缓冲 chan</h3>
<p>还是用我们上面的那段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">		done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>make(chan struct&#123;&#125;)</code>，只有一个参数，所以
<code>done</code> 是一个无缓冲的 <code>chan</code>，这种
<code>chan</code> 会在发送的时候阻塞，直到有另一个协程从
<code>chan</code> 中获取数据。</p>
<p><img src="/images/go/channel/chan6.png" /></p>
<h3 id="有缓冲-chan">有缓冲 chan</h3>
<p>有缓冲的 <code>chan</code>
在协程往里面写入数据的时候，可以进行缓冲。<strong>缓冲的作用是，在需要读取
<code>chan</code> 的 goroutine 的处理速度比较慢的时候，写入
<code>chan</code> 的 goroutine 也可以持续运行，直到写满
<code>chan</code> 的缓冲区</strong></p>
<p><img src="/images/go/channel/chan7.png" /></p>
<p>上图的 <code>chan</code> 是一个有缓冲的 <code>chan</code>，在
<code>chan</code> 里面的数据还没来得及被接收的时候，<code>chan</code>
可以充当一个缓冲的角色。但是，如果 <code>chan</code>
的数据一直没有被接收，然后满了的时候，往 <code>chan</code>
写入数据的协程依然会陷入阻塞。但这种阻塞状态会在 <code>chan</code>
的数据被读取的时候解除。</p>
<p>下面是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// 定义一个缓冲数量为 2 的 chan</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 模拟比较慢的处理速度</span></span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">			i, ok := &lt;-ch</span><br><span class="line">			<span class="comment">// ok 为 false 表示 ch 已经关闭并且数据已经被读取完</span></span><br><span class="line">			<span class="comment">// 这个时候中断循环</span></span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fmt.Printf(<span class="string">&quot;[%d] get from ch: %d\n&quot;</span>, time.Now().Unix(), i)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 处理完数据之后，发送结束的信号</span></span><br><span class="line">		done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 在循环结束之后关闭 chan</span></span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">			<span class="comment">// 在写入 2 个数之后，会陷入阻塞状态</span></span><br><span class="line">			<span class="comment">// 直到上面那个协程从 ch 读取出数据，ch 才会有空余的地方可以继续接收数据</span></span><br><span class="line">			ch &lt;- i</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[%d] write to ch: %d\n&quot;</span>, time.Now().Unix(), i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 收到结束信号，解除阻塞状态，继续往下执行</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1669381752] write to ch: 0</span><br><span class="line">[1669381752] write to ch: 1</span><br><span class="line">[1669381753] get from ch: 0</span><br><span class="line">[1669381753] write to ch: 2</span><br><span class="line">[1669381754] get from ch: 1</span><br><span class="line">[1669381755] get from ch: 2</span><br></pre></td></tr></table></figure>
<p>我们可以看到，写入 <code>chan</code> 的协程在 <code>1669381752</code>
的时候没有写入了，然后在读取 <code>chan</code> 的协程从
<code>chan</code> 中读取了一个数出来后才能继续写入。</p>
<h3 id="nil-chan">nil chan</h3>
<p><code>chan</code> 的零值是 <code>nil</code>，<code>close</code> 一个
<code>nil</code> 通道会引发 <code>panic</code>。往 <code>nil</code>
通道写入或从中读取数据会永久阻塞：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	&lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行的时候会报错：<code>fatal error: all goroutines are asleep - deadlock!</code></p>
<h3 id="len-和-cap">len 和 cap</h3>
<ul>
<li><code>len</code>：通过 <code>len</code> 我们可以查询一个
<code>chan</code> 的长度，也就是有多少被发送到这个 <code>chan</code>
但是还没有被接收的值。</li>
<li><code>cap</code>：通过 <code>cap</code>
可以查询一个容道的容量，也就是我们传给 <code>make</code>
函数的第二个参数，它表示 <code>chan</code> 最多可以容纳多少数据。</li>
</ul>
<blockquote>
<p>如果 <code>chan</code> 是 <code>nil</code>，那么 <code>len</code> 和
<code>cap</code> 都会返回 0。</p>
</blockquote>
<h3 id="chan-的方向">chan 的方向</h3>
<p><code>chan</code>
还有一个非常重要的特性就是它是可以有方向的，这里说的方向指的是，数据的流向。在我们上面的例子中，数据既可以流入
<code>chan</code>，也可以从 <code>chan</code>
中流出，因为我们没有指定方向，没有指定那么 <code>chan</code>
就是双向的。</p>
<p>具体来说，有以下几种情况：</p>
<ul>
<li><code>chan</code>，没有指定方向，既可以读又可以写。</li>
<li><code>chan&lt;-</code>，只写 <code>chan</code>，只能往
<code>chan</code> 中写入数据，如果从中读数据的话，编译不会通过。</li>
<li><code>&lt;-chan</code>，只读 <code>chan</code>，只能从
<code>chan</code>
中读取数据，如果往其中写入数据的话，编译不会通过。</li>
</ul>
<p>另外，<strong>无方向的 <code>chan</code> 可以转换为
<code>chan&lt;-</code> 或者
<code>&lt;-chan</code>，但是反过来不行</strong></p>
<p>在实际使用 <code>chan</code> 的时候，在某些地方我们其实是只允许往
<code>chan</code> 里面写数据，然后另一个地方只允许从 <code>chan</code>
中读数据。比如下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch 是只写 chan，如果在这个函数里面从 ch 读取数据编译不会通过</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">		fmt.Printf(<span class="string">&quot;produce %d\n&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发送 3 个数之后，关闭 chan</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch 是只读 chan，如果在这个函数里往 ch 写入数据编译不会通过</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		i, ok := &lt;-ch</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// chan 的数据已经被全部接收完，</span></span><br><span class="line">			<span class="comment">// 发送 done 信号</span></span><br><span class="line">			done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;consume %d\n&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> producer(nums)</span><br><span class="line">	<span class="keyword">go</span> consumer(nums)</span><br><span class="line">	<span class="comment">// 收到结束信号之后继续往下执行</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>producer</code> 这个协程里面往 <code>chan</code>
写入数据，写入 3 个数之后关闭，然后 <code>consumer</code> 这个协程序从
<code>chan</code> 读取数据， 在读取完所有数据之后，发送结束信号（通过
<code>done</code> 这个 <code>chan</code>），最后 <code>main</code>
协程收到 <code>done</code> 信号后退出。</p>
<blockquote>
<p>这样有个好处就是，从语法层面限制了对 chan
的读写操作。而不用担心有误操作。</p>
</blockquote>
<h2 id="什么时候阻塞什么时候不阻塞">什么时候阻塞？什么时候不阻塞？</h2>
<p>在开始这个话题之前，很有必要说一下，go 里面 <code>chan</code>
的一些实现原理，在 <code>chan</code> 的实现中，维护了三个队列：</p>
<ul>
<li>数据缓冲队列（<code>chan</code>）：也就是上面说的环形队列，是一种先进先出结构（<code>FIFO</code>，"First
In, First Out"），它的长度是 <code>chan</code>
的容量。此队列存放的都是同一种类型的元素。</li>
<li>接收数据<strong>协程</strong>队列（<code>recvq</code>）：当
<code>chan</code>
里面没有数据可以读取的时候，这个队列会有数据，这个队列中的协程都在等待从
<code>chan</code> 中读取数据。</li>
<li>发送数据<strong>协程</strong>队列（<code>sendq</code>）：当数据缓冲队列满了的时候（又或者如果是一个无缓冲的
<code>chan</code>），那么这个队列不为空，这个队列中的协程都在等待往
<code>chan</code> 中写入数据。</li>
</ul>
<p>大家在实际使用的时候可以参考一下下图，下图列出了对 <code>chan</code>
操作的所有场景：</p>
<p><img src="/images/go/channel/chan8.png" /></p>
<p>对于阻塞或者非阻塞，其实有一个很简单的判断标准，下面描述了所有会阻塞的情况：</p>
<ul>
<li><strong>发送：如果没有地方能存放发送的数据，则阻塞</strong>，具体有下面几种情况：
<ul>
<li><code>nil chan</code></li>
<li>有缓冲但是缓冲满了</li>
<li>无缓冲并且没有协程在等待从 <code>chan</code> 中读取数据</li>
</ul></li>
<li><strong>接收：如果没有可以读取的数据，则阻塞</strong>，具体有下面几种情况：
<ul>
<li><code>nil chan</code></li>
<li>有缓冲，但是缓冲区空的</li>
<li>无缓冲，但是没有协程正在往 <code>chan</code> 中发送数据</li>
</ul></li>
</ul>
<p>大家觉得抽象可以结合下面这个图想象一下：</p>
<p><img src="/images/go/channel/chan9.png" /></p>
<p>结合现实场景想象一下，我们可以把 <code>chan</code>
想象成为配送员，<code>sendq</code> 想象为商家，<code>recvq</code>
想象成用户，配送员装餐点的箱子想象成缓冲区：</p>
<p>一个假设的前提：假设商家只能在送出去一份餐点后，才能开始制作下一份餐点。</p>
<ul>
<li>发送
<ul>
<li><code>nil chan</code>。没有配送员了，商家的餐点肯定是送不出去了，商家只能等着关门大吉了。</li>
<li>有缓冲但是缓冲满了。配送员会有一个箱子（缓冲区）来存放外卖，但是这个箱子现在满了，虽然接了一个单，但是没有办法再从商家那里取得外卖来送了</li>
<li>无缓冲并且没有协程在等待从 <code>chan</code>
中读取数据。这个外卖是用户自取的订单，但是用户联系不上。（当然现实中商家不用等，我们假设现在商家只能送出去一份后才能开始制作下一份）</li>
</ul></li>
<li>接收
<ul>
<li><code>nil chan</code>。没有配送员，用户的餐没人送，用户只能等着饿死了。</li>
<li>有缓冲，但是缓冲区空的。商家还没制作好餐点，配送员没有取到餐，这个时候用户打电话给配送员叫他快点送，但是这个时候配送员也没有办法，因为他也没有拿到用户的餐点。这个时候用户快饿死了，但也没有办法，只有干等着，先吃饱才能搬砖。</li>
<li>无缓冲，但是没有协程正在往 <code>chan</code>
中发送数据。这天，用户是下了自取的订单，然后去到店里的时候，商家还没做好，这个时候，用户啥事也干不了，也只能等了。</li>
</ul></li>
</ul>
<p><strong>需要注意的是，上图中发送和接收只有一个协程，但是在实际中，正如这一节开头讲的那样，发送和接收都维护了一个队列的。</strong>
对应到上面那个现实的例子，那就是配送员可以同时从多个商家那里取餐，也可以同时给多个用户送餐，这个过程，有可能多个商家在制作需要这个配送员配送的餐点，也有可能有多个用户在等着这个配送员送餐。</p>
<h2 id="操作符只是语法糖">&lt;- 操作符只是语法糖</h2>
<p>在 go 里面我们操作 <code>chan</code> 的方式好像非常简单，就通过
<code>&lt;-</code> 操作符就已经绰绰有余了，这也是 go
的设计理念吧，尽量把语言设计得简单。
（但是，<strong>简单并不容易</strong>）但是，从另外一个角度看，go 把对
<code>chan</code> 的操作简化成我们现在看到的这个样子，也说明了
<code>chan</code> 在 go 里面的地位（一等公民）。</p>
<p>在 go 中，<code>chan</code>
实际上是一个结构体（<code>runtime/chan.go</code> 里面的
<code>hchan</code>
结构体），而且，还是一个非常复杂的结构体，但是我们在使用的时候却非常简单，
这其实是 go
设计者给开发者提供的一种语法糖，直接在语法层面极大地简化了开发者对
<code>chan</code> 的使用，</p>
<p>如果没有这个语法糖，那就需要开发者自己去创建 <code>hchan</code>
结构体，然后发送或者接收的时候还需要调用这个结构体的方法。
相比之下，<code>&lt;-</code>
就写一个操作符就行了，而且这个符号还非常形象，指向哪就代表了数据是流向
<code>chan</code> （写）还是从 <code>chan</code> 流出（读）。</p>
<h3 id="for...range-语法糖">for...range 语法糖</h3>
<p>我们上面说过了，从 <code>chan</code>
读取数据的时候，可能需要用两个值来接收 <code>chan</code>
的返回值，第二个值用来判断接收到的值是否是 <code>chan</code>
关闭之前发送的。</p>
<p>而 <code>for...range</code> 语法也可以用来从 <code>chan</code>
中读取数据，它会循环，直到 <code>chan</code>
关闭，这样直接免去了我们判断的操作，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	nums := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;send %d\n&quot;</span>, i)</span><br><span class="line">			nums &lt;- i</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(nums)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 传统写法</span></span><br><span class="line">		<span class="comment">//for &#123;</span></span><br><span class="line">		<span class="comment">//	num, ok := &lt;-nums</span></span><br><span class="line">		<span class="comment">//	if !ok &#123;</span></span><br><span class="line">		<span class="comment">//		break</span></span><br><span class="line">		<span class="comment">//	&#125;</span></span><br><span class="line">		<span class="comment">//	fmt.Printf(&quot;receive %d\n&quot;, num)</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// range 语法糖</span></span><br><span class="line">		<span class="keyword">for</span> num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;receive %d\n&quot;</span>, num)</span><br><span class="line">		&#125;</span><br><span class="line">		done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="select-语句里面使用-chan">select 语句里面使用 chan</h2>
<p>go 里面有一个关键字 <code>select</code>，可以让我们同时监听几个
<code>chan</code>，在任意一个 <code>chan</code>
有数据的时候，<code>select</code> 里面的 <code>case</code>
块得以执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ch1 会先收到数据</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		ch1 &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		ch2 &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// select 会阻塞，直到其中某一个分支收到数据</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">		<span class="comment">// 执行这一行代码</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;from ch1&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch2:</span><br><span class="line">		<span class="comment">// 这一行不会被执行</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;from ch2&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>select-case</code> 的用法类似于
<code>switch-case</code>，也有一个 <code>default</code> 语句，在
<code>select</code> 里面</p>
<ul>
<li>如果 <code>default</code> 之前的 <code>case</code> 都不满足，则执行
<code>default</code> 块的代码。</li>
<li>如果没有 <code>default</code> 语句，则会一直阻塞，直到某一个
<code>case</code> 上面的 <code>chan</code> 返回（有数据、或者
<code>chan</code> 被关闭都会返回）</li>
</ul>
<p>当然，<code>case</code> 后面可以从 <code>chan</code>
读取数据，也可以往 <code>chan</code> 写数据，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="comment">// 往 nil chan 写入数据会阻塞</span></span><br><span class="line">	<span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ch1 会先收到数据</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		ch1 &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 会阻塞，直到其中一个 case 返回</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">		<span class="comment">// 执行这一行代码</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;from ch1&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> ch2 &lt;- <span class="number">1</span>: <span class="comment">// 永远不会满足，因为 ch2 是 nil</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;from ch2&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>select</code> 的另外一种很常见的用法是，等待一个
<code>chan</code> 和一个定时器（实现控制超时的功能），比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ch1 一秒后才收到数据</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		ch1 &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">		fmt.Println(<span class="string">&quot;from ch1&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">100</span>):</span><br><span class="line">		<span class="comment">// 执行如下代码，因为这个 case 在 100ms 后就返回了</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;from ch2&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们需要控制某些操作的超时时间，那么就可以在时间到了之后，做一些清理操作，然后终止一些工作，最后退出协程。</p>
<h2 id="总结">总结</h2>
<ul>
<li>go 里面通过 <code>chan</code>
来实现协程之间的通信，<code>chan</code>
大概就是一个协程给另一个协程发送信息的代理。</li>
<li>多线程程序执行的时候，因为有 CPU
缓存，然后需要对同一块内存进行并发读写，可能会导致数据竞争的问题。</li>
<li>在很多语言中，都提供了锁的机制，来保护一片内存同一时刻只能一个线程操作，比如
java 里面的 <code>synchronized</code> 关键字。</li>
<li>go 里面很多情况下，在不同协程之间通信都是使用 <code>chan</code>
来实现的。</li>
<li>进程会有阻塞态、运行态，go
里面的协程也有阻塞的状态，当需要的资源得不到满足的时候就会陷入阻塞。比如等待别的协程往
<code>chan</code> 里面写入数据。</li>
<li><code>chan</code> 的几种常见操作：<code>make</code>
创建、<code>&lt;-chan</code> 读、<code>chan&lt;-</code>
写、<code>len</code> 获取 <code>chan</code>
中未读取的元素个数、<code>cap</code> 获取 <code>chan</code>
的缓冲区容量。</li>
<li><code>chan</code> <strong>类型</strong>上不加 <code>&lt;-</code>
表示是一个可读可写的 <code>chan</code>，<code>&lt;-chan T</code>
表示只读 <code>chan</code>，<code>chan&lt;- T</code> 表示只写
<code>chan</code>，双向的 <code>chan</code> 可以转换为只读或者只写
<code>chan</code>，但是反过来不行，只读 <code>chan</code> 和只写
<code>chan</code> 之间也不能相互转换。</li>
<li>协程的阻塞跟不阻塞，很简单的判断方式就是，发送的时候就看有没有地方能接得住，接收的时候就看有没有数据可以拿，没有则陷入阻塞。</li>
<li><code>&lt;-</code> 是 go
语言在设计层面提供给开发者的一种语法糖，<code>chan</code>
底层是一个很复杂的结构体。</li>
<li><code>for...range</code> 结构在遍历 <code>chan</code>
的时候不用判断返回值是否有效，因为返回值无效的时候会退出循环。</li>
<li>我们可以通过 <code>select</code> 来同时等待多个 <code>chan</code>
的操作返回。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/11/23/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20unsafe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/23/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20unsafe/" class="post-title-link" itemprop="url">深入理解 go unsafe</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-23 20:08:30" itemprop="dateCreated datePublished" datetime="2022-11-23T20:08:30+08:00">2022-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>学过 C
的朋友应该知道，有一种类型是指针类型，指针类型存储的是一个内存地址，通过这个内存地址可以找到它指向的变量。
go 虽然是一种高级语言，但是也还是给开发者提供了指针的类型
<code>unsafe.Pointer</code>，我们可以通过它来直接读写变量的内存。
正因为如此，如果我们操作不当，极有可能会导致程序崩溃。今天就来了解一下
<code>unsafe</code> 里所能提供的关于指针的一些功能， 以及使用
<code>unsafe.Pointer</code> 的一些注意事项。</p>
<h2
id="内存里面的二进制数据表示什么">内存里面的二进制数据表示什么？</h2>
<p>我们知道，计算机存储数据的时候是以二进制的方式存储的，当然，内存里面存储的数据也是二进制的。二进制的
01 本身其实并没有什么特殊的含义。</p>
<p>它们的具体含义完全取决于我们怎么去理解它们，比如
<code>0010 0000</code>，如果我们将其看作是一个十进制数字，那么它就是
32， 如果我们将其看作是字符，那么他就是一个空格（具体可参考 ASCII
码表）。</p>
<p>对应到编程语言层面，其实我们的变量存储在内存里面也是 01
表示的二进制，这些二进制数表示是什么类型都是语言层面的事，
更准确来说，是编译器来处理的，我们写代码的时候将变量声明为整数，那么我们取出来的时候也会表示成一个整数。</p>
<p><strong>这跟本文有什么关系呢？我们下面会讲到很多关于类型转换的内容，如果我们理解了这一节说的内容，下面的内容会更容易理解</strong></p>
<p><strong>在我们做类型转换的时候，实际上底层的二进制表示是没有变的，变的只是我们所看到的表面的东西。</strong></p>
<h2 id="内存布局">内存布局</h2>
<p>有点想直接开始讲 <code>unsafe</code> 里的 <code>Pointer</code>
的，但是如果读者对计算机内存怎么存储变量不太熟悉的话，
看起来可能会比较费解，所以在文章开头会花比较大的篇幅来讲述计算机是怎么存储数据的，
相信读完会再阅读后面的内容（比如指针的算术运算、通过指针修改结构体字段）会没有那么多障碍。</p>
<h3 id="变量在内存中是怎样的">变量在内存中是怎样的？</h3>
<p>我们先来看一段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int8</span> = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="type">int16</span> = <span class="number">2</span></span><br><span class="line">	<span class="comment">// unsafe.Sizeof() 可以获取存储变量需要的内存大小，单位为字节</span></span><br><span class="line">	<span class="comment">// 输出：1 2</span></span><br><span class="line">	<span class="comment">// int8 意味着，用 8 位，也就是一个字节来存储整型数据</span></span><br><span class="line">	<span class="comment">// int16 意味着，用 16 位，也就是两个字节来存储整型数据</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(a), unsafe.Sizeof(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中我们定义了两个变量，占用一个字节的 <code>a</code>
和占用两个字节的 <code>b</code>，在内存中它们大概如下图：</p>
<p><img src="/images/go/unsafe/memory_0.png" /></p>
<p>我们可以看到，在图中，<code>a</code> 存储在低地址，占用一个字节，而
<code>b</code> 存储在 <code>a</code> 相邻的地方，占用两个字节。</p>
<h3 id="结构体在内存中是怎样的">结构体在内存中是怎样的？</h3>
<p>我们再来看看结构体在内存中的存储：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line">	<span class="comment">// 输出：2 1 1</span></span><br><span class="line">	<span class="comment">// 意味着 p 占用两个字节，</span></span><br><span class="line">	<span class="comment">// 其中 age 占用一个字节，score 占用一个字节</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(p), unsafe.Sizeof(p.age), unsafe.Sizeof(p.score))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，我们定义了一个 <code>Person</code> 结构体，其中两个字段
<code>age</code> 和 <code>score</code> 都是 <code>int8</code>
类型，都是只占用一个字节的，它的内存布局大概如下图：</p>
<p><img src="/images/go/unsafe/memory_1.png" /></p>
<p>我们可以看到，在内存中，结构体字段是占用了内存中连续的一段存储空间的，具体来说是占用了连续的两个字节。</p>
<h3 id="指针在内存中是怎么存储的">指针在内存中是怎么存储的？</h3>
<p>在下面的代码中，我们定义了一个 <code>a</code> 变量，大小为 1
字节，然后我们定义了一个指向 <code>a</code> 的指针 <code>p</code>：</p>
<p>需要先说明的是，下面有两个操作符，一个是
<code>&amp;</code>，这个是取地址的操作符，<code>var p = &amp;a</code>
意味着，取得 <code>a</code> 的内存地址，将其存储在变量 <code>p</code>
中， 另一个操作符是
<code>*</code>，这个操作符的意思是解指针，<code>*p</code> 就是通过
<code>p</code> 的地址取得 <code>p</code> 指向的内容（也就是
<code>a</code>）然后进行操作。 <code>*p = 4</code> 意味着，将
<code>p</code> 指向的 <code>a</code> 修改为 4。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int8</span> = <span class="number">3</span></span><br><span class="line">	<span class="comment">// ... 其他变量</span></span><br><span class="line">	<span class="keyword">var</span> p = &amp;a</span><br><span class="line">	fmt.Println(unsafe.Sizeof(p))</span><br><span class="line">	fmt.Println(*p) <span class="comment">// 3</span></span><br><span class="line">	*p = <span class="number">4</span></span><br><span class="line">	fmt.Println(a) <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/go/unsafe/memory_2.png" /></p>
<p>需要注意的是，这里面不再是一个单元格一个字节了，<code>p</code>（指针变量）是要占用
8 个字节的（这个跟机器有关，我的是 64 位的 CPU，所以是 8 个字节）。</p>
<blockquote>
<p>从这个图，我们可以得知，指针实际上存储的是一个内存地址，通过这个地址我们可以找到它实际存储的内容。</p>
</blockquote>
<h3
id="结构体的内存布局真的是我们上面说的那样吗">结构体的内存布局真的是我们上面说的那样吗？</h3>
<p>上面我们说了，下面这个结构体占用了两个字节，结构体里面的一个字段占用一个字节：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再来看看下面这个结构体，它会占用多少字节呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int16</span> <span class="comment">// 类型由 int8 改为了 int16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许我们这个时候已经算好了 <code>1 + 2 = 3</code>，3
个字节不是吗？说实话，真的不是，它会占用 4 个字节，
这可能会有点反常理，但是这跟计算机的体系结构有着密切的关系，先看具体的运行结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line">	<span class="comment">// 输出：4 1 2</span></span><br><span class="line">	<span class="comment">// 意味着 p 占用 4 个字节，</span></span><br><span class="line">	<span class="comment">// 其中 age 占用 2 个字节，score 占用 2 个字节</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(p), unsafe.Sizeof(p.age), unsafe.Sizeof(p.score))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会这样呢？因为 CPU
运行的时候，需要从内存读取数据，而从内存取数据的过程是按字读取的，如果我们数据的内存没有对齐，
则可能会导致 CPU
本来一次可以读取完的数据现在需要多次读取，这样就会造成效率的下降。</p>
<p>关于内存对齐，是一个比较庞大的话题，这里不展开了，我们需要明确的是，go
编译器会对我们的结构体字段进行内存对齐。</p>
<blockquote>
<p>内存对我们的影响就是，它可能会导致结构体所占用的空间比它字段类型所需要的空间大（所以我们做指针的算术运算的时候需要非常注意），
具体大多少其实我们其实不需要知道，因为有方法可以知道，哪就是
<code>unsafe.Offsetof</code>，下面会说到。</p>
</blockquote>
<h2 id="uintptr-是什么意思">uintptr 是什么意思？</h2>
<p>在开始下文之前，还是得啰嗦一句，<code>uintptr</code> 这种命名方式是 C
语言里面的一种类型命名的惯例， <code>u</code>
前缀表示是无符号数（unsigned），<code>ptr</code>
是指针（pointer）的缩写，这个 <code>uintptr</code>
按这个命名惯例解析的话，就是一个指向无符号整数的指针。</p>
<p>另外，还有另外一种命名惯例，就是在整型类型的后面加上一个表示占用 bit
数的数字，（1字节=8bit） 比如 <code>int8</code> 表示一个占用 8
位的整数，只可以存储 1 个字节的数据，然后 <code>int64</code>
表示的是一个 8 字节数（64位）。</p>
<h2 id="unsafe-包定义的三个新类型">unsafe 包定义的三个新类型</h2>
<h3 id="arbitrarytype">ArbitraryType</h3>
<p><code>type ArbitraryType int</code>，这个类型实际上是一个
<code>int</code> 类型，但是从名字上我们可以看到，它被命名为任意类型，
也就是说，他会被我们用来表示任意的类型，具体怎么用，是下面说的
<code>unsafe.Pointer</code> 用的。</p>
<h3 id="integertype">IntegerType</h3>
<p><code>type IntegerType int</code>，它表示的是一个任意的整数，在
<code>unsafe</code> 包中它被用来作为表示切片或者指针加减的长度。</p>
<h3 id="pointer">Pointer</h3>
<p><code>type Pointer *ArbitraryType</code>，这个就是我们上一节提到的指针了，它可以指向任何类型的数据（<code>*ArbitraryType</code>）。</p>
<blockquote>
<p>内存地址实际上就是计算机内存的编号，是一个整数，所以我们才可以使用
<code>int</code> 来表示指针。</p>
</blockquote>
<h2 id="unsafe-包计算内存的三个方法">unsafe 包计算内存的三个方法</h2>
<p>这几个方法在我们对内存进行操作的时候会非常有帮助，因为根据这几个方法，我们才可以得知底层数据类型的实际大小。</p>
<h3 id="sizeof">Sizeof</h3>
<p>计算 <code>x</code>
所需要的内存大小（单位为字节），如果其中包含了引用类型，<code>Sizeof</code>
不会计算引用指向的内容的大小。</p>
<p>有几种常见的情况（没有涵盖全部情况）：</p>
<ul>
<li>基本类型，如
<code>int8</code>、<code>int</code>，<code>Sizeof</code>
返回的是这个类型本身的大小，如 <code>unsafe.Sizeof(int8(x))</code> 为
1，因为 <code>int8</code> 只占用一个字节。</li>
<li>引用类型，如 <code>var x *int</code>，<code>Sizeof(x)</code> 会返回
8（在我的机器上，不同机器可能不一样），另外就算引用指向了一个复合类型，比如结构体，返回的还是
8（因为变量本身存储的只是内存地址）。</li>
<li>结构体类型，如果是结构体，那么 <code>Sizeof</code>
返回的大小包含了用于内存对齐的内存（所以可能会比结构体底层类型所需要的实际大小要大）</li>
<li>切片，<code>Sizeof</code> 返回的是
24（返回的是切片这个类型所需要占用空间的大小，我们需要知道，切片底层是
<code>slice</code> 结构体，里面三个字段分别是
<code>array unsafe.Pointer</code>、<code>len int</code> 和
<code>cap int</code>，这三个字段所需要的大小为 24）</li>
<li>字符串，跟切片类似，<code>Sizeof</code> 会返回
16，因为字符串底层是一个用来存储字符串内容的 <code>unsafe.Pointer</code>
指针和一个表示长度的 <code>int</code>，所以是 16。</li>
</ul>
<blockquote>
<p>这个方法返回的大小跟机器密切相关，但一般开发者的电脑都是 64
位的，调用这个函数的值应该跟我的机器上得到的一样。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> School <span class="keyword">struct</span> &#123;</span><br><span class="line">	students []Person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int8</span></span><br><span class="line">	<span class="keyword">var</span> y <span class="type">int</span></span><br><span class="line">	<span class="comment">// 1 8</span></span><br><span class="line">	<span class="comment">// int8 占用 1 个字节，int 占用 8 个字节</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(x), unsafe.Sizeof(y))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">	<span class="comment">// 8</span></span><br><span class="line">	<span class="comment">// 指针变量占用 8 个字节</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(p))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> person Person</span><br><span class="line">	<span class="comment">// 4</span></span><br><span class="line">	<span class="comment">// age 内存对齐需要 2 个字节</span></span><br><span class="line">	<span class="comment">// score 也需要两个字节</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(person))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> school School</span><br><span class="line">	<span class="comment">// 24</span></span><br><span class="line">	<span class="comment">// 只有一个切片字段，切片需要 24 个字节</span></span><br><span class="line">	<span class="comment">// 不管这个切片里面有多少数据，school 所需要占用的内存空间都是 24 字节</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(school))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">	<span class="comment">// 16</span></span><br><span class="line">	<span class="comment">// 字符串底层是一个 unsafe.Pointer 和一个 int</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="offsetof-方法">Offsetof 方法</h3>
<p>这个方法用于计算结构体字段的内存地址相对于结构体内存地址的偏移。具体来说就是，我们可以通过
<code>&amp;</code>（取地址）操作符获取结构体地址。</p>
<blockquote>
<p>实际上，结构体地址就是结构体中第一个字段的地址。</p>
</blockquote>
<p>拿到了结构体的地址之后，我们可以通过 <code>Offsetof</code>
方法来获取结构体其他字段的偏移量，下面是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> person Person</span><br><span class="line">	<span class="comment">// 0 2</span></span><br><span class="line">	<span class="comment">// person.age 是第一个字段，所以是 0</span></span><br><span class="line">	<span class="comment">// person.score 是第二个字段，因为需要内存对齐，实际上 age 占用了 2 个字节，</span></span><br><span class="line">	<span class="comment">// 因此 unsafe.Offsetof(person.score) 是 2，也就是说从第二个字节开始才是 person.score</span></span><br><span class="line">	fmt.Println(unsafe.Offsetof(person.age), unsafe.Offsetof(person.score))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们上面也说了，编译器会对结构体做一些内存对齐的操作，这会导致结构体底层字段占用的内存大小会比实际需要的大小要大。
因此，我们在取结构体字段地址的时候，最好是通过结构体地址加上
<code>unsafe.Offsetof(x.y)</code> 拿到的地址来操作。如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> person = Person&#123;</span><br><span class="line">		age:   <span class="number">10</span>,</span><br><span class="line">		score: <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// &#123;10 20&#125;</span></span><br><span class="line">	fmt.Println(person)</span><br><span class="line">	<span class="comment">// 取得 score 字段的指针</span></span><br><span class="line">	<span class="comment">// 通过结构体地址，加上 score 字段的偏移量，得到 score 字段的地址</span></span><br><span class="line">	score := (*<span class="type">int16</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;person)) + unsafe.Offsetof(person.score)))</span><br><span class="line">	*score = <span class="number">30</span></span><br><span class="line">	<span class="comment">// &#123;10 30&#125;</span></span><br><span class="line">	fmt.Println(person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子看起来有点复杂，但是没关系，后面会详细展开的，这里主要要说明的是：</p>
<p>我们通过 <code>unsafe.Pointer</code>
来操作结构体底层字段的时候，我们是通过 <code>unsafe.Offsetof</code>
来获取结构体字段地址偏移量的，
因为我们看到的类型大小并不是内存实际占用的大小，通过
<code>Offsetof</code> 拿到的结果是已经将内存对齐等因素考虑在内的了。
（如果我们错误的认为 <code>age</code> 只占用一个字节，然后将
<code>unsafe.Offsetof(person.score)</code> 替换为 1，那么我们就修改不了
score 字段了）</p>
<h3 id="alignof-方法">Alignof 方法</h3>
<p>这个方法用以获取某一个类型的对齐系数，就是对齐一个类型的时候需要多少个字节。
这个对开发者而言意义不是非常大，go 里面只有 <code>WaitGroup</code>
用到了一下，
没有看到其他地方有用到这个方法，所以本文不展开了，有兴趣的自行了解。</p>
<h2 id="unsafe.pointer-是什么">unsafe.Pointer 是什么？</h2>
<p>让我们再来回顾一下，<code>Pointer</code> 的定义是
<code>type Pointer *ArbitraryType</code>，也就是一个指向任意类型的指针类型。
首先它是指针类型，所以我们初始化 <code>unsafe.Pointer</code>
的时候，需要通过 <code>&amp;</code>
操作符来将变量的地址传递进去。我们可以将其想象为指针类型的包装类型。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">	<span class="comment">// 打印出 a 的地址：0xc0000240a8</span></span><br><span class="line">	fmt.Println(unsafe.Pointer(&amp;a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unsafe.pointer-类型转换">unsafe.Pointer 类型转换</h2>
<p>在使用 <code>unsafe.Pointer</code>
的时候，往往需要另一个类型来配合，那就是 <code>uintptr</code>，这个
<code>uintptr</code> 在文档里面的描述是： <code>uintptr</code>
是一种整数类型，其大小足以容纳<strong>任何指针</strong>的位模式。这里的关键是
"任何指针"，
也就是说，<strong>它设计出来是被用来存储指针的，而且其大小保证能存储下任何指针。</strong></p>
<p>而我们知道 <code>unsafe.Pointer</code> 也是表示指针，那么
<code>uintptr</code> 跟 <code>unsafe.Pointer</code> 有什么区别呢？</p>
<p><strong>只需要记住最关键的一点，<code>uintptr</code>
是内存地址的整数表示，而且可以进行算术运算，而
<code>unsafe.Pointer</code>
除了可以表示一个内存地址之外，还能保证其指向的内存不会被垃圾回收器回收，但是
<code>uintptr</code>
这个地址不能保证其指向的内存不被垃圾回收器回收。</strong></p>
<p>我们先来看看与 <code>unsafe.Pointer</code>
相关的几种类型转换，这在我们下文几乎所有地方都会用到：</p>
<ul>
<li>任何类型的指针值都能转换为 <code>unsafe.Pointer</code></li>
<li><code>unsafe.Pointer</code> 可以转换为一个指向任何类型的指针值</li>
<li><code>unsafe.Pointer</code> 可以转换为 <code>uintptr</code></li>
<li><code>uintptr</code> 可以转换为 <code>unsafe.Pointer</code></li>
</ul>
<p>例子（下面这个例子中输出的地址都是变量 <code>a</code>
所在的内存地址，都是一样的地址）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> p = &amp;a</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. int 类型指针转换为 unsafe.Pointer</span></span><br><span class="line">	fmt.Println(unsafe.Pointer(p)) <span class="comment">// 0xc0000240a8</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. unsafe.Pointer 转换为普通类型的指针</span></span><br><span class="line">	pointer := unsafe.Pointer(&amp;a)</span><br><span class="line">	<span class="keyword">var</span> pp *<span class="type">int</span> = (*<span class="type">int</span>)(pointer) <span class="comment">// 0xc0000240a8</span></span><br><span class="line">	fmt.Println(pp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. unsafe.Pointer 可以转换为 uintptr</span></span><br><span class="line">	<span class="keyword">var</span> p1 = <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, p1) <span class="comment">// c0000240a8，没有 0x 前缀</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. uintptr 可以转换为 unsafe.Pointer</span></span><br><span class="line">	p2 := unsafe.Pointer(p1)</span><br><span class="line">	fmt.Println(p2) <span class="comment">// 0xc0000240a8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何正确地使用指针">如何正确地使用指针？</h2>
<p>指针允许我们忽略类型系统而对任意内存进行读写，这是非常危险的，所以我们在使用指针的时候要格外的小心。</p>
<p>我们使用 <code>Pointer</code>
的模式有以下几种，如果我们不是按照以下模式来使用 <code>Pointer</code>
的话，那使用的方式很可能是无效的，
或者在将来变得无效，但就算是下面的几种使用模式，也有需要注意的地方。</p>
<p>运行 <code>go vet</code> 可以帮助查找不符合这些模式的
<code>Pointer</code> 的用法，但 <code>go vet</code>
没有警告也并不能保证代码有效。</p>
<p>以下我们就来详细学习一下使用 <code>Pointer</code>
的几种正确的模式：</p>
<h3 id="将-t1-转换为指向-t2-的-pointer">1. 将 <code>*T1</code>
转换为指向 <code>*T2</code> 的 <code>Pointer</code></h3>
<p>前提条件：</p>
<ul>
<li><code>T2</code> 类型所需要的大小不大于 <code>T1</code>
类型的大小。（大小大的类型转换为占用空间更小的类型）</li>
<li><code>T1</code> 和 <code>T2</code> 的内存布局一样。</li>
</ul>
<blockquote>
<p>这是因为如果直接将占用空间小的类型转换为占用空间更大的类型的话，多出来的部分是不确定的内容，当然我们也可以通过
<code>unsafe.Pointer</code> 来修改这部分内容。</p>
</blockquote>
<p>这种转换允许将一种类型的数据重新解释为另外一种数据类型。下面是一个例子（为了方便演示用了
<code>int32</code> 和 <code>int8</code> 类型）：</p>
<blockquote>
<p>在这个例子中，<code>int8</code> 类型不大于 <code>int32</code>
类型，而且它们的内存布局是一样的，所以可以转换。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int32</span> = <span class="number">2</span></span><br><span class="line">	<span class="comment">// p 是 *int8 类型，由 *int32 转换而来</span></span><br><span class="line">	<span class="keyword">var</span> p = (*<span class="type">int8</span>)(unsafe.Pointer(&amp;a))</span><br><span class="line">	<span class="keyword">var</span> b <span class="type">int8</span> = *p</span><br><span class="line">	fmt.Println(b) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>unsafe.Pointer(&amp;a)</code> 是指向 <code>a</code> 的
<code>unsafe.Pointer</code>（本质上是指向 <code>int32</code>
的指针），<code>(*int8)</code> 表示类型转换，将这个
<code>unsafe.Pointer</code> 转换为 <code>(*int8)</code> 类型。</p>
<p>觉得代码不好理解的可以看下图：</p>
<p><img src="/images/go/unsafe/pattern_1.png" /></p>
<p>在上图，我们实际上是创建了一个指向了 <code>a</code> 最低位那 1
字节的指针，然后取出了这个字节里面存储的内容，将其存入了 <code>b</code>
中。</p>
<p>上面提到有一个比较重要的地方，那就是：转换的时候是占用空间大的类型，转换为占用空间小的类型，比如
<code>int32</code> 转 <code>int8</code> 就是符合这个条件的，
那么如果我们将一个小的类型转换为大的类型会发生什么呢？我们来看看下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">	b <span class="type">int8</span></span><br><span class="line">	c <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = A&#123;<span class="number">1</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> b = B&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 大转小</span></span><br><span class="line">	<span class="keyword">var</span> pa = (*A)(unsafe.Pointer(&amp;b))</span><br><span class="line">	fmt.Println(*pa) <span class="comment">// &#123;2&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 错误示例：小转大（危险，A 里面 a 后面的内存其实是未知的）</span></span><br><span class="line">	<span class="keyword">var</span> pb = (*B)(unsafe.Pointer(&amp;a))</span><br><span class="line">	fmt.Println(*pb) <span class="comment">// &#123;1 2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大转小：<code>*B</code> 转换为 <code>*A</code>
的具体转换过程可以表示为下图：</p>
<p><img src="/images/go/unsafe/pattern_1_2.png" /></p>
<p>在这个过程中，其实 <code>a</code> 和 <code>b</code>
都没有改变，本质上我们只是创建了一个 <code>A</code> 类型的指针，
这个指针指向变量 <code>b</code> 的地址（但是 <code>*pa</code> 会被看作是
<code>A</code> 类型），所以 <code>pa</code> 实际上是跟 <code>b</code>
共享了内存。 我们可以尝试修改 <code>(*pa).a = 3</code>，我们就会发现
<code>b.b</code> 也变成了 3。</p>
<p>也就是说，最终的内存布局是下图这样的：</p>
<p><img src="/images/go/unsafe/pattern_1_3.png" /></p>
<p>小转大：<code>*A</code> 转换为 <code>*B</code>
的具体转换过程可以表示为下图：</p>
<p><img src="/images/go/unsafe/pattern_1_4.png" /></p>
<p><strong>注意：这是错误的用法。(当然也不是完全不行)</strong></p>
<p>在 <code>*A</code> 转换为 <code>*B</code> 的过程中，因为
<code>B</code> 需要 2 个字节空间，所以我们拿到的 <code>pb</code>
实际上是包含了 <code>a</code> 后面的 1 个字节，
<strong>但是这个字节本来是属于 <code>b</code> 变量的</strong>，这个时候
<code>b</code> 和 <code>*pb</code> 都引用了第 2
个字节，这样依赖它们在修改这个字节的时候，
会相互影响，这可能不是我们想要的结果，而且这种操作非常危险。</p>
<h3 id="将-pointer-转换为-uintptr但不转换回-pointer">2. 将
<code>Pointer</code> 转换为 <code>uintptr</code>（但不转换回
<code>Pointer</code>）</h3>
<p>将 <code>Pointer</code> 转换为 <code>uintptr</code> 会得到
<code>Pointer</code> 指向的内存地址，是一个整数。这种
<code>uintptr</code> 的通常用途是打印它。</p>
<p>但是，<strong>将 <code>uintptr</code> 转换回 <code>Pointer</code>
通常无效</strong>。 <code>uintptr</code>
是一个整数，而不是一个引用。将指针转换为 <code>uintptr</code>
会创建一个没有指针语义的整数值。 即使 <code>uintptr</code>
持有某个对象的地址，如果该对象移动，垃圾收集器也不会更新该
<code>uintotr</code> 的值， 也不会阻止该对象被回收。</p>
<p>如下面这种，我们取得了变量的地址
<code>p</code>，然后做了一些其他操作，最后再从这个地址里面读取数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> p = <span class="type">uintptr</span>(unsafe.Pointer(&amp;a))</span><br><span class="line">	<span class="comment">// ... 其他代码</span></span><br><span class="line">	<span class="comment">// 下面这种转换是危险的，因为有可能 p 指向的对象已经被垃圾回收器回收</span></span><br><span class="line">	fmt.Println(*(*<span class="type">int</span>)(unsafe.Pointer(p)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体如下图：</p>
<p><img src="/images/go/unsafe/pattern_2.png" /></p>
<p>只有下面的模式中转换 <code>uintptr</code> 到 <code>Pointer</code>
是有效的。</p>
<h3 id="使用算术运算将-pointer-转换为-uintptr-并转换回去">3.
使用算术运算将 <code>Pointer</code> 转换为 <code>uintptr</code>
并转换回去</h3>
<p>如果 <code>p</code> 指向一个已分配的对象，我们可以将 <code>p</code>
转换为 <code>uintptr</code> 然后加上一个偏移量，再转换回
<code>Pointer</code>。如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = unsafe.Pointer(<span class="type">uintptr</span>(p) + offset)</span><br></pre></td></tr></table></figure>
<p>这种模式最常见的用法是访问结构体或者数组元素中的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于 f := unsafe.Pointer(&amp;s.f)</span></span><br><span class="line">f := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 e := unsafe.Pointer(&amp;x[i])</span></span><br><span class="line">e := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;x)) + i*unsafe.Sizeof(x[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<p>对于第一个例子，完整代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">	d <span class="type">int8</span></span><br><span class="line">	f <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s = S&#123;</span><br><span class="line">		d: <span class="number">1</span>,</span><br><span class="line">		f: <span class="number">2</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	f := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))</span><br><span class="line">	fmt.Println(*(*<span class="type">int8</span>)(f)) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的内存布局如下图（<code>s</code> 的两个字段都是 1 字节，所以图中
<code>d</code> 和 <code>f</code> 都是 1 字节）：</p>
<p><img src="/images/go/unsafe/pattern_3.png" /></p>
<p>详细说明一下：</p>
<blockquote>
<p>第一小节我们说过了，结构体字段的内存布局是连续的。上面没有说的是，其实数组的内存布局也是连续的。这对理解下面的内容很有帮助。</p>
</blockquote>
<ul>
<li><code>&amp;s</code> 取得了结构体 <code>s</code> 的地址</li>
<li><code>unsafe.Pointer(&amp;s)</code> 转换为 <code>Pointer</code>
对象，这个指针对象指向的是结构体 <code>s</code></li>
<li><code>uintptr(unsafe.Pointer(&amp;s))</code> 取得
<code>Pointer</code> 对象的内存地址（整数）</li>
<li><code>unsafe.Offsetof(s.f)</code> 取得了 <code>f</code>
字段的内存偏移地址（相对地址，相对于 <code>s</code> 的地址）</li>
<li><code>uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f)</code>
就是 <code>s.f</code> 的实际内存地址了（绝对地址）</li>
<li>最后转换回 <code>unsafe.Pointer</code> 对象，这个对象指向的地址是
<code>s.f</code> 的地址</li>
</ul>
<p>最终 <code>f</code> 指向的地址是 <code>s.f</code>，然后我们可以通过
<code>(*int8)(f)</code> 将 <code>unsafe.Pointer</code> 转换为
<code>*int8</code> 类型指针，最后通过 <code>*</code>
操作符取得这个指针指向的值。</p>
<p>对于第二个例子，完整代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x = [<span class="number">3</span>]<span class="type">int8</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	e := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;x)) + <span class="number">2</span>*unsafe.Sizeof(x[<span class="number">0</span>]))</span><br><span class="line">	fmt.Println(*(*<span class="type">int8</span>)(e)) <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的内存布局如下图，<code>e</code> 指向了数组的第 3 个元素（下标从
0 开始算的）：</p>
<p><img src="/images/go/unsafe/pattern_3_2.png" /></p>
<blockquote>
<p>代码中的 2 可以是其他任何有效的数组下标。</p>
</blockquote>
<ul>
<li><code>&amp;s</code> 取得了数组 <code>x</code> 的地址</li>
<li><code>unsafe.Pointer(&amp;x)</code> 转换为 <code>Pointer</code>
对象，这个指针对象指向的是数组 <code>x</code></li>
<li><code>uintptr(unsafe.Pointer(&amp;x))</code> 取得
<code>Pointer</code> 对象的内存地址（也就是 <code>0xab</code>）</li>
<li><code>unsafe.Sizeof(x[0])</code> 是数组 <code>x</code>
里面每一个元素所需要的内存大小，乘以 <code>2</code> 表示是元素
<code>x[2]</code> 的地址偏移量（相对地址，相对于 <code>x[0]</code>
的地址）</li>
<li><code>uintptr(unsafe.Pointer(&amp;x)) + 2*unsafe.Sizeof(x[0])</code>
表示的是数组元素 <code>x[2]</code> 的实际内存地址（绝对地址）</li>
<li>最后转换回 <code>unsafe.Pointer</code> 对象，这个对象指向的地址是
<code>x[2]</code> 的地址（也就是 <code>0xab + 2</code>）。</li>
</ul>
<p>最终，我们可以通过 <code>(*int8)</code> 将 <code>e</code> 转换为
<code>*int8</code> 类型的指针，最后通过 <code>*</code>
操作符获取其指向的内容，也就是 6。</p>
<p>以这种方式对指针进行加减偏移量的运算都是有效的。(em...这里说的是写在同一行的这种方式)。这种情况下使用
<code>&amp;^</code> 这两个操作符也是有效的（通常用于内存对齐）。
在所有情况下，得到的结果必须指向原始分配的对象。</p>
<p>不像 C
语言，将指针加上一个超出其原始分配的内存区域的偏移量是无效的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效: end 指向了分配的空间以外的区域</span></span><br><span class="line"><span class="keyword">var</span> s thing</span><br><span class="line">end = unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Sizeof(s))</span><br></pre></td></tr></table></figure>
<p><img src="/images/go/unsafe/pattern_3_3.png" /></p>
<blockquote>
<p>下面对切片的这种操作也跟上图类似。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效: end 指向了分配的空间以外的区域</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">end = unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>])) + <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>
<p>这是因为，内存的地址范围是
<code>[start, end)</code>，是不包含终点的那个地址的，上面的
<code>end</code> 都指向了地址的边界，这是无效的。
当然，除了边界上，边界以外都是无效的。（<code>end</code>
指向的内存不是属于那个变量的）</p>
<p>注意：两个转换(<code>Pointer</code> =&gt; <code>uintptr</code>,
<code>uintptr</code> =&gt;
<code>Pointer</code>)必须出现在同一个表达式中，只有中间的算术运算：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效: uintptr 在转换回 Pointer 之前不能存储在变量中</span></span><br><span class="line"><span class="comment">// 原因上面也说过了，就是 p 指向的内容可能会被垃圾回收器回收。</span></span><br><span class="line">u := <span class="type">uintptr</span>(p)</span><br><span class="line">p = unsafe.Pointer(u + offset)</span><br></pre></td></tr></table></figure>
<p>注意：指针必须指向已分配的对象，因此它不能是 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效: nil 指针转换</span></span><br><span class="line">u := unsafe.Pointer(<span class="literal">nil</span>)</span><br><span class="line">p := unsafe.Pointer(<span class="type">uintptr</span>(u) + offset)</span><br></pre></td></tr></table></figure>
<h3 id="调用-syscall.syscall-时将指针转换为-uintptr">4. 调用
<code>syscall.Syscall</code> 时将指针转换为 <code>uintptr</code></h3>
<p>觉得文字太啰嗦可以直接看图：</p>
<p><img src="/images/go/unsafe/pattern_4.png" /></p>
<p><code>syscall</code> 包中的 <code>Syscall</code> 函数将其
<code>uintptr</code>
参数直接传递给操作系统，然后操作系统可以根据调用的细节将其中一些参数重新解释为指针。
也就是说，系统调用实现隐式地将某些参数从 <code>uintptr</code>
转换回指针。</p>
<p>如果必须将指针参数转换为 <code>uintptr</code>
以用作参数，则该转换必须出现在调用表达式本身中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall.Syscall(SYS_READ, <span class="type">uintptr</span>(fd), <span class="type">uintptr</span>(unsafe.Pointer(p)), <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>
<p>编译器通过安排被引用的分配对象（如果有的话）被保留，并且在调用完成之前不移动，来处理在调用程序集中实现的函数的参数列表中转换为
<code>uintptr</code> 的指针，
即使仅从类型来看，在调用期间似乎不再需要对象。</p>
<p>为了使编译器识别该模式，转换必须出现在参数列表中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效：在系统调用期间隐式转换回指针之前，</span></span><br><span class="line"><span class="comment">// uintptr 不能存储在变量中。</span></span><br><span class="line">u := <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">syscall.Syscall(SYS_READ, <span class="type">uintptr</span>(fd), u, <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>
<h3
id="将-reflect.value.pointer-或-reflect.value.unsafeaddr-的结果从-uintptr-转换为-pointer">5.
将 <code>reflect.Value.Pointer</code> 或
<code>reflect.Value.UnsafeAddr</code> 的结果从 <code>uintptr</code>
转换为 <code>Pointer</code></h3>
<p><code>reflect.Value</code> 的 <code>Pointer</code> 和
<code>UnsafeAddr</code> 方法返回类型 <code>uintptr</code> 而不是
<code>unsafe.Pointer</code>， 从而防止调用者在未导入 <code>unsafe</code>
包的情况下将结果更改为任意类型。（这是为了防止开发者对
<code>Pointer</code> 的误操作。）
然而，<strong>这也意味着这个返回的结果是脆弱的，我们必须在调用之后立即转换为
<code>Pointer</code></strong>（如果我们确切的需要一个
<code>Pointer</code>）：</p>
<blockquote>
<p>其实就是为了让开发者明确自己知道在干啥，要不然写出了 bug
都不知道。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在调用了 reflect.Value 的 Pointer 方法后，</span></span><br><span class="line"><span class="comment">// 立即转换为 unsafe.Pointer。</span></span><br><span class="line">p := (*<span class="type">int</span>)(unsafe.Pointer(reflect.ValueOf(<span class="built_in">new</span>(<span class="type">int</span>)).Pointer()))</span><br></pre></td></tr></table></figure>
<p>与上述情况一样，在转换之前存储结果是无效的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效: uintptr 在转换回 Pointer 之前不能保存在变量中</span></span><br><span class="line">u := reflect.ValueOf(<span class="built_in">new</span>(<span class="type">int</span>)).Pointer() <span class="comment">// uintptr 保存到了 u 中</span></span><br><span class="line">p := (*<span class="type">int</span>)(unsafe.Pointer(u))</span><br></pre></td></tr></table></figure>
<p>原因上面也说了，因为 <code>u</code>
指向的内存是不受保护的，可能会被垃圾回收器收集。</p>
<h3
id="将-reflect.sliceheader-或-reflect.stringheader-的-data-字段跟-pointer-互相转换">6.
将 <code>reflect.SliceHeader</code> 或 <code>reflect.StringHeader</code>
的 <code>Data</code> 字段跟 <code>Pointer</code> 互相转换</h3>
<p>与前面的情况一样，反射数据结构 <code>SliceHeader</code> 和
<code>StringHeader</code> 将字段 <code>Data</code> 声明为
<code>uintptr</code>， 以防止调用者在不首先导入 <code>unsafe</code>
的情况下将结果更改为任意类型。 然而，这意味着 <code>SliceHeader</code>
和 <code>StringHeader</code>
仅在解析实际切片或字符串值的内容时有效。</p>
<p>我们先来看看这两个结构体的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SliceHeader 是切片的运行时表示（内存布局跟切片一致）</span></span><br><span class="line"><span class="comment">// 它不能安全或可移植地使用，其表示形式可能会在以后的版本中更改。</span></span><br><span class="line"><span class="comment">// 此外，Data 字段不足以保证它引用的数据不会被垃圾回收器收集，</span></span><br><span class="line"><span class="comment">// 因此程序必须保留一个指向底层数据的单独的、正确类型的指针。</span></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">	Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringHeader 字符串的运行时表示（内存布局跟字符串一致）</span></span><br><span class="line"><span class="comment">// ... 其他注意事项跟 SliceHeader 一样</span></span><br><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span></span><br><span class="line">    Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串的内容修改为 p 指向的内容</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">hdr.Data = <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">hdr.Len = n</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种转换是有效的，因为 SliceHeader 的内存布局和 StringHeader
的内存布局一致，并且 SliceHeader 所占用的内存空间比 StringHeader
所占用内存空间大，也就是说，这是一种大小更大的类型转换为大小更小的类型，这会丢失
SliceHeader 的一部分数据，
但是丢失的那部分对我们程序正常运行是没有任何影响的。</p>
</blockquote>
<p>在这个用法中，<code>hdr.Data</code>
实际上是引用字符串头中的基础指针的另一种方式，而不是 uintptr 变量本身。
（我们这里也是使用了 <code>uintptr</code> 表达式，而不是一个存储了
<code>uintptr</code> 类型的变量）</p>
<p>通常来说，<code>reflect.SliceHeader</code> 和
<code>reflect.StringHeader</code> 通常用在指向实际切片或者字符串的
<code>*reflect.SliceHeader</code> 和
<code>*reflect.StringHeader</code>，<strong>永远不会被当作普通结构体使用</strong>。
程序不应该声明或者分配这些结构体类型的变量，下面的写法是有风险的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效: 直接声明的 Header 不会将 Data 作为引用</span></span><br><span class="line"><span class="keyword">var</span> hdr reflect.StringHeader</span><br><span class="line">hdr.Data = <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">hdr.Len = n</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;hdr)) <span class="comment">// p 可能已经丢失</span></span><br></pre></td></tr></table></figure>
<h2 id="add-函数">Add 函数</h2>
<p>函数原型是：<code>func Add(ptr Pointer, len IntegerType) Pointer</code></p>
<p>这个函数的作用是，可以将 <code>unsafe.Pointer</code>
类型加上一个偏移量得到一个指向新地址的 <code>unsafe.Pointer</code>。
简单点来说，就是对 <code>unsafe.Pointer</code>
做算术运算的，上面我们说过 <code>unsafe.Pointer</code>
是不能直接进行算术运算的， 因此需要先转换为 <code>uintptr</code>
然后再进行算术运算，算完再转换回 <code>unsafe.Pointer</code>
类型，所以会很繁琐。 有了 <code>Add</code>
方法，我们可以写得简单一些，不用做 <code>uintptr</code> 的转换。</p>
<p>有了
<code>Add</code>，我们可以简化一下上面那个通过数组指针加偏移量的例子，示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x = [<span class="number">3</span>]<span class="type">int8</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	<span class="comment">//e := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;x)) + 2*unsafe.Sizeof(x[0]))</span></span><br><span class="line">	e := unsafe.Add(unsafe.Pointer(&amp;x), <span class="number">2</span> * unsafe.Sizeof(x[<span class="number">0</span>]))</span><br><span class="line">	fmt.Println(*(*<span class="type">int8</span>)(e)) <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们先是通过 <code>unsafe.Pointer(&amp;x)</code>
获取到了一个指向 <code>x</code> 的 <code>unsafe.Pointer</code> 对象，
然后通过 <code>unsafe.Add</code> 加上了 2 个 <code>int8</code>
类型大小的偏移量，最终得到的是一个指向 <code>x[2]</code> 的
<code>unsafe.Pointer</code>。</p>
<blockquote>
<p><code>Add</code> 方法可以简化我们对指针的一些操作。</p>
</blockquote>
<h2 id="slice-函数">Slice 函数</h2>
<p><code>Slice</code>
函数的原型是：<code>func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType</code></p>
<p>函数 <code>Slice</code> 返回一个切片，其底层数组以 <code>ptr</code>
开头，长度和容量为 <code>len</code>。</p>
<p><code>unsafe.Slice(ptr, len)</code> 等价于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*[<span class="built_in">len</span>]ArbitraryType)(unsafe.Pointer(ptr))[:]</span><br></pre></td></tr></table></figure>
<p>除了这个，作为一种特殊情况，如果 <code>ptr</code> 为
<code>nil</code>，<code>len</code> 为零，则 <code>Slice</code> 返回
<code>nil</code>。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x = [<span class="number">6</span>]<span class="type">int8</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="comment">// 这里取了数组第一个元素 x[1] 的地址，</span></span><br><span class="line">	<span class="comment">// 从这个地址开始取了 3 个元素作为新的切片底层数组，</span></span><br><span class="line">	<span class="comment">// 返回这个新的切片</span></span><br><span class="line">	s := unsafe.Slice(&amp;x[<span class="number">1</span>], <span class="number">3</span>)</span><br><span class="line">	fmt.Println(s) <span class="comment">// [5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要非常注意的是，第一个参数实际上隐含传递了该地址对应的类型信息，上面用了
<code>&amp;x[1]</code>，传递的类型实际上是 <code>int8</code>。</p>
</blockquote>
<p>如果我们按照下面这样写，得到的结果就是错误的，因为它隐式传递的类型是
<code>[6]int8</code>（这是一个数组），而不是 <code>int8</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x = [<span class="number">6</span>]<span class="type">int8</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="comment">// unsafe.Slice 第一个参数接收到的类型是 [6]int，</span></span><br><span class="line">	<span class="comment">// 所以最终返回了一个切片，这个切片有三个元素，</span></span><br><span class="line">	<span class="comment">// 每一个元素都是长度为 6 数据类型为 int8 的数组。</span></span><br><span class="line">	<span class="comment">// 也即形如 [[6]int8, [6]int8, [6]int8] 的切片</span></span><br><span class="line">	s := unsafe.Slice(&amp;x, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// [[4 5 6 7 8 9] [91 91 52 32 53 32] [54 32 4 5 6 7]]</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样显然不是我们想要的结果，因为它读取到了一部分未知的内存，如果我们修改这部分内存，可能会造成程序崩溃。</p>
<h2 id="一个很常见的用法">一个很常见的用法</h2>
<p>在实际应用中，很多框架为了提高性能，在做 <code>[]byte</code> 和
<code>string</code> 的切换的时候，往往会使用 <code>unsafe.Pointer</code>
来实现（比如 <code>gin</code> 框架）：</p>
<p>下面这个例子实现了 <code>[]byte</code> 到 <code>string</code>
的转换，而且避免了内存分配。这是因为，切片和字符串的内存布局是一致的，只不过切片比字符串占用
的空间多了一点，还有一个 <code>cap</code>
容量字段，用来表示切片的容量是多少。具体我们可以再看看上面的
<code>reflect.SliceHeader</code> 和 <code>reflect.StringHeader</code>，
在下面这个字节切片到字符串的转换过程中，是从占用空间更大的类型转换为占用空间更小的类型，所以是安全的，丢失的那个
<code>cap</code> 对我们程序正常运行无影响。</p>
<p>先看看 <code>[]byte</code> 和 <code>string</code>
的类型底层定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	str unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片，比 string 的结构体多了一个 cap 字段，但是前面的两个字段是一样的</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>[]byte</code> 转字符串的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BytesToString</span><span class="params">(b []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 将 b 解析为字符串</span></span><br><span class="line">	<span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个操作如下图：</p>
<p><img src="/images/go/unsafe/bytes_0.png" /></p>
<p>在这个转换过程中，其实只是将 <code>b</code> 表示的类型转由
<code>[]byte</code> 转换为了 <code>string</code>，之所以可以这么转，
是因为 <code>[]byte</code> 的内存布局跟 <code>string</code>
的内存布局是一样的，
但是由于字符串实际占用空间比切片类型要小（不包括其底层指针指向的内容），
所以在转换过程中，<code>cap</code> 字段丢失了，但是 <code>strin</code>
也不需要这个字段，所以对程序运行没影响。</p>
<blockquote>
<p>同时字符串长度是按照字节计算的，所以字节切片和字符串的 len
字段是一样的，不需要做额外处理。</p>
</blockquote>
<p>字符串转 <code>[]byte</code> 的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringToBytes</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *(*[]<span class="type">byte</span>)(unsafe.Pointer(</span><br><span class="line">		<span class="comment">// 定义匿名结构体变量，内存布局跟 []byte 一致，</span></span><br><span class="line">		<span class="comment">// 这样就可以转换为 []byte 了。</span></span><br><span class="line">		&amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="type">string</span></span><br><span class="line">			Cap <span class="type">int</span></span><br><span class="line">		&#125;&#123;s, <span class="built_in">len</span>(s)&#125;,</span><br><span class="line">	))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个操作如下图：</p>
<p><img src="/images/go/unsafe/bytes_1.png" /></p>
<p>这个过程只是需要分配很小一部分内存就可以完成了，效率比 go
自带的转换高。</p>
<blockquote>
<p>go 里面字符串是不可变的，但 go
为了维持字符串不可变的特性，在字符串和字节切片之间转换一般都是通过数据拷贝的方式实现的。
因为这样就不会影响到原来的字符串或者字节切片了，但是这样做的性能会非常低。
具体可参考 <code>slicebytetostring</code> 和
<code>stringtoslicebyte</code> 函数，这两个函数位于
<code>runtime/string.go</code> 中。</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>本文主要讲了如下内容：</p>
<ul>
<li>内存布局：结构体的字段存储是占用了连续的一段内存，而且结构体可能会占用比实际需要空间更大的内存，因为需要对齐内存。</li>
<li>指针存储了指向变量的地址，对这个地址使用 <code>*</code>
操作符可以获取这个地址指向的内容。</li>
<li><code>uintptr</code> 是 C 里面的一种命名惯例，<code>u</code>
前缀的意思是 <code>unsigned</code>，<code>int</code> 表示是
<code>int</code> 类型，<code>ptr</code>
表示这个类型是用来表示指针的。</li>
<li><code>unsafe</code> 定义的 <code>Pointer</code>
类型是一种可以指向任何类型的指针，<code>ArbitraryType</code>
可用于表示任意类型。</li>
<li>我们通过 <code>unsafe.Pointer</code> 修改结构体字段的时候，要使用
<code>unsafe.Offsetof</code> 获取结构体的偏移量。</li>
<li>通过 <code>unsafe.Sizeof</code>
可以获得某一种类型所需要的内存空间大小（其中包括了用于内存对齐的内存）。</li>
<li><code>unsafe.Pointer</code> 与 <code>uintptr</code>
之间的类型转换。</li>
<li>几种使用 <code>unsafe.Pointer</code> 的模式：
<ul>
<li><code>*T1</code> 到 <code>*T2</code> 的转换</li>
<li><code>unsafe.Pointer</code> 转换为 <code>uintptr</code></li>
<li>使用算术运算将 <code>unsafe.Pointer</code> 转换为
<code>uintptr</code> 并转换回去（需要注意不能使用中间变量来保存
<code>uintptr(unsafe.Pointer(p))</code>）</li>
<li>调用 <code>syscall.Syscall</code> 时将指针转换为
<code>uintptr</code></li>
<li>将 <code>reflect.Value</code> 的 <code>Pointer</code> 和
<code>UnsafeAddr</code> 的结果从 <code>uintptr</code> 转换为
<code>unsafe.Pointer</code></li>
<li>将 <code>reflect.SliceHeader</code> 或
<code>reflect.StringHeader</code> 的 <code>Data</code> 字段跟
<code>Pointer</code> 互相转换</li>
</ul></li>
<li><code>Add</code> 函数可以简化指针的算术运算，不用来回转换类型（比如
<code>unsafe.Pointer</code> 转换为 <code>uintptr</code>，然后再转换为
<code>unsafe.Pointer</code>）。</li>
<li><code>Slice</code> 函数可以获取指针指向内存的一部分。</li>
<li>最后介绍了 <code>string</code> 和 <code>[]byte</code> 之间通过
<code>unsafe.Pointer</code> 实现高效转换的方法。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/11/20/golang/go%20Context%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/20/golang/go%20Context%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">go Context 设计与实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-20 20:08:30" itemprop="dateCreated datePublished" datetime="2022-11-20T20:08:30+08:00">2022-11-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>版本：go 1.19</p>
</blockquote>
<p>在前一篇文章中我们讨论了 go <code>Context</code>
的一些常见使用方式，今天我们再来从源码的角度深入了解一下
<code>Context</code> 的设计与实现。 <code>Context</code>
的源码数量不多，去掉注释大概只有两三百行，但是包含的信息量巨大（所以本文也比较长），而且设计得非常巧妙，值得读一读。
然后，下面的 <code>图解 propagateCancel</code> 这一小节的几个图描述了
<code>Context</code> 的工作机制，如果不想看代码，可以直接拉到下面。</p>
<h2 id="再了解一下-chan">再了解一下 chan</h2>
<p>在开始本文之前，先来了解一下 <code>Context</code>
实现的关键：<code>chan</code>，对于
<code>chan</code>（再准确一点，我们这里讨论的其实是只读
<code>chan</code>），我们需要清楚以下几点：</p>
<ul>
<li><code>&lt;-ch</code> 表示从 chan 中获取值。</li>
<li><code>&lt;-ch</code>
在通道（<code>chan</code>）尚未关闭的时候，会一直阻塞，直到通道接收到值。所以有时候通过
<code>select</code> 语句来监听
<code>chan</code>，从而实现协程间的通信。</li>
<li><code>&lt;-ch</code>
在通道（<code>chan</code>）关闭了之后，会立即返回，但是返回的是
<code>chan</code>
关联类型的零值，如果我们还需要判断是否是因为关闭才返回的话，需要用两个值来接收
<code>&lt;-ch</code> 的返回值，如
<code>v, ok := &lt;-ch</code>，<code>ok</code>
表明了通道是否已经关闭，如果是关闭导致它返回，则返回的是
<code>false</code>。</li>
</ul>
<p>下面这个例子展示了 <code>Context</code> 实现的关键（通过
<code>close(chan)</code>，所有 <code>&lt;-chan</code>
会返回，本质上来说是一种 "广播机制"）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个 chan，类型是 struct&#123;&#125;</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 这个 case 会在 chan 关闭或者收到值的时候执行，</span></span><br><span class="line">		<span class="comment">// 在这里的情况是关闭了 chan。</span></span><br><span class="line">		<span class="keyword">case</span> v, ok := &lt;-ch:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="comment">// 输出 &quot;chan ch is closed.&quot;</span></span><br><span class="line">				fmt.Println(<span class="string">&quot;chan ch is closed.&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 关闭 chan 之后得到的是 ch 的零值，也就是一个空结构体实例</span></span><br><span class="line">			fmt.Println(v) <span class="comment">// &#123;&#125;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭 chan，所有从 chan 读取的操作都会立即返回。</span></span><br><span class="line">	<span class="comment">// 关闭 chan 之后，&lt;-ch 返回的第一个值是 chan 对应类型的零值，第二个参数是 false。</span></span><br><span class="line">	<span class="comment">// 如果不是关闭的 chan，第二个参数是 true，表示可以从 chan 获取到数据。</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 防止程序退出看不到效果</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &#123;&#125;，chan struct&#123;&#125; 关闭后，从中获取值的时候会立即返回一个空结构体实例</span></span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 <code>Context</code> 中，<code>context.Done()</code> 方法返回的
<code>chan</code>，不会接收任何的值，但是在调用 <code>CancelFunc</code>
的时候，会关闭这个 <code>chan</code>，因此 所有的
<code>&lt;-context.Done()</code>
会返回一个零值，返回什么不重要，重要的是，它返回的时候就代表着被上游取消了（代表的是一个取消信号）。</p>
</blockquote>
<h2 id="context-的-uml-图">Context 的 UML 图</h2>
<p>先来看看它的 UML 图，在后面会陆续展开细说。</p>
<p><img src="/images/go/context/context_uml.png" /></p>
<ul>
<li>首先，有两个关键的接口，分别是 <code>Context</code> 和
<code>canceler</code>。<code>Context</code>
里面的接口是我们实际开发的时候用的，而 <code>canceler</code> 是
<code>context</code> 包内部使用， 这个 <code>canceler</code>
接口定义了一个 <code>cancel</code>
方法，这个方法就是用来发送取消信号的。</li>
<li><code>emptyCtx</code> 代表一个空的 <code>Context</code>，往往用作根
<code>Context</code>，<code>valueCtx</code> 在父 <code>Context</code>
的基础上加了一个键值对。</li>
<li><code>cancelCtx</code> 同时实现了 <code>Context</code> 和
<code>canceler</code> 接口，表示一个可以取消的
<code>Context</code>。</li>
<li><code>timerCtx</code> 在 <code>cancelCtx</code>
的基础上加了一个定时器，表示可以在指定时间之后由定时器进行取消操作。又或者由开发者自行取消。</li>
</ul>
<h2 id="context-包的结构体方法说明">context 包的结构体、方法说明</h2>
<ul>
<li><code>Context</code> 接口：定义了 <code>Context</code>
接口的四个方法</li>
<li><code>emptyCtx</code> 结构体：一个空 <code>Context</code></li>
<li><code>CancelFunc</code> 函数类型：<code>Context</code>
的取消函数</li>
<li><code>canceler</code> 接口：<code>Context</code> 取消接口</li>
<li><code>cancelCtx</code> 结构体：实现了取消接口的
<code>Context</code></li>
<li><code>timerCtx</code> 结构体：超时会取消的 <code>Context</code></li>
<li><code>valueCtx</code> 结构体：可以存储键值对的
<code>Context</code></li>
<li><code>Background()</code> 函数：返回空
<code>Context</code>，常作为根 <code>Context</code></li>
<li><code>TODO()</code> 函数：返回一个空 <code>Context</code>，在需要
<code>Context</code> 的地方又没有合适的 <code>Context</code>
就用这个</li>
<li><code>WithCancel()</code> 函数：基于父
<code>Context</code>，创建一个可取消的 <code>Context</code></li>
<li><code>newCancelCtx()</code> 函数：创建一个可取消的
<code>Context</code></li>
<li><code>propagateCancel()</code> 函数：将节点挂载到上游第一个
<code>cancelCtx</code> 上，又或者启动协程监听 <code>Context</code>
取消事件</li>
<li><code>parentCancelCtx()</code> 函数：返回上游的第一个
<code>cancelCtx</code></li>
<li><code>removeChild()</code> 函数：移除 <code>Context</code> 节点</li>
<li><code>init()</code> 函数：包初始化函数，创建了一个关闭的
<code>chan</code></li>
<li><code>WithDeadline()</code> 函数：创建一个有 <code>deadline</code>
的 <code>Context</code></li>
<li><code>WithTimeout()</code> 函数：创建一个有 <code>timeout</code> 的
<code>Context</code></li>
<li><code>WithValue()</code> 函数：创建一个存储键值对的
<code>Context</code></li>
</ul>
<h2 id="context-接口">Context 接口</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个 channel，当 context 被取消或者到了 deadline 的时候，</span></span><br><span class="line">	<span class="comment">// 这个 channel 会被 close，从而 &lt;-chan struct&#123;&#125; 会返回。</span></span><br><span class="line">	<span class="comment">// 在没有关闭之前，一直阻塞，因为不会有任何地方往这个 channel 中发送值。</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 channel Done 返回的 channel 关闭后，返回 context 取消原因。</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 context 是否会被取消以及自动取消时间（即 deadline）</span></span><br><span class="line">	<span class="comment">// ok 为 true，表明设置了 deadline，第一个返回值就是设置的 deadline</span></span><br><span class="line">	<span class="comment">// ok 为 false，表示没有设置 deadline，第一个返回值没意义。</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 key 对应的 value</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Context</code> 接口定义了 4
个方法，它们都是幂等的，也就是说连续多次调用同一个方法，得到的结果都是相同的。</p>
<p><code>Deadline()</code> 示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/davecgh/go-spew/spew&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, _ := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="comment">// 输出 ctx 的 deadline，具体时间为 1 秒之后</span></span><br><span class="line">	spew.Dump(ctx.Deadline())</span><br><span class="line"></span><br><span class="line">	ctx1 := context.Background()</span><br><span class="line">	<span class="comment">// ctx1 的超时时间是一个零值</span></span><br><span class="line">	spew.Dump(ctx1.Deadline())</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出：</span></span><br><span class="line">	<span class="comment">// (time.Time) 2022-11-19 11:45:38.702281 +0800 CST m=+1.000233039</span></span><br><span class="line">	<span class="comment">// (bool) true</span></span><br><span class="line">	<span class="comment">// (time.Time) 0001-01-01 00:00:00 +0000 UTC</span></span><br><span class="line">	<span class="comment">// (bool) false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过 <code>Deadline()</code> 方法可以知道当前拿到的
<code>Context</code> 参数是否设置了 deadline，以及 deadline 是什么时候，
从而决定接下来是否还需要做一些操作，如果时间太少的话，就可以考虑不做了，因为最终的结果还是超时。</p>
<h2 id="canceler-接口">canceler 接口</h2>
<p>先看源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现了 <code>canceler</code> 两个方法的
<code>Context</code>，就表明该 <code>Context</code> 是可取消的。</p>
<p><code>cancel</code> 方法的第一个参数 <code>removeFromParent</code>
表示的是，是否从父 <code>Context</code> 移除自身，这是因为
<code>Context</code> 是一个树状结构。 在 <code>Context</code>
取消的时候，它会给所有派生的 <code>Context</code>
也发送取消信号，所以派生新的 <code>Context</code> 的时候会记录从当前
<code>Context</code> 派生出去的 <code>Context</code>。</p>
<p>但同样的，在 <code>Context</code> 被取消的时候，父
<code>Context</code> 也就再也不需要给这个 <code>Context</code>
发送取消信号啥的。</p>
<p><img src="/images/go/context/context_tree.png" /></p>
<p>我们可以看这个图，<code>Context</code> 派生出了三个
<code>Context</code>，当 <code>child 3</code> 这个 <code>Context</code>
<code>cancel</code> 的时候，只会影响到 <code>child 3-1</code> 和
<code>child 3-2</code> 以及其自身， <code>cancel</code> 之后，根结点的
<code>Context</code> 再发送取消信号，<code>child 3</code>
就再也收不到了，因为它已经从这棵树中移除。</p>
<h2 id="emptyctx-结构体">emptyCtx 结构体</h2>
<p><code>emptyCtx</code> 本身没有什么实际的作用，一般用作根
<code>Context</code>，比如在 <code>main</code> 函数里面创建的
<code>Context</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> e &#123;</span><br><span class="line">	<span class="keyword">case</span> background:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">	<span class="keyword">case</span> todo:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;unknown empty Context&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用 <code>context.Background()</code> 或者
<code>context.TODO()</code> 的时候返回的就是一个
<code>emptyCtx</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">	todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>emptyCtx</code> 永远不会被取消，也没有值和
deadline。<code>TODO</code> 用在需要 <code>Context</code> 但又没有合适的
<code>Context</code> 可以用的时候。</p>
<h2 id="cancelctx-结构体">cancelCtx 结构体</h2>
<p><code>cancel</code> 的操作实际上只会做一次，后续调用
<code>cancel</code> 的时候会返回第一次 <code>cancel</code>
的结果，<code>cancel</code> 是一个幂等操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以被取消，取消的时候，所有实现了 canceler 接口的派生出来的 Context 也会被取消。</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// cancelCtx 也实现了 `Context` 接口</span></span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	<span class="comment">// mu 用以保护后面的 done、children、err 字段</span></span><br><span class="line">	mu       sync.Mutex</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 是一个 chan struct&#123;&#125;，懒汉式创建，</span></span><br><span class="line">	<span class="comment">// 在第一次 cancel 的时候被关闭</span></span><br><span class="line">	done     atomic.Value</span><br><span class="line">	<span class="comment">// 记录所有可以取消的子 Context</span></span><br><span class="line">	<span class="comment">// 在第一次 cancel 的时候会被设置为 nil。</span></span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 在第一次 cancel 的时候会被设置为非 nil 的值</span></span><br><span class="line">	err      <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>cancelCtx.done</code> 是一个支持原子操作的
<code>chan struct&#123;&#125;</code>。</p>
</blockquote>
<p>先来看看它的 <code>Done()</code> 方法实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个只读的 chan，但没有任何地方会往这个 chan 写入数据，</span></span><br><span class="line"><span class="comment">// cancel 的时候会关闭这个 chan，从而任何 &lt;-ch 的操作都会立即返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="comment">// 如果 done 这个 chan 已经初始化了，就直接返回。</span></span><br><span class="line">	d := c.done.Load()</span><br><span class="line">	<span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果 done 还没初始化，则会进行初始化。</span></span><br><span class="line">	<span class="comment">// 也就是上面说的 &quot;懒汉式&quot; 的创建方式，只有在需要的时候才会初始化。</span></span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	d = c.done.Load()</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		c.done.Store(d)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看 <code>Err</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 使用 mu 保证并发安全，本质是 return c.err</span></span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	err := c.err</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cancel-方法">cancel 方法</h2>
<p>然后再来看 <code>cancel</code> 方法的实现：</p>
<p><code>cancel</code> 方法做了如下操作：</p>
<ul>
<li>关闭 <code>c.done</code></li>
<li>取消 <code>c</code> 的所有孩子 <code>Context</code></li>
<li>如果 <code>removeFromParent</code> 为 <code>true</code>，会将
<code>c</code> 从其父 <code>Context</code> 的 <code>children</code>
属性中移除</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送取消信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 必须传递一个 err</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果已经取消，直接返回。（幂等的设计）</span></span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 记录取消原因，在调用 c.Err() 的时候会返回这个原因</span></span><br><span class="line">	c.err = err</span><br><span class="line">	<span class="comment">// 关闭 done 这个通道，通知其他协程</span></span><br><span class="line">	d, _ := c.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done.Store(closedchan)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(d)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历它的所有子结点，并对其子结点进行取消操作</span></span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将子结点置空</span></span><br><span class="line">	c.children = <span class="literal">nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从父结点中移除自己</span></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="withcancel-方法">WithCancel 方法</h2>
<p>我们再来看看创建 <code>cancelCtx</code> 的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值里的 Context 的 Done 方法返回的 channel 关闭或者 parent 被 cancel 的时候，</span></span><br><span class="line"><span class="comment">// 返回值的 CancelFunc 会被执行。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">	<span class="comment">// 必须从其他 Context 派生</span></span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	<span class="comment">// 将 c 挂靠到 parent 的 children 属性中，</span></span><br><span class="line">	<span class="comment">// 从而在 parent 取消的时候，可以感知得到。</span></span><br><span class="line">	propagateCancel(parent, &amp;c) <span class="comment">// 具体实现后面有详细说明 </span></span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 cancelCtx 实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> cancelCtx &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到这里的 <code>CancelFunc</code> 的里面调用 <code>cancel</code>
的时候，第一个参数是 <code>true</code>，这表示在取消的时候，需要从
<code>parent</code> 中移除自身。</p>
<h2 id="parentcancelctx-方法">parentCancelCtx 方法</h2>
<p><code>parentCancelCtx</code> 方法用以从 <code>parent</code>
开始直到根节点的路径搜索第一个 <code>cancelCtx</code>，会跳过中间的
<code>valueCtx</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前节点到根节点路径上的第一个 *cancelCtx。</span></span><br><span class="line"><span class="comment">// 如果 parent 就是 *cancelCtx，那么返回的就是 parent。</span></span><br><span class="line"><span class="comment">// 如果不是，它会从当前结点往 Context 树根结点遍历，找到父结点中的第一个 *cancelCtx，假设是 p。</span></span><br><span class="line"><span class="comment">// 然后检查 p.done 是否跟 parent.Done() 一样，不一样的话意味着 *cancelCtx 已经被包装在自定义实现中了，</span></span><br><span class="line"><span class="comment">// 这个时候，我们不应该绕过它，直接返回 nil 和 false。</span></span><br><span class="line"><span class="comment">// （注意：如果是我们的结构体嵌套了 Context，那么一样会被当做普通的 Context 处理。）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// 判断 parent 的 done 是否已经关闭或者并没有 done chan。</span></span><br><span class="line">	<span class="comment">// 如果是，则返回 nil 和 false</span></span><br><span class="line">    done := parent.Done()</span><br><span class="line">	<span class="comment">// done 为 nil 表示 parent 或者到根 Context 这条路径上并没有 *cancelCtx（只有 valueCtx 或 emptyCtx）。</span></span><br><span class="line">    <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 判断 parent 是否是一个 cancelCtx</span></span><br><span class="line">	<span class="comment">// 如果不是，则返回 nil 和 false</span></span><br><span class="line">	<span class="comment">// 讲道理，parent.Value(&amp;cancelCtxKey) 的返回值只有两种情况：</span></span><br><span class="line">	<span class="comment">// emptyCtx（找到根节点也没找到）或者 *cancelCtx（找到了）</span></span><br><span class="line">	<span class="comment">// （parent.Value 实现细节见下面的 value 那一小节）</span></span><br><span class="line">    p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 执行到这里的时候：p 是一个 *cancelCtx</span></span><br><span class="line">	<span class="comment">// 判断 parent.Done() 和 p.done 是否相等：</span></span><br><span class="line">	<span class="comment">// 不等则意味着 *cancelCtx 已经被包装在自定义实现中了，这个时候，我们不应该绕过它。</span></span><br><span class="line">	<span class="comment">// 详细请参考：go issue 28728（google）</span></span><br><span class="line">    pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从父结点移除自己（从 parent 移除 child）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	p, ok := parentCancelCtx(parent)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从父结点的 children 中移除 child</span></span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(p.children, child)</span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="propagatecancel-函数">propagateCancel 函数</h2>
<p>这个函数会在两个地方调用，一个是 <code>WithCancel</code>，另一个是
<code>WithDeadline</code>，它的主要作用是，找到 <code>parent</code>
以及其父级 <code>Context</code> 路径上 第一个
<code>cancelCtx</code>，目的是，将 <code>child</code> 挂载到找到的这个
<code>cancelCtx</code> 的 <code>children</code> 属性上，从而在这个
<code>cancelCtx</code> 取消的时候， 可以通过遍历
<code>cancelCtx.children</code> 对 <code>child</code> 进行通知。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由 parent 往根节点搜索第一个 cancelCtx，如果找到则将 child 写入到 cancelCtx.children 中。</span></span><br><span class="line"><span class="comment">// 如果找到的 cancelCtx 自定义了 Done，则启动协程监听 cancelCtx.Done()。 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果 Context 树上完全不存在 cancelCtx，则直接返回</span></span><br><span class="line">	done := parent.Done()</span><br><span class="line">	<span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 parent 已经取消，则直接取消 child</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-done:</span><br><span class="line">		<span class="comment">// parent is already canceled</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 往根节点搜索第一个 cancelCtx</span></span><br><span class="line">	<span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">		<span class="comment">// 找到了，但是已经取消了，则取消 child</span></span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// parent has already been canceled</span></span><br><span class="line">			child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 找到了，尚未取消。</span></span><br><span class="line">			<span class="comment">// 将 child 写入到 p 的 children 属性中。</span></span><br><span class="line">			<span class="comment">// p.children 是懒汉式创建的。</span></span><br><span class="line">			<span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">				p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 执行到这里的原因是：</span></span><br><span class="line">		<span class="comment">// 用户自定义了 Done 通道（跟 parent 不是同一个 done），</span></span><br><span class="line">		<span class="comment">// 所以不能以父节点路径上的 done 来决定 child 是否取消，</span></span><br><span class="line">		<span class="comment">// 需要通过启动新协程的方式来监听 Done 通道，从而可以正常取消 parent 的孩子节点。</span></span><br><span class="line">		atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">				child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">			<span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图解-propagatecancel">图解 propagateCancel</h2>
<p><code>propagateCancel</code>
的实现可能只看代码不好理解，所以我画了几个图来帮助我们理解：</p>
<p>我们可以看到 <code>propagateCancel</code> 里面有一个
<code>parentCancelCtx</code>，对于
<code>parentCancelCtx</code>，下一小节有比较详细的说明。 这个图描述了
<code>parentCancelCtx</code> 的实际执行过程，在我们调用
<code>propagateCancel</code> 的时候，搜索 <code>cancelCtx</code>
的过程：</p>
<ul>
<li>首先，我们知道，<code>Context</code> 是一个树状结构，每一个
<code>Context</code> 都可以派生出子 <code>Context</code>。</li>
<li>图中 <code>parentA</code> 是 <code>child</code> 到根节点
<code>emptyCtx</code> 路径上的第一个 <code>cancelCtx</code>。</li>
<li><code>parentCancelCtx</code> 拿到的是 <code>parentA</code>，然后将
<code>child</code> 写入到 <code>parentA</code> 的 <code>children</code>
属性中。</li>
<li>从而在我们手动取消 <code>parentA</code> 的时候，<code>parentA</code>
可以通过遍历 <code>children</code> 的方式，告知 <code>child</code>
协程取消了。</li>
</ul>
<blockquote>
<p>注意：搜索的时候会跳过 <code>valueCtx</code>。</p>
</blockquote>
<p><strong>在 <code>child</code> 到 <code>emptyCtx</code>
路径上搜索第一个 <code>cancelCtx</code> 的过程</strong>：</p>
<p><img src="/images/go/context/context_par_1.png" /></p>
<p>我们<strong>取消的过程</strong>大概如下图：</p>
<p><img src="/images/go/context/context_par_2.png" /></p>
<p>我们理解取消的过程的时候，可以忽略掉 <code>Context</code> 树中那些非
<code>cancelCtx</code> 节点，正如上图这样，实际上取消过程只涉及到
<code>parentA</code> 以及 <code>child</code>，
其他节点如何并不影响。</p>
<p>如果觉得这个图不太好懂，可以再看看这个图：</p>
<p><img src="/images/go/context/context_par_4.png" /></p>
<p><strong>用户覆盖了 <code>done</code> 的特殊情况</strong>：</p>
<p><img src="/images/go/context/context_par_3.png" /></p>
<p>如果用户覆盖了 <code>done</code> 通道，这表明用户想自行控制什么时候
<code>parentB</code> 结束。（也就是说，<code>parentB</code> 脱离了路径上
<code>cancelCtx</code> 的控制， 也就是假设 <code>parentA</code> 还是
<code>cancelCtx</code>，在 <code>parentA</code>
取消的时候，<code>parentB</code> 是收不到信号的，<code>parentB</code>
收到信号是在其 <code>Done()</code> 返回的通道关闭的时候。）</p>
<p>这个时候因为我们从 <code>parentB</code> 派生出了一个新的
<code>cancelCtx</code>（<code>child</code>），所以 <code>parentB</code>
需要对 <code>child</code> 进行控制， 也就是说在 <code>parentB</code>
取消的时候，也取消 <code>child</code>。这种情况下，就是通过
<code>propagateCancel</code> 里面的协程里面实现的。</p>
<h2 id="parentcancelctx-函数">parentCancelCtx 函数</h2>
<p><code>parentCancelCtx</code>
的描述比较晦涩，如果没有实际的例子我们很难看得懂它的意思。里面有一个比较，
是针对 <code>parent.Done()</code> 和
<code>p.done.Load().(chan struct&#123;&#125;)</code>
的，源码里面判断如果这两者不一样，则返回 <code>nil</code> 和
<code>false</code>。</p>
<p>注释里说，如果两者不一样，我们不应该绕过它（bypass
it），但是这里的绕过是什么意思呢？我们来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	ch &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> a.ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCancel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个 cancel context</span></span><br><span class="line">	ctx, cancel0 := WithCancel(TODO())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个 A 实例</span></span><br><span class="line">	<span class="comment">// 这个实例可以内嵌了 Context，所以可以当作 Context 使用，</span></span><br><span class="line">	<span class="comment">// 但是我们覆盖了 Context 本身的 Done 方法。</span></span><br><span class="line">	ch := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	a := A&#123;ctx, ch&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为我们覆盖了 Done 方法，所以 go 底层会认为是开发者想要</span></span><br><span class="line">	<span class="comment">// 自行控制协程取消，所以在 WithCancel 的时候并不会把 ctx1</span></span><br><span class="line">	<span class="comment">// 挂载到 a 的 children 属性下，这样一来，</span></span><br><span class="line">	<span class="comment">// go 底层只能再启动一个协程来监听 a 的 Done chan，</span></span><br><span class="line">	<span class="comment">// 从而可以在 a cancel 的时候可以正常通知到 ctx1。</span></span><br><span class="line">	ctx1, cancel := WithCancel(&amp;a)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">		cancel()</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ctx2 会写入到 ctx1 的 children 属性中，</span></span><br><span class="line">	<span class="comment">// 这样就不需要启动新的协程来监测 ctx1 的 done。</span></span><br><span class="line">	ctx2, cancel2 := WithCancel(ctx1)</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个图描述了上面这个例子中的 <code>Context</code> 树结构：</p>
<p><img src="/images/go/context/context_cancel.png" /></p>
<p>我们调用了三次 <code>WithCancel</code>，这三次的效果都不太一样：</p>
<ul>
<li>第一次调用的时候，<code>parent.Done</code> 返回
<code>nil</code>，这个时候，我们取消只有调用 <code>cancel0</code>
这一种途径，也就是手动取消。</li>
<li>第二次调用的时候，<code>parent.Done</code> 返回的不是
<code>nil</code>，但是和 go 语言底层的那个 <code>done</code>
属性不一致（一个是 <code>A.Done()</code> ，另一个是
<code>cancelCtx.done</code>）。这种情况下，go
底层就知道，开发者自己定义了一个 <code>done</code>
通道，这个时候，会需要另外启动一个协程来监听 <code>A.Done()</code>
返回的 <code>done</code>，从而可以在 <code>A</code> 结束的时候，通知
<code>A</code> 的孩子 <code>ctx1</code>。</li>
<li>第三次调用的时候，<code>parent.Done</code> 返回的不是
<code>nil</code>，而且和 <code>cancelCtx.done</code>
相等，说明用户没有重写 <code>Done</code> 方法，这样就可以直接将
<code>ctx2</code> 挂载到 <code>ctx1</code> 的 <code>children</code>
属性上，而不用另外启动协程来监听 <code>ctx1</code> 的
<code>done</code>。</li>
</ul>
<p>具体怎么实现的可以看上面的 <code>propagateCancel</code>
这一小节。</p>
<blockquote>
<p>之所以这样是为了给开发者一定的控制权，如果忽略了用户自定义的
<code>Done</code> 方法，那么可能取消的操作用户就无法控制了。 但我们覆盖
<code>Done</code> 方法就是为了可以自主去控制取消的操作。</p>
</blockquote>
<h2 id="child-什么时候从父-context-移除">child 什么时候从父 Context
移除？</h2>
<p>如果我们足够细心，就会发现我们在 <code>cancel</code>
的时候，有的地方需要将 <code>child</code> 从 <code>Context</code>
中移除，而有的地方不需要，那什么时候需要呢？</p>
<p>需要移除的情况：</p>
<ol type="1">
<li><code>WithCancel</code> 派生出新的 <code>Context</code>
的时候，假设叫 <code>root</code>，这个时候派生的这个 <code>root</code>
也是可以继续派生出新的 <code>Context</code> 的，而这个 <code>root</code>
对于它的子孙 <code>Context</code> 它就是根节点，所以当 <code>root</code>
被取消的时候，它和它的子孙 <code>Context</code> 也要被取消了，所以以
<code>root</code> 为根节点的子树需要被移除。</li>
<li><code>WithDeadline</code> 里面，当给定的 <code>d</code>
其实已经小于当前时间的时候（也就是父 <code>Context</code>
已经超时了），这个时候会将刚挂载到父节点的 <code>timerCtx</code>
移除，同时返回的 <code>CancelFunc</code> 中，<code>cancel</code>
的第一个参数是 <code>false</code>，因为它已经被移除了。</li>
</ol>
<p>不需要移除的情况：</p>
<ol type="1">
<li>在 <code>propagateCancel</code> 中监测到 <code>parent</code>
已经被取消的时候，因为这个时候 <code>child</code> 并没有关联上
<code>parent</code>，所以自然也没有移除的这种操作。</li>
<li>就是上面提到的第二种情况中，<code>WithDeadline</code> 的时候就监测到
<code>deadline</code> 已经比当前时间小了（超时了）。</li>
<li>在 <code>cancelCtx</code> 的 <code>cancel</code> 方法里面，遍历
<code>cancelCtx</code> 的孩子节点的时候，不需要做移除的操作，因为
<code>cancelCtx</code> 本身就需要被从 <code>Context</code>
树中移除。</li>
<li><code>timerCtx</code> 在没有挂载到 <code>parent</code>
上就已经过期了。</li>
</ol>
<h2 id="timerctx-结构体">timerCtx 结构体</h2>
<p><code>timerCtx</code> 是一个带有定时器的
<code>cancelCtx</code>，我们既可以手动取消，也可以由底层定时器在到达
<code>deadline</code> 的时候进行取消。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timerCtx 嵌套了 cancelCtx，这表示我们可以手动取消。</span></span><br><span class="line"><span class="comment">// 另外还有一个定时器，这个定时器的执行时间定在 deadline 这个时间点，</span></span><br><span class="line"><span class="comment">// 一旦时间到了，就会调用 cancelCtx 的 cancel 方法。</span></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancelCtx</span><br><span class="line">	timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们有两种方法来创建 <code>timerCtx</code>，一个是
<code>WithDeadline</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于 parent 创建一个 cancelCtx，内嵌到 timerCtx 中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">	<span class="comment">// 不能基于 nil 创建一个 timerCtx</span></span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果当前设置的超时时间比 parent 设置的超时时间更长，</span></span><br><span class="line">	<span class="comment">// 那么不用 timerCtx 开启定时器了，因为 parent 会先到期取消，</span></span><br><span class="line">	<span class="comment">// 这里再启动一个定时器也没有执行的机会了。</span></span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">		<span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建一个 timerCtx</span></span><br><span class="line">	c := &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  d,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将刚创建的 timerCtx 挂载到父 Context 中</span></span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">	<span class="comment">// 判断还有多久到达 deadline</span></span><br><span class="line">	dur := time.Until(d)</span><br><span class="line">	<span class="comment">// 如果 deadline 已经过去了，那么直接执行 timerCtx 的 cancel 逻辑,</span></span><br><span class="line">	<span class="comment">// 同时移除跟父节点的关联。（创建了还没来得及启动定时器就到期了）</span></span><br><span class="line">	<span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">		<span class="comment">// cancel 不再需要从父节点移除自身，上一行已经移除了</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 启动一个定时器，在到达 deadline 的时候执行 cancel 操作。</span></span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 除了定时器之外，返回一个 CancelFunc 给用户提供自行取消的方式。</span></span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一个是 <code>WithTimeout</code>：</p>
<p><code>WithTimeout</code> 本质上是对 <code>WithDeadline</code>
的调用而已，只不过描述到期时间的方式不一样而已。
<code>WithDeadline</code>
描述的是具体的到期时间，<code>WithTimeout</code>
描述的是多久以后的时间，两者其实都代表未来的某一个时间点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">	<span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="valuectx">valueCtx</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// valueCtx 在父 Context 的基础上，带有一对键值对。</span></span><br><span class="line"><span class="comment">// 实现了一个 Value 方法，其他方法都是调用 parent 的。</span></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="withvalue-方法">WithValue 方法</h2>
<p><code>WithValue</code>
方法一般用在请求范围内的数据共享，<code>WithValue</code>
方法很简单，就是在 <code>parent</code> 的基础上加上了一个
<code>key</code> 和 一个 <code>value</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回的子 Context 里面有 key val 对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line">	<span class="comment">// parent 不能为 nil</span></span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// key 不能为 nil</span></span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// key 必须是可以比较的，</span></span><br><span class="line">	<span class="comment">// 因为在获取值的时候需要进行 key 的比较。</span></span><br><span class="line">	<span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回 valueCtx</span></span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="valuectx-1">valueCtx</h2>
<p><code>valueCtx</code> 是从其他 <code>Context</code>
派生出来的，所以内嵌了 <code>Context</code> 接口，同时还有两个字段是
<code>key</code> 和 <code>val</code>，表示的是父 <code>Context</code>
传递的键值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="value-方法">value 方法</h2>
<p><code>value</code> 方法用以从 <code>Context</code>
中获取对应的值，它会从 <code>Context</code>
树自底向上进行递归搜索，具体来说会有以下几种情况：</p>
<ul>
<li>如果 <code>ctx</code> 是 <code>*valueCtx</code>，则会判断
<code>key</code> 是否等于 <code>ctx</code> 里面的
<code>key</code>，如果相等，返回
<code>ctx.val</code>。<strong>否则，再去搜索 <code>ctx</code> 的父
<code>Context</code></strong>。</li>
<li>如果 <code>ctx</code> 是 <code>*cancelCtx</code>，同时
<code>key</code> 是 <code>&amp;cancelCtxKey</code>，则会返回
<code>ctx</code>。<strong>否则，会继续搜索 <code>ctx</code>
到根结点这个路径上的第一个 <code>cancelCtx</code></strong>。</li>
<li>如果 <code>ctx</code> 是 <code>*timerCtx</code>，同时
<code>key</code> 是 <code>&amp;cancelCtxKey</code>，则会返回
<code>ctx.cancelCtx</code>。<strong>否则，会继续搜索 <code>ctx</code>
到根结点这个路径上的第一个 <code>cancelCtx</code></strong>。</li>
<li>如果 <code>ctx</code> 是 <code>*emptyCtx</code>，则会返回
<code>nil</code>。（因为这时候是最顶层的 <code>Context</code>
了，也找不到对应的值）。</li>
<li>如果都不是以上的几种情况，则有可能是开发者自定义的
<code>Context</code> 实现，则直接返回 <code>c.Value(key)</code>。</li>
</ul>
<p>它要解决的问题是：</p>
<ul>
<li>获取父级 <code>Context</code> 中 <code>WithValue</code>
共享的值。</li>
<li>获取父级 <code>Context</code> 中最靠近当前节点的
<code>cancelCtx</code>（<strong>非常重要：它的一个很重要的作用是，将当前节点设置为这个
<code>cancelCtx</code> 的
<code>children</code>，从而可以实现在这个父级的 <code>cancelCtx</code>
取消的时候，当前的 <code>Context</code> 可以感知到</strong>）。</li>
<li>如果是开发者自己实现的 <code>Context</code>，则直接调用用户自定义的
<code>Value</code> 方法。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 key 从 c 中获取对应的值，会从 Context 树自底向上递归搜索。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *valueCtx:</span><br><span class="line">			<span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">				<span class="keyword">return</span> ctx.val</span><br><span class="line">			&#125;</span><br><span class="line">			c = ctx.Context</span><br><span class="line">		<span class="keyword">case</span> *cancelCtx:</span><br><span class="line">			<span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">				<span class="keyword">return</span> c</span><br><span class="line">			&#125;</span><br><span class="line">			c = ctx.Context</span><br><span class="line">		<span class="keyword">case</span> *timerCtx:</span><br><span class="line">			<span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;ctx.cancelCtx</span><br><span class="line">			&#125;</span><br><span class="line">			c = ctx.Context</span><br><span class="line">		<span class="keyword">case</span> *emptyCtx:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> c.Value(key)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下面的图可能会更加直观：</p>
<p><img src="/images/go/context/context_value.png" /></p>
<p>这个方法大概做的事情是，从当前的 <code>Context</code> 中查找指定的
<code>key</code>，如果找不到则递归地从其父级 <code>Context</code>
上找。</p>
<blockquote>
<p>但我们最需要关注的是，它这里面 <code>case *cancelCtx</code> 和
<code>case *timerCtx</code> 的逻辑表明了，在我们调用
<code>parent.Value(&amp;cancelCtxKey)</code> 的
时候，实际上获取到的是当前 <code>Context</code> 到根
<code>Context</code> 上第一个 <code>cancelCtx</code>。</p>
</blockquote>
<p>一个更简单的图是下面这样的（当然在实际中，会有多个子节点，这里假设都是只有一个子节点）：</p>
<p><img src="/images/go/context/context_value_search.png" /></p>
<h2 id="为什么是通过关闭-chan-的方式取消">为什么是通过关闭 chan
的方式取消？</h2>
<p>上面我们说了，在 <code>Context</code> 取消的时候，是通过关闭
<code>chan</code>
的方式来实现的，那么为什么要这么做呢？这是因为，如果说要通过往
<code>chan</code> 写入数据的方式来 通知其他子孙 <code>Context</code>
的话，我们就需要有多少个子孙 <code>Context</code> 就要往
<code>chan</code> 里面发多少次，但是如果选择使用 <code>close</code>
的方式的话， 我们就完全不用管派生出了多少个可以 <code>cancel</code> 的
<code>Context</code>，因为一旦 <code>chan</code> 关闭了，所有的
<code>&lt;-chan</code> 操作立即得以返回，这同样也实现了通信。 但是
<code>close</code> 这种方式无疑更加高明，更加简洁，当然也更加巧妙。</p>
<h2 id="总结">总结</h2>
<p>本文主要讲了如下内容：</p>
<ul>
<li>介绍了 <code>context</code> 包的几个 <code>Context</code>
结构体，其中 <code>emptyCtx</code> 一般用作根
<code>Context</code>，<code>valueCtx</code>
一般用作请求范围内的数据共享，而 <code>cancelCtx</code> 给开发者控制下游
<code>Context</code> 提供了一种很好的方式，<code>timerCtx</code> 在
<code>cancelCtx</code>
的基础上加了一个定时器，时间到会发送取消信号。</li>
<li><code>timerCtx</code> 有两种取消方式，一种是开发者手动取消，这个和
<code>cancelCtx</code> 一致，另外一种方法是到达 <code>deadline</code>
的时候，由定时器来取消。</li>
<li>go 里面 <code>Context</code> 取消的时候，是通过关闭
<code>chan</code> 的方式来让下游的 <code>Context</code> 感知的，因为
<code>chan</code> 的工作机制就是如果被关闭则调用 <code>&lt;-chan</code>
会立即返回。</li>
<li>创建 <code>cancelCtx</code> 的时候，会将派生的 <code>Context</code>
挂载到上游 <code>Context</code> 中第一个 <code>cancelCtx</code> 的
<code>children</code> 上，这样在上游取消的时候，这个派生的
<code>Context</code> 可以感知得到。</li>
<li>上游取消的信号会跨过中间的所有 <code>valueCtx</code>，传达到下游那些
<code>cancelCtx</code>，在取消的时候，<code>Context</code> 会从
<code>Context</code> 树中移除。</li>
<li>如果开发者实现了自己的 <code>Done</code> 通道，并且返回的是跟底层
<code>cancelCtx</code> 中不一样的 <code>done</code> 通道，则会导致 go
底层启动一个协程来监测这个被覆盖的 <code>done</code> 通道。</li>
<li><code>value</code> 也会从 <code>Context</code>
树中自底向上搜索，直到根节点。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/11/18/golang/go%20Context%20%E6%8C%87%E5%8C%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/18/golang/go%20Context%20%E6%8C%87%E5%8C%97/" class="post-title-link" itemprop="url">go Context 指北</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-18 22:08:30" itemprop="dateCreated datePublished" datetime="2022-11-18T22:08:30+08:00">2022-11-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在上一篇文章中，讲了很多跟 <code>Context</code>
相关的东西，我们也知道了 go 里面 <code>Context</code>
的一些比较常见的用法、使用场景，比如超时控制、变量共享等， 但是对于 go
<code>Context</code>
本身还没有太多的讲解，可能看起来会有点费解，今天就来详细说说
<code>Context</code> 的设计以及其用法。</p>
<h2 id="context.context-模型">context.Context 模型</h2>
<p>在开始之前，我们先来看看这张图，这张图涵盖了所有创建
<code>context.Context</code> 的方法：</p>
<p><img src="/images/go/context/context.png" /></p>
<p>首先，是最上层的 <code>context.Background()</code> 和
<code>context.TODO()</code>，看过源码的同学应该知道，这两个方法返回的
<code>Context</code> 是一样的，都是 <code>new(emptyCtx)</code>， 而这个
<code>emptyCtx</code>
其实是没有任何实际功能的，但是他们又是最重要的，因为创建
<code>Context</code> 只有这两个方法，其他的几个方法都是从这里创建的
<code>Context</code> 派生的。 我们一般会使用
<code>context.Background()</code> 来创建一个最顶级的
<code>Context</code>，比如，go 的 http 服务器中
<code>request.Context()</code> 方法的那个 <code>Context</code> 就是通过
<code>context.Background()</code> 创建的。 而
<code>context.TODO()</code> 往往用在需要 <code>Context</code>
的地方，但是我们还没确定使用一个什么样的 <code>Context</code>
的时候。</p>
<p>其次，中间的 <code>context.Context</code> 表示通过
<code>context.Background()</code> 或者 <code>context.TODO()</code>
方法创建的 <code>Context</code>。 这个 <code>Context</code>
往往就是一个请求中的根 <code>Context</code>，所有子协程里面的
<code>Context</code> 都是从这个 <code>Context</code>
派生的，又或者是直接使用了这个 <code>Context</code>。</p>
<p>然后，从父 <code>Context</code> 创建新的 <code>Context</code>
的几个方法需要详细说一下：</p>
<ul>
<li><code>WithCancel</code>: 这个方法返回一个新的
<code>Context</code>，同时返回一个 <code>CancelFunc</code>，通过调用
<code>CancelFunc</code>，我们可以在子协程中的
<code>context.Done()</code>
方法接收到取消的信号，从而作出相应的操作（比如清理、中止执行等）。</li>
<li><code>WithDeadline</code>: 这个方法也会返回一个新的
<code>Context</code>，同时也返回了一个
<code>CancelFunc</code>，本质上来说，这两个返回值跟
<code>WithCancel</code> 的两个返回值并无二致。我们通过
<code>WithDeadline</code> 返回的 <code>CancelFunc</code>
也是可以给子协程发送取消信号的。但是通过 <code>WithDeadline</code>
创建的
<code>Context</code>，会有一个定时器在运行，到了指定时间如果我们的子协程依然没有结束，同样也会收到取消的信号，这个定时器的作用就是在指定时间后执行
<code>CancelFunc</code>。</li>
<li><code>WithTimeout</code>: 这个其实跟 <code>WithDeadline</code>
是一样的，只是参数上有点不一样，最终效果都是在一定时间后发送取消信号。</li>
<li><code>WithValue</code>: 这个方法只是返回一个带有我们传递变量的新的
<code>Context</code>，没有其他什么特别的功能了。</li>
</ul>
<p>所以，除了基础的 <code>context.Background()</code> 和
<code>context.TODO()</code>，对于怎么基于这两个基础的
<code>Context</code> 创建新的
<code>Context</code>，可以简单总结如下：</p>
<ul>
<li>如果我们只是想有一个机制可以取消子协程的执行，可以使用
<code>WithCancel</code>，拿到 <code>CancelFunc</code>
之后，在我们需要的时候调用 <code>CancelFunc</code> 就可以给子
<code>Context</code> 传递取消信号。</li>
<li>如果我们想对子协程进行超时控制，可以使用 <code>WithDeadline</code>
或者
<code>WithTimeout</code>，这两个方法的本质上都是启动一个定时器，在到达一定时间后，会给子协程发送取消信号。但是除了定时器，它们还返回了一个
<code>CancelFunc</code>，这意味着我们在到达定时器指定的时间之前，也可以手动调用
<code>CancelFunc</code> 来发送取消信号。</li>
<li>如果我们只是想给子协程传递一些数据，从而实现变量共享的话，可以使用
<code>WithValue</code>。</li>
</ul>
<h2 id="实际使用中的-context">实际使用中的 Context</h2>
<p>我们再来看一张图，上面的描述可能会比较抽象，下面这个图展示了实际使用中的
<code>Context</code>。</p>
<p><img src="/images/go/context/context_1.png" /></p>
<p>根结点的 <code>Context</code> 只有两种创建方式
<code>context.Background()</code> 或者
<code>context.TODO()</code>，在我们做一些 <code>io</code>
操作的时候，比如 rpc 调用，数据库查询等，
我们会需要做一些超时控制，这个时候我们就会需要新建一个有超时控制功能的
<code>Context</code>（使用 <code>context.WithDeadline</code> 或者
<code>context.WithTimeout</code>）， 假设是上图的
<code>child 2</code>，然后 <code>child 2</code> 这个
<code>Context</code> 所在的 <code>goroutine</code> 里面也需要做一些
<code>io</code> 操作，然后也需要限制这些操作的超时时间， 然后在
<code>child 2</code> 的基础上再通过 <code>context.WithTimeout</code>
创建了一个新的 <code>Context</code>，假设是 <code>child 2-2</code>。</p>
<blockquote>
<p>需要注意的是，这里每一级都是一个新的 Context 实例，而不是在原有
Context 上增加或者修改其属性。</p>
</blockquote>
<p>假设 <code>child 2</code> 的 <code>Deadline</code> 到了，这个时候
<code>child 2</code> 的定时器会调用 <code>CancelFunc</code> 来给子
<code>Context</code> 发送取消信号。 <code>child 2-2</code> 里的
<code>select</code> 语句的 <code>context.Done()</code>
得以返回，从而开始执行清理操作，然后中止协程的执行。</p>
<p>在这个过程中，取消信号的传播是从上往下一级级有序传递的，每一级的
<code>Context</code> 会给那些从其派生的 <code>Context</code>
传传递取消信号，直到叶子结点。</p>
<blockquote>
<p>需要注意的是，虽然信号传播是从上往下的，但是不代表子协程需要等待父协程的
<code>context.Done()</code> 里面的逻辑执行完再执行，因为我们之前也说过，
在 go 里面，协程是平等的，父子协程的执行是同时进行的。</p>
</blockquote>
<p>我们可以看看下面的例子，有点啰嗦，大概看一下就好：</p>
<p>主要是想通过这个例子说明，在调用 <code>CancelFunc</code>
的时候，所有子孙 <code>Context</code> 都能接收到这个信号（当然它的父
<code>Context</code> 不会收到）。 这也跟我们实际的应用场景一致。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c context.Context)</span></span> &#123;</span><br><span class="line">		ctx1, _ := context.WithCancel(c)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c1 context.Context)</span></span> &#123;</span><br><span class="line">			ctx2, _ := context.WithCancel(c1)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c2 context.Context)</span></span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-c2.Done():</span><br><span class="line">					fmt.Println(<span class="string">&quot;ctx2 done.&quot;</span>)</span><br><span class="line">					wg.Done()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(ctx2)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-c1.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;ctx1 done.&quot;</span>)</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(ctx1)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-c.Done():</span><br><span class="line">			fmt.Println(<span class="string">&quot;ctx1 done.&quot;</span>)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// main ctx</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		<span class="comment">// 父协程通过调用 CancelFunc 发送了取消信号</span></span><br><span class="line">		cancel()</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出：</span></span><br><span class="line">	<span class="comment">// ctx2 done.</span></span><br><span class="line">	<span class="comment">// ctx1 done. </span></span><br><span class="line">	<span class="comment">// ctx1 done.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程大概如下图：</p>
<p><img src="/images/go/context/context_2.png" /></p>
<h2 id="实际使用中的-goroutine">实际使用中的 goroutine</h2>
<p>在实际的场景中，goroutine 类似
<code>Context</code>，也是树状的结构，每一个协程都可以启动新的协程，同样子协程也可以启动新的协程，最终会如下图这样：</p>
<p><img src="/images/go/context/context_3.png" /></p>
<p>同样的，而在父协程里面通过 <code>Context</code>
发送取消信号的时候，所有子孙协程都能感知得到，所以虽然看起来这棵树可能变得有点庞大，但是也不是完全不可控的。</p>
<h2 id="go-中监控协程的一个工具">go 中监控协程的一个工具</h2>
<p>我们现在直到了，go
的协程里面可以启动新的协程，最终可能会有非常多的协程，但是到底有多少呢？</p>
<p>对于这个问题，go 官方的标准库已经给我们提供了一个工具
<code>net/http/pprof</code>，具体使用方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 启动之后，在 localhost:6060 可以看到当前进程的一些指标，比如当前的协程有多少个</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		http.ListenAndServe(<span class="string">&quot;localhost:6060&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">120</span>)</span><br><span class="line">		ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>pprof</code>
我们可以知道应用的健康状况，如协程数量等，这不是本文重点，不赘述了。</p>
<h2 id="总结">总结</h2>
<p>本文主要讲述了如下内容：</p>
<ul>
<li>我们先是讲解了创建<code>Context</code> 的几种方式，其中，根
<code>Context</code> 只有两种创建方式，分别是
<code>context.Background()</code> 和
<code>context.TODO()</code>，其他种类的 <code>Context</code> 可以通过
<code>context.WithXXX()</code> 创建。</li>
<li>在 go 里面，如果我们只是想要取消一个协程，那么我们可以通过
<code>WithCancel</code> 来实现，如果要进行超时控制，可以使用
<code>WithTimeout</code> 或 <code>WithDeadline</code>。</li>
<li><code>Context</code> 是一个树状结构，每一个 <code>Context</code>
都可以作为父 <code>Context</code> 创建新的
<code>Context</code>，然后在调用 <code>CancelFunc</code>
或者超时的时候，会由父到子传递取消的信号。</li>
<li><code>Context</code> 也可以用来传递参数，比如我们可以通过
<code>WithValue</code> 来传递参数，然后在子协程里面通过
<code>Value</code> 来获取参数。</li>
<li>最后，我们讲解了如何通过 <code>pprof</code> 来监控协程的数量。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/11/17/golang/gin%20Context%20%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/17/golang/gin%20Context%20%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">gin Context 详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-17 20:08:30" itemprop="dateCreated datePublished" datetime="2022-11-17T20:08:30+08:00">2022-11-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>上一篇文章中讲到了 <code>gin</code> 的 <code>Engine</code>
结构体，它代表的是 <code>gin</code>
框架的应用实例，里面包含了应用的一些配置等信息。
既然是应用实例，我们自然有需要用到它的时候，而在 <code>gin</code>
里面，我们是通过 <code>Context</code>
来使用它的，因为在我们的路由处理函数里面， <code>Context</code>
是唯一的一个参数，所以，自然而然的，<code>Engine</code> 就被设置为
<code>Context</code> 的一个属性。 当然，这只是 <code>Context</code>
的一小部分，也许可以这么说，<code>Engine</code>
只是搭起了一个骨架，构造起了一个
<code>请求-&gt;路由-&gt;处理-&gt;响应</code> 的模型，
但是所有脏活累活其实基本都在 <code>Context</code> 里面，今天就来看看
<code>Context</code> 具体有哪些功能。</p>
<h2 id="协程是什么">协程是什么？</h2>
<p>需要注意的是，我在本文前面提到的 <code>Context</code> 其实是
<code>gin.Context</code>，而不是 go 标准库的
<code>context.Context</code>， 当然 <code>gin.Context</code>
也实现了标准库的 <code>Context</code> 接口，
但是在这基础上，还提供了非常多的功能。</p>
<p>回到正题，也许很多人都知道，go
里面的一个核心功能就是它的协程（<code>goroutine</code>），我有时候会跟别人说
<code>goroutine</code> 是其精髓所在，其实一点也不为过。
毕竟再也没有其他任何一门语言，能够像 go
的协程这样如此简单地实现多线程的功能，这得益于 go
的设计，它从一开始就遵循
<strong>通过通信来共享内存，而不是通过共享内存来通信</strong>
的设计理念。</p>
<p>我们先来看看 go 的协程模型是怎样的。 <strong>从 go
进程启动的那一刻开始，它就启动了一个
<code>goroutine</code></strong>，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// goroutine nums: 1</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;goroutine nums: %d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动的时候，<code>main</code> 就是一个协程，所以调用
<code>runtime.NumGoroutine()</code> 的时候，输出的是
<code>1</code>。</p>
<p>然后我们知道，在代码的任何地方，我们都可以通过 <code>go</code>
关键字来启动一个新的协程，所以我们可以通过以下的方式来在
<code>main</code> 里面启动一个新的协程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 用以等待协程执行完成</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">20</span>)</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// goroutine nums: 2</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;goroutine nums: %d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>稍微解释一下这里的几行代码：</p>
<ul>
<li><code>var wg sync.WaitGroup</code> 这个 <code>WaitGroup</code> 是 go
里面用来等待多个协程的机制（如果没有 <code>wg</code>
控制，有可能会导致主协程在子协程还没执行完毕就退出，比如子协程需要执行个几秒，但是你主协程不等它的话，子协程就会在主协程退出的时候也马上结束，这可能并不是我们想要的结果）</li>
<li><code>wg.Add(1)</code>
表示需要等待的协程的数量，<code>wg.Done()</code>
表示需要等待的协程数量减少 1，在减少到 0 的时候，<code>wg.Wait()</code>
调用会返回，否则，<code>wg.Wait()</code> 会一直阻塞。</li>
</ul>
<p>这里输出了 <code>goroutine nums: 2</code>，这是因为除了
<code>main</code> 协程之外，我们还用 <code>go</code>
关键字启动了一个新的协程，所以实际上是有两个协程。</p>
<p>好了，我们可以看到，在上面的代码里面通过 <code>go</code>
关键字后面接一个 <code>func</code>
就可以启动一个新的协程，所以<strong>其实协程本质上就是一个函数调用</strong>。
但是这跟普通的函数调用有什么区别呢？最关键的区别是，函数调用是顺序执行的，在执行函数的时候，调用函数的地方必须等待函数返回然后再往下执行。
而协程可以实现并行（当然，前提是有多个 cpu
可以使用），这样一来，启动协程的时候，go
关键字后面的代码可以接着执行（跟 <code>go func</code>
启动的协程同时执行）。</p>
<p>所以，<code>go</code> 的协程有如下特点：</p>
<ul>
<li>最关键的，<code>main</code>
协程退出的话，所有子协程都直接退出（注意是 <code>main</code>
协程）。</li>
<li>首先，不同协程是可以并行执行的，每一个协程都是平等的，所以上面需要通过
<code>WaitGroup</code>
来等待子协程，因为主协程跟子协程是并行执行的，如果不等待子协程执行完毕
<code>main</code> 协程就退出的话，就会导致子协程执行一半就退出。</li>
</ul>
<blockquote>
<p>需要注意的是，上面提到的是 <code>main</code>
协程退出，所有子协程都会退出，但是如果不是 <code>main</code>
协程启动的协程的话，比如子协程 A 里面又启动了新的协程 B 的情况下， 如果
B 执行的时间会比 A 执行时间长，这种情况下，A 协程的退出并不会导致 B
协程的终止。这样就会出现
<strong>协程泄漏</strong>，这个问题可大可小，毕竟协程还在的话，资源就会被一直占用而得不到释放。
轻则导致响应缓慢，严重直接导致服务不可用、OOM 啥的。</p>
</blockquote>
<h2 id="context-是什么">Context 是什么？</h2>
<p>简单来说，<code>Context</code>
代表了协程的上下文，用以在父子协程之间传递控制信号，共享变量等操作，比如超时的时候告诉子协程超时，父协程取消协程执行的时候传递取消的信号。</p>
<p>在上面我们提到了使用协程的情况下，有可能会导致协程泄漏，是不是我们对此就完全没有办法了呢？并不是的，毕竟从
<code>go</code> 设计出来协程就是它最重要的特性， 所以 <code>go</code>
提供了一种叫 <code>Context</code> 的东西，翻译成中文就是 "上下文"
的意思，的确是这样，它就是代表了 "上下文"，但是是什么的上下文呢？</p>
<p>在 http
请求中，它往往代表的是当前处理的请求的上下文。它可以在请求内来共享数据，这是其中一个关键的功能。另外一个功能就是可以解决上一小节说的
"协程泄漏" 的问题。</p>
<p>那 <code>Context</code> 是如何解决 "协程泄漏"
的问题的呢？我们先来看看 <code>Context</code> 的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context.Context 接口</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 获取给协程设置的终止时间</span></span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">	<span class="comment">// 用在子协程的 select 语句里面，有三种情况会导致这个函数返回：</span></span><br><span class="line">	<span class="comment">// 1. context 的 cancel 被调用</span></span><br><span class="line">	<span class="comment">// 2. 当前时间到了 context 的 deadline</span></span><br><span class="line">	<span class="comment">// 3. 当前协程执行超时</span></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 有几种情况：</span></span><br><span class="line">	<span class="comment">// 1. 如果 Done 通道尚未关闭，则返回 nil</span></span><br><span class="line">	<span class="comment">// 2. 如果 Done 通道已经关闭，返回一个表示具体原因的错误：被取消了或者超时了</span></span><br><span class="line">	Err() <span class="type">error</span></span><br><span class="line">	<span class="comment">// 返回父协程 context.WithValue 绑定的值</span></span><br><span class="line">	Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重点看这里的 <code>Done</code> 方法，它的返回值是一个
<code>chan</code>，而这个 <code>chan</code>
是父协程用来给子协程传递信息的关键，在父协程中进行 <code>cancel</code>
或者 当前的时间已经到了 <code>context</code> 指定的
<code>Deadline</code>，又或者子协程执行的总时间到达了指定的
<code>timeout</code> 时间时，<code>Done</code> 返回的那个
<code>chan</code> 会接收到一个值， 也就是说
<code>case &lt;-c.Done():</code> 里面的语句会被执行。</p>
<blockquote>
<p>select 是 go 里面多路复用的机制，每一个 case 一般是一个 chan，在 chan
获取到值的时候，case 里面的语句会被执行，而 select 语句也会结束。</p>
</blockquote>
<p>关于 <code>Context</code>
的其他东西，这里不细说了，不是本文的重点，我们需要知道的是，
<strong>Context
提供了一种机制，可以让父协程给子协程传递一些信号，这样我们就可以控制子协程的执行耗时，防止某些操作导致协程一直执行下去</strong>。</p>
<blockquote>
<p>另外需要注意的是，并不是说我们用了 <code>Context</code>
就可以控制子协程了，我们还需要在子协程里面监听
<code>context.Done()</code> 的返回值，在 <code>Done()</code>
返回的时候，做一些清理工作，然后退出协程。</p>
</blockquote>
<p>之所以需要子协程做 <code>Done()</code>
的监听，是因为父子协程之间并不是一种强的控制关系，而是需要子协程主动来协助父协程做超时等控制的。</p>
<p>好了，我们在父协程里面设置了一个带有 <code>Timeout</code> 或者
<code>Deadline</code> 的
<code>Context</code>，然后我们也在子协程里面通过 <code>select</code>
来监听 <code>context.Done()</code> 返回的 <code>chan</code>，
而且也在这个 <code>chan</code>
返回的时候作出了相应的清理操作，所以我们最终才得以实现父协程控制子协程。也就避免了父协程退出了，一堆子协程还在执行的
"协程泄漏" 现象。</p>
<h2 id="context-的一个实例">Context 的一个实例</h2>
<p>在下面的例子中：</p>
<ul>
<li>我们定义了 <code>wg</code>，用以控制等待子协程结束。</li>
<li>通过 <code>WithCancel</code> 创建了一个
<code>Context</code>，同时获取了一个可以发送取消信号的函数句柄，我们调用它可以往一个
<code>chan</code> 写入数据，从而 <code>select</code>
语句从阻塞状态转变为执行态。</li>
<li>我们在 1 秒后通过调用 <code>cancel</code> 方法发送了取消的信号</li>
<li>而 <code>out</code> 这个 <code>chan</code> 要在 2
秒后才会收到数据，所以 <code>select</code> 匹配上了
<code>&lt;-ctx.Done()</code> 这一分支</li>
<li>我们打印输出，发现 <code>ctx.Done()</code> 的原因是
<code>context canceled</code>（取消了），最后 <code>wg.Done()</code>
结束 <code>WaitGroup</code> 等待。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟控制超时的情况，</span></span><br><span class="line"><span class="comment">// 我们在 1 秒后主动发送取消信号，</span></span><br><span class="line"><span class="comment">// select 里面的 `case &lt;-ctx.Done()` 会返回，select 语句结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义了一个有取消功能的 Context，</span></span><br><span class="line">	<span class="comment">// ctx 里面的 Done() 方法返回的 chan 在我们调用</span></span><br><span class="line">	<span class="comment">// cancel 方法的时候会获取到值。</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.TODO())</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c context.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 1 秒后发送取消信号</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		cancel()</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// out 表示接收业务处理结果的 chan</span></span><br><span class="line">	<span class="comment">// 我们在业务处理完毕之后往其中写入数据</span></span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(out <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 模拟耗时 2 秒的业务处理</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		out &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;(out)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 1 秒后，这里接收到值，执行这一个分支</span></span><br><span class="line">		fmt.Println(ctx.Err()) <span class="comment">// 输出：context canceled</span></span><br><span class="line">		wg.Done()</span><br><span class="line">	<span class="keyword">case</span> &lt;-out:</span><br><span class="line">		fmt.Println(<span class="string">&quot;done!&quot;</span>)</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子只是用了 <code>WithCancel</code>，但是
<code>WithDeadline</code> 和 <code>WithTimeout</code>
的功能都是类似的，都是通过 <code>ctx.Done()</code> 返回的那个
<code>chan</code> 来进行父子协程之间的通信的。</p>
<h2 id="gin-里面的-context-是怎样的">gin 里面的 <code>Context</code>
是怎样的？</h2>
<p>在上一小节中，我们提到了，<code>Context</code>
表示的是协程的上下文。回到本文的主题，我们现在的场景是一个 web
框架，它的核心功能就是处理 HTTP 请求，
在我们的请求处理过程中，可能会有各种各样的操作，比如读写文件、发起新的
HTTP 请求、读写数据库等，而这些操作的耗时可能是不确定的。</p>
<p>所以 <code>gin</code> 也是需要 <code>Context</code>
的机制来控制子协程的执行的，但是正如前面所说的，<code>gin</code>
其实是一个 web 框架，它的核心功能是处理 HTTP 请求， 因此
<code>gin</code> 里面的 <code>Context</code> 除了 <code>Context</code>
共有的一些功能外，在其基础上封装了很多跟 HTTP
请求处理相关的功能，比如：</p>
<ul>
<li>表单验证</li>
<li>错误处理</li>
<li>获取请求数据</li>
<li>渲染不同格式的响应</li>
</ul>
<blockquote>
<p>这些功能不在本文的讨论范围之内，本文只探讨 Context 相关的功能。</p>
</blockquote>
<p>而且，实际上，在 <code>gin</code> 里面对 <code>Context</code>
方法的调用只是简单的对 <code>*http.Request</code> 的
<code>Context</code> 的封装，并没有什么特别的功能，除了
<code>Value()</code> 方法，它可以从 <code>Context.Keys</code>
里面获取值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deadline、Done、Err 方法会调用 http.Request 本身的 context 对应的同名方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Err() <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gin.Context.Value 方法</span></span><br><span class="line"><span class="comment">// 根据 key 获取关联的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Value(key any) any &#123;</span><br><span class="line">	<span class="comment">// 获取当前 Context 关联的请求</span></span><br><span class="line">	<span class="keyword">if</span> key == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.Request</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取 Context 本身</span></span><br><span class="line">	<span class="keyword">if</span> key == ContextKey &#123;</span><br><span class="line">		<span class="keyword">return</span> c</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从 c.Keys 里面获取共享的变量</span></span><br><span class="line">	<span class="keyword">if</span> keyAsString, ok := key.(<span class="type">string</span>); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> val, exists := c.Get(keyAsString); exists &#123;</span><br><span class="line">			<span class="keyword">return</span> val</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 都不是上面的情况，从最初的 Context 里面获取 key 对应的值</span></span><br><span class="line">	<span class="keyword">if</span> !c.engine.ContextWithFallback || c.Request == <span class="literal">nil</span> || c.Request.Context() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Request.Context().Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应该如何使用-gin-中的-context">应该如何使用 <code>gin</code>
中的 <code>Context</code> ？</h2>
<p>现在我们知道了，在我们开发中其实有很多时候是需要通过启动子协程来进行处理的。为了更好的对子协程进行一些控制，我们往往需要在父协程里面定义一个
<code>Context</code> 对象，
然后创建子协程的时候，将其作为参数传递给子协程。</p>
<p>一来可以在父子协程之间共享数据，另一方面可以让子协程感知父协程的一些控制信号。再次提醒，这个是需要子协程主动去监听
<code>context.Done()</code> 这个 <code>chan</code>
的，否则一样会导致协程泄漏，下面是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// IDE 提示不应该忽略它的第二个返回值，防止 context 泄漏</span></span><br><span class="line">	ctx, _ := context.WithDeadline(context.TODO(), time.Now().Add(time.Second))</span><br><span class="line">	<span class="comment">// 正常退出</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c context.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;goroutine 1&quot;</span>)</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ctx 到了 deadline 也不会退出</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;goroutine 2&quot;</span>)</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出 3</span></span><br><span class="line">	fmt.Println(runtime.NumGoroutine())</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// 输出 2，还有 main 协程跟上面第二个协程</span></span><br><span class="line">	fmt.Println(runtime.NumGoroutine())</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么会这样呢？这是因为，其实对于子协程来说，你传递的这个 Context
参数就仅仅是一个参数而已，只是占用了函数调用栈上的一小片内存的变量，一个变量，如果你不去管它、用它，它又能做什么呢？它只是一段内存而已。
所以才需要去主动监听 context.Done() 返回的 chan。</p>
</blockquote>
<p>因此，正确的做法是在一个合适的地方加上
<code>select</code>，如下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c context.Context)</span></span> &#123;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;for run...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-c.Done():</span><br><span class="line">            <span class="comment">// 接收到协程终止信号</span></span><br><span class="line">            fmt.Println(c.Err())</span><br><span class="line">            <span class="keyword">break</span> out</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 终止 select，继续下一次 for 循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;goroutine 2&quot;</span>)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;(ctx)</span><br></pre></td></tr></table></figure>
<p>这个例子也许不太恰当，但是反映出的一个关键点是，我们在做一些比较耗时的操作时，必须注意监听父协程的终止信号，不加以控制的话，很有可能会导致协程泄漏。</p>
<p>说了那么多，该回到正题了。正如前面两个例子那样，其实我们在 web
应用中往往有需要进行网络调用的时候，比如 rpc
调用、数据库读写，缓存读写，这些库里面往往第一个参数就是接收
<code>context.Context</code> 参数，
通过这个参数，我们就可以控制子协程的一些行为了（前提是被调用方遵循
<code>Context</code> 的约定），比如做超时控制。</p>
<p>比如，非常流行的 <code>gorm</code> 库，我们在查询的时候也可以传递
<code>Context</code> 参数进行一些控制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">	<span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// refer https://github.com/go-sql-driver/mysql#dsn-data-source-name for details</span></span><br><span class="line">	dsn := <span class="string">&quot;gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">	db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 我们的 context 定义的超时时间是 1 秒</span></span><br><span class="line">	ctx, _ := context.WithTimeout(context.TODO(), time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实际上我们的 SQL 需要执行 3 秒</span></span><br><span class="line">	db = db.WithContext(ctx).Exec(<span class="string">&quot;select sleep(3)&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出：context deadline exceeded</span></span><br><span class="line">	fmt.Println(db.Error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义的 <code>Context</code> 的超时时间是 1
秒，但实际上我们执行的 SQL 需要的时间是 3 秒，但是我们的
<code>Exec</code> 调用在 1 秒后马上就返回了，
这是因为我们传递了一个有超时控制的 <code>Context</code> 作为参数，这样
<code>gorm</code> 的 <code>mysql</code>
库就知道需要控制它的执行时间，在超时的时候可以及时响应。</p>
<p>所以回到 <code>gin</code> 中，因为我们有一个请求相关的
<code>Context</code>
所以，我们在进行网络调用这类操作的时候，可以基于这个
<code>Context</code> 创建一个新的 <code>Context</code>，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 第一个参数是代表 HTTP 请求上下文的 Context</span></span><br><span class="line">		ctx, _ := context.WithTimeout(c, time.Second)</span><br><span class="line">		<span class="comment">// ... 省略一部分代码</span></span><br><span class="line">		<span class="comment">// 执行 SQL</span></span><br><span class="line">		db := db.WithContext(ctx).Exec(<span class="string">&quot;&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(<span class="string">&quot;:3000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我们就实现了，既可以通过 <code>Context</code>
来进行父子协程的变量共享，也实现了对子协程的一些控制。</p>
<blockquote>
<p>正如我们所看到的那样，我们创建新的 <code>Context</code>
往往是基于一个父 <code>Context</code>
来创建的，在实际开发中，会出现一些相对来说比较复杂的情况，比如，父子
<code>Context</code> 都设置了 <code>Timeout</code> 又或者一个设置了
<code>Deadline</code> 一个设置了 <code>Timeout</code> 等，
这种情况下，子 <code>Context</code> 在 <code>ctx.Done()</code>
的时候，会取父子协程中设置的最小的那个时间，如下面的例子。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	start := time.Now()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父 context 的超时时间是 1 秒</span></span><br><span class="line">	ctx1, _ := context.WithTimeout(context.TODO(), time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子 context 的超时时间是 3 秒</span></span><br><span class="line">	<span class="comment">// 但实际上，在这个调用之后，ctx2 的超时时间实际上是 1 秒</span></span><br><span class="line">	ctx2, _ := context.WithTimeout(ctx1, time.Second*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-c.Done(): <span class="comment">// 1 秒后 chan 会获取到值，执行下面的逻辑</span></span><br><span class="line">			fmt.Println(c.Err())</span><br><span class="line">			ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ctx2)</span><br><span class="line"></span><br><span class="line">	&lt;-ch</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出 1</span></span><br><span class="line">	fmt.Println(time.Now().Sub(start).Seconds())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，在现在很多涉及到网络调用等耗时操作的 golang
库中，往往需要提供一个 <code>Context</code>
参数用做超时控制，我们使用的时候将 <code>gin.Context</code>
作为参数传递给 <code>context.WithTimeout</code> 之类的函数即可。</p>
<h2 id="总结">总结</h2>
<p>好了，到此为止吧，关于 <code>Context</code>
后续有空再写一篇，这里面的东西，如果对 <code>Context</code> 的一些 API
不太熟悉的话，可能会不太好懂。最后总结一下：</p>
<ul>
<li>main 函数本身是一个协程，协程里面可以通过 <code>go</code>
关键字启动新的协程。
协程本质上是一个函数调用。父子协程是可以并行执行的（前提是有多个 CPU
核）。</li>
<li>在需要等待子协程执行完的时候，可以使用
<code>sync.WaitGroup</code>，当然除了这个，另外一个方法是使用
<code>chan</code>。</li>
<li><code>Context</code>
代表的是父子协程的一个上下文对象，主要作用是共享数据、以及对子协程做一些超时控制等。</li>
<li><code>gin</code> 里面的 <code>Context</code> 除了
<code>context.Context</code> 的基本功能外，还提供了很多 HTTP
请求处理相关的一些功能，比如获取请求数据、处理响应等。</li>
<li>子协程有义务通过 <code>select</code>
来监听父协程发送的取消信号，又或者超时的信号，否则有可能导致协程泄漏。</li>
<li>我们在调用一些库的时候，比如在 <code>gorm</code> 里面进行
<code>MySQL</code>，如果需要进行超时控制，则可以通过
<code>context.WithTimeout</code> 来创建一个新的
<code>Context</code>，并把这个新的 <code>Context</code> 作为参数传递给
<code>db.WithContext</code>，这样在网络调用超时的时候，我们的调用会直接返回错误。从而避免了长时间占用资源。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/16/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/70/">70</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/18/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">eleven26</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eleven26" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
