<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eleven26.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="eleven26">
<meta property="og:url" content="https://eleven26.github.io/page/13/index.html">
<meta property="og:site_name" content="eleven26">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="eleven26">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="PHP">
<meta property="article:tag" content="Laravel">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://eleven26.github.io/page/13/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/13/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>eleven26</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">eleven26</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">100</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">346</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eleven26</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eleven26" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eleven26" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2023/04/02/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20RWMutex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20RWMutex/" class="post-title-link" itemprop="url">深入理解 go RWMutex</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-02 20:08:30" itemprop="dateCreated datePublished" datetime="2023-04-02T20:08:30+08:00">2023-04-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在上一篇文章<a
target="_blank" rel="noopener" href="https://blog.baiguiren.com/2023/03/30/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20Mutex/">《深入理解
go Mutex》</a>中， 我们已经对 go <code>Mutex</code>
的实现原理有了一个大致的了解，也知道了 <code>Mutex</code>
可以实现并发读写的安全。
今天，我们再来看看另外一种锁，<code>RWMutex</code>，有时候，其实我们读数据的频率要远远高于写数据的频率，
而且不同协程应该可以同时读取的，这个时候，<code>RWMutex</code>
就派上用场了。</p>
<p><code>RWMutex</code> 的实现原理和 <code>Mutex</code> 类似，只是在
<code>Mutex</code> 的基础上，区分了读锁和写锁：</p>
<ul>
<li>读锁：只要没有写锁，就可以获取读锁，多个协程可以同时获取读锁（<strong>可以并行读</strong>）。</li>
<li>写锁：只能有一个协程获取写锁，其他协程想获取读锁或写锁都只能等待。</li>
</ul>
<p>下面就让我们来深入了解一下 <code>RWMutex</code>
的基本使用和实现原理等内容。</p>
<h2 id="rwmutex-的整体模型">RWMutex 的整体模型</h2>
<p>正如 <code>RWMutex</code>
的命名那样，它是区分了读锁和写锁的锁，所以我们可以从读和写两个方面来看
<code>RWMutex</code> 的模型。</p>
<blockquote>
<p>下文中的 <code>reader</code> 指的是进行读操作的
goroutine，<code>writer</code> 指的是进行写操作的 goroutine。</p>
</blockquote>
<h3 id="读操作模型">读操作模型</h3>
<p>我们可以用下图来表示 <code>RWMutex</code> 的读操作模型：</p>
<figure>
<img src="/images/go/rwmutex/rwmutex_1.png" alt="rwmutex_1" />
<figcaption aria-hidden="true">rwmutex_1</figcaption>
</figure>
<blockquote>
<p>上图使用了 <code>w.Lock</code>，是因为 <code>RWMutex</code>
的实现中，写锁是使用 <code>Mutex</code> 来实现的。</p>
</blockquote>
<p>说明：</p>
<ul>
<li>读操作的时候可以同时有多个 goroutine 持有
<code>RLock</code>，然后进入临界区。（也就是可以并行读），上图的
<code>G1</code>、<code>G2</code> 和 <code>G3</code> 就是同时持有
<code>RLock</code> 的几个 goroutine。</li>
<li>在读操作的时候，如果有 goroutine 持有 <code>RLock</code>，那么其他
goroutine （不管是读还是写）就只能等待，直到所有持有 <code>RLock</code>
的 goroutine 释放锁。</li>
<li>也就是上图的 <code>G4</code> 需要等待
<code>G1</code>、<code>G2</code> 和 <code>G3</code>
释放锁之后才能进入临界区。</li>
<li>最后，因为 <code>G5</code> 和 <code>G6</code>
这两个协程获取锁的时机比 <code>G4</code> 晚，所以它们会在
<code>G4</code> 释放锁之后才能进入临界区。</li>
</ul>
<h3 id="写操作模型">写操作模型</h3>
<p>我们可以用下图来表示 <code>RWMutex</code> 的写操作模型：</p>
<figure>
<img src="/images/go/rwmutex/rwmutex_2.png" alt="rwmutex_2" />
<figcaption aria-hidden="true">rwmutex_2</figcaption>
</figure>
<p>说明：</p>
<ul>
<li>写操作的时候只能有一个 goroutine 持有
<code>Lock</code>，然后进入临界区，释放写锁之前，所有其他的 goroutine
都只能等待。</li>
<li>上图的 <code>G1</code>~<code>G5</code>
表示的是按时间顺序先后获取锁的几个 goroutine。</li>
<li>上面几个 goroutine 获取锁的过程是：
<ul>
<li><code>G1</code> 获取写锁，进入临界区。然后
<code>G2</code>、<code>G3</code>、<code>G4</code> 和 <code>G5</code>
都在等待。</li>
<li><code>G1</code> 释放写锁之后，<code>G2</code> 和 <code>G3</code>
可以同时获取读锁，进入临界区。然后 <code>G3</code>、<code>G4</code> 和
<code>G5</code> 都在等待。</li>
<li><code>G2</code> 和 <code>G3</code>
可以同时获取读锁，进入临界区。然后 <code>G4</code> 和 <code>G5</code>
都在等待。</li>
<li><code>G2</code> 和 <code>G3</code> 释放读锁之后，<code>G4</code>
获取写锁，进入临界区。然后 <code>G5</code> 在等待。</li>
<li>最后，<code>G4</code> 释放写锁，<code>G5</code>
获取读锁，进入临界区。</li>
</ul></li>
</ul>
<h2 id="基本用法">基本用法</h2>
<p><code>RWMutex</code> 中包含了以下的方法：</p>
<ul>
<li><code>Lock</code>：获取写锁，如果有其他 goroutine
持有读锁或写锁，那么就会阻塞等待。</li>
<li><code>Unlock</code>：释放写锁。</li>
<li><code>RLock</code>：获取读锁，如果有其他 goroutine
持有写锁，那么就会阻塞等待。</li>
<li><code>RUnlock</code>：释放读锁。</li>
</ul>
<p>其他不常用的方法：</p>
<ul>
<li><code>RLocker</code>：返回一个读锁，该锁包含了 <code>RLock</code> 和
<code>RUnlock</code> 方法，可以用来获取读锁和释放读锁。</li>
<li><code>TryLock</code>: 尝试获取写锁，如果获取成功，返回
<code>true</code>，否则返回 <code>false</code>。不会阻塞等待。</li>
<li><code>TryRLock</code>: 尝试获取读锁，如果获取成功，返回
<code>true</code>，否则返回 <code>false</code>。不会阻塞等待。</li>
</ul>
<h3 id="一个简单的例子">一个简单的例子</h3>
<p>我们可以通过下面的例子来看一下 <code>RWMutex</code> 的基本用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mutex</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRWMutex</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	config = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动 10 个 goroutine 来写</span></span><br><span class="line">	<span class="keyword">var</span> wg1 sync.WaitGroup</span><br><span class="line">	wg1.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			set(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>)</span><br><span class="line">			wg1.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动 100 个 goroutine 来读</span></span><br><span class="line">	<span class="keyword">var</span> wg2 sync.WaitGroup</span><br><span class="line">	wg2.Add(<span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			get(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">			wg2.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg1.Wait()</span><br><span class="line">	wg2.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 获取读锁，可以多个 goroutine 并发读取</span></span><br><span class="line">	mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> mu.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> v, ok := config[key]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(key, val <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取写锁</span></span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">	config[key] = val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们启动了 10 个 goroutine 来写配置，启动了 100 个
goroutine 来读配置。
这跟我们现实开发中的场景是一样的，很多时候其实是读多写少的。
如果我们在读的时候也使用互斥锁，那么就会导致读的性能非常差，因为读操作一般都不会有副作用的，但是如果使用互斥锁，那么就只能一个一个的读了。</p>
<p>而如果我们使用 <code>RWMutex</code>，那么就可以同时有多个 goroutine
来读取配置，这样就可以大大提高读的性能。
因为我们进行读操作的时候，可以多个 goroutine
并发读取，这样就可以大大提高读的性能。</p>
<h2 id="rwmutex-使用的注意事项">RWMutex 使用的注意事项</h2>
<p>在<a
target="_blank" rel="noopener" href="https://blog.baiguiren.com/2023/03/30/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20Mutex/">《深入理解
go Mutex》</a>中，我们已经讲过了 <code>Mutex</code> 的使用注意事项，
其实 <code>RWMutex</code> 的使用注意事项也是差不多的：</p>
<ul>
<li>不要忘记释放锁，不管是读锁还是写锁。</li>
<li><code>Lock</code> 之后，没有释放锁之前，不能再次使用
<code>Lock</code>。</li>
<li>在 <code>Unlock</code> 之前，必须已经调用了
<code>Lock</code>，否则会 <code>panic</code></li>
<li>在第一次使用 <code>RWMutex</code> 之后，不能复制，因为这样一来
<code>RWMutex</code> 的状态也会被复制。这个可以使用 <code>go vet</code>
来检查。</li>
</ul>
<h2 id="源码剖析">源码剖析</h2>
<p><code>RWMutex</code> 的一些实现原理跟 <code>Mutex</code>
是一样的，比如阻塞的时候使用信号量等，在 <code>Mutex</code>
那一篇中已经有讲解了，这里不再赘述。 这里就 <code>RWMutex</code>
的实现原理进行一些简单的剖析。</p>
<h3 id="rwmutex-结构体">RWMutex 结构体</h3>
<p><code>RWMutex</code> 的结构体定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex        <span class="comment">// 互斥锁，用于保护读写锁的状态</span></span><br><span class="line">	writerSem   <span class="type">uint32</span>       <span class="comment">// writer 信号量</span></span><br><span class="line">	readerSem   <span class="type">uint32</span>       <span class="comment">// reader 信号量</span></span><br><span class="line">	readerCount atomic.Int32 <span class="comment">// 所有 reader 数量</span></span><br><span class="line">	readerWait  atomic.Int32 <span class="comment">// writer 等待完成的 reader 数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各字段含义：</p>
<ul>
<li><code>w</code>：互斥锁，用于保护读写锁的状态。<code>RWMutex</code>
的写锁是互斥锁，所以直接使用 <code>Mutex</code> 就可以了。</li>
<li><code>writerSem</code>：writer 信号量，用于实现写锁的阻塞等待。</li>
<li><code>readerSem</code>：reader 信号量，用于实现读锁的阻塞等待。</li>
<li><code>readerCount</code>：所有 reader
数量（包括已经获取读锁的和正在等待获取读锁的 reader）。</li>
<li><code>readerWait</code>：writer 等待完成的 reader
数量（也就是获取写锁的时刻，已经获取到读锁的 reader 数量）。</li>
</ul>
<p>因为要区分读锁和写锁，所以在 <code>RWMutex</code>
中，我们需要两个信号量，一个用于实现写锁的阻塞等待，一个用于实现读锁的阻塞等待。
我们需要特别注意的是 <code>readerCount</code> 和 <code>readerWait</code>
这两个字段，我们可能会比较好奇，为什么有了 <code>readerCount</code>
这个字段， 还需要 <code>readerWait</code> 这个字段呢？</p>
<p>这是因为，我们在尝试获取写锁的时候，可能会有多个 reader
正在使用读锁，这时候我们需要知道有多少个 reader 正在使用读锁， 等待这些
reader 释放读锁之后，就获取写锁了，而 <code>readerWait</code>
这个字段就是用来记录这个数量的。 在 <code>Lock</code>
中获取写锁的时候，如果观测到 <code>readerWait</code> 不为 0
则会阻塞等待，直到 <code>readerWait</code> 为 0
之后才会真正获取写锁，然后才可以进行写操作。</p>
<h3 id="读锁源码剖析">读锁源码剖析</h3>
<p>获取读锁的方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取读锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">	<span class="keyword">if</span> rw.readerCount.Add(<span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 有 writer 在使用锁，阻塞等待 writer 完成</span></span><br><span class="line">		runtime_SemacquireRWMutexR(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读锁的实现很简单，先将 <code>readerCount</code> 加 1，如果加 1
之后的值小于 0，说明有 writer 正在使用锁，那么就需要阻塞等待 writer
完成。</p>
<p>释放读锁的方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放读锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">	<span class="comment">// readerCount 减 1，如果 readerCount 小于 0 说明有 writer 在等待</span></span><br><span class="line">	<span class="keyword">if</span> r := rw.readerCount.Add(<span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 有 writer 在等待，唤醒 writer</span></span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒 writer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">	<span class="comment">// 未 Lock 就 Unlock，panic</span></span><br><span class="line">	<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">		fatal(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// readerWait 减 1，返回值是新的 readerWait 值</span></span><br><span class="line">	<span class="keyword">if</span> rw.readerWait.Add(<span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 最后一个 reader 唤醒 writer</span></span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读锁的实现总结：</p>
<ul>
<li>获取读锁的时候，会将 <code>readerCount</code> 加 1</li>
<li>如果正在获取读锁的时候，发现 <code>readerCount</code> 小于 0，说明有
writer 正在使用锁，那么就需要阻塞等待 writer 完成。</li>
<li>释放读锁的时候，会将 <code>readerCount</code> 减 1</li>
<li>如果 <code>readerCount</code> 减 1 之后小于 0，说明有 writer
正在等待，那么就需要唤醒 writer。</li>
<li>唤醒 writer 的时候，会将 <code>readerWait</code> 减 1，如果
<code>readerWait</code> 减 1 之后为 0，说明 writer 获取锁的时候存在的
reader 都已经释放了读锁，可以获取写锁了。</li>
</ul>
<blockquote>
<p>·rwmutexMaxReaders<code>算是一个特殊的标识，在获取写锁的时候会将</code>readerCount<code>的值减去</code>rwmutexMaxReaders<code>， 所以在其他地方可以根据</code>readerCount`
是否小于 0 来判断是否有 writer 正在使用锁。</p>
</blockquote>
<h3 id="写锁源码剖析">写锁源码剖析</h3>
<p>获取写锁的方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取写锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">	<span class="comment">// 首先，解决与其他写入者的竞争。</span></span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	<span class="comment">// 向读者宣布有一个待处理的写入。</span></span><br><span class="line">	<span class="comment">// r 就是当前还没有完成的读操作，等这部分读操作完成之后才可以获取写锁。</span></span><br><span class="line">	r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="comment">// 等待活跃的 reader</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; rw.readerWait.Add(r) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 阻塞，等待最后一个 reader 唤醒</span></span><br><span class="line">		runtime_SemacquireRWMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放写锁的方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放写锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">	<span class="comment">// 向 readers 宣布没有活动的 writer。</span></span><br><span class="line">	r := rw.readerCount.Add(rwmutexMaxReaders)</span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123; <span class="comment">// r &gt;= 0 并且 &lt; rwmutexMaxReaders 才是正常的（r 是持有写锁期间尝试获取读锁的 reader 数量）</span></span><br><span class="line">		fatal(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果有 reader 在等待写锁释放，那么唤醒这些 reader。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 允许其他的 writer 继续进行。</span></span><br><span class="line">	rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写锁的实现总结：</p>
<ul>
<li>获取写锁的时候，会将 <code>readerCount</code> 减去
<code>rwmutexMaxReaders</code>，这样就可以区分读锁和写锁了。</li>
<li>如果 <code>readerCount</code> 减去 <code>rwmutexMaxReaders</code>
之后不为 0，说明有 reader 正在使用读锁，那么就需要阻塞等待这些 reader
释放读锁。</li>
<li>释放写锁的时候，会将 <code>readerCount</code> 加上
<code>rwmutexMaxReaders</code>。</li>
<li>如果 <code>readerCount</code> 加上 <code>rwmutexMaxReaders</code>
之后大于 0，说明有 reader 正在等待写锁释放，那么就需要唤醒这些
reader。</li>
</ul>
<h3 id="tryrlock-和-trylock">TryRLock 和 TryLock</h3>
<p><code>TryRLock</code> 和 <code>TryLock</code>
的实现都很简单，都是尝试获取读锁或者写锁，如果获取不到就返回
<code>false</code>，获取到了就返回
<code>true</code>，这两个方法不会阻塞等待。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TryRLock 尝试锁定 rw 以进行读取，并报告是否成功。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryRLock() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		c := rw.readerCount.Load()</span><br><span class="line">		<span class="comment">// 有 goroutine 持有写锁</span></span><br><span class="line">		<span class="keyword">if</span> c &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 尝试获取读锁</span></span><br><span class="line">		<span class="keyword">if</span> rw.readerCount.CompareAndSwap(c, c+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TryLock 尝试锁定 rw 以进行写入，并报告是否成功。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryLock() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 写锁被占用</span></span><br><span class="line">	<span class="keyword">if</span> !rw.w.TryLock() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 读锁被占用</span></span><br><span class="line">	<span class="keyword">if</span> !rw.readerCount.CompareAndSwap(<span class="number">0</span>, -rwmutexMaxReaders) &#123;</span><br><span class="line">		<span class="comment">// 释放写锁</span></span><br><span class="line">		rw.w.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 成功获取到锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p><code>RWMutex</code> 使用起来比较简单，相比 <code>Mutex</code>
而言，它区分了读锁和写锁，可以提高并发性能。最后，总结一下本文内容：</p>
<ul>
<li><code>RWMutex</code> 有两种锁：读锁和写锁。</li>
<li>读锁可以被多个 goroutine 同时持有，写锁只能被一个 goroutine
持有。也就是可以并发读，但只能互斥写。</li>
<li>写锁被占用的时候，其他的读和写操作都会被阻塞。读锁被占用的时候，其他的写操作会被阻塞，但是读操作不会被阻塞。除非读操作发生在一个新的写操作之后。</li>
<li><code>RWMutex</code> 包含以下几个方法：
<ul>
<li><code>Lock</code>：获取写锁，如果有其他的写锁或者读锁被占用，那么就会阻塞等待。</li>
<li><code>Unlock</code>：释放写锁。</li>
<li><code>RLock</code>：获取读锁，如果写锁被占用，那么就会阻塞等待。</li>
<li><code>RUnlock</code>：释放读锁。</li>
</ul></li>
<li>也包含了两个非阻塞的方法：
<ul>
<li><code>TryLock</code>：尝试获取写锁，如果获取不到就返回
<code>false</code>，获取到了就返回 <code>true</code>。</li>
<li><code>TryRLock</code>：尝试获取读锁，如果获取不到就返回
<code>false</code>，获取到了就返回 <code>true</code>。</li>
</ul></li>
<li><code>RWMutex</code> 使用的注意事项跟 <code>Mutex</code> 差不多：
<ul>
<li>使用之后不能复制</li>
<li><code>Unlock</code> 之前需要有 <code>Lock</code> 调用，否则
<code>panic</code>，<code>RUnlock</code> 之前需要有 <code>RLock</code>
调用，否则 <code>panic</code>。</li>
<li>不要忘记使用 <code>Unlock</code> 和 <code>RUnlock</code>
释放锁。</li>
</ul></li>
<li><code>RWMutex</code> 的实现：
<ul>
<li>写锁还是使用 <code>Mutex</code> 来实现。</li>
<li>获取读锁和写锁的时候，如果获取不到都会阻塞等待，直到被唤醒。</li>
<li>获取写锁的时候，会将 <code>readerCount</code> 减去
<code>rwmutexMaxReaders</code>，这样就可以直到有写锁被占用。释放写锁的时候，会将
<code>readerCount</code> 加上 <code>rwmutexMaxReaders</code>。</li>
<li>获取写锁的时候，如果还有读操作未完成，那么这一次获取写锁只会等待这部分未完成的读操作完成。所有后续的操作只能等待这一次写锁释放。</li>
</ul></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2023/03/30/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20Mutex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/30/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20Mutex/" class="post-title-link" itemprop="url">深入理解 go Mutex</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-30 20:08:30" itemprop="dateCreated datePublished" datetime="2023-03-30T20:08:30+08:00">2023-03-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在我们的日常开发中，总会有时候需要对一些变量做并发读写，比如 web
应用在同时接到多个请求之后，
需要对一些资源做初始化，而这些资源可能是只需要初始化一次的，而不是每一个
http 请求都初始化，
在这种情况下，我们需要限制只能一个协程来做初始化的操作，比如初始化数据库连接等，
这个时候，我们就需要有一种机制，可以限制只有一个协程来执行这些初始化的代码。
在 go
语言中，我们可以使用互斥锁（<code>Mutex</code>）来实现这种功能。</p>
<h2 id="互斥锁的定义">互斥锁的定义</h2>
<p>这里引用一下维基百科的定义：</p>
<p>互斥锁（<em>Mutual exclusion</em>，缩写
<code>Mutex</code>）是一种用于多线程编程中，防止两个线程同时对同一公共资源
（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（<em>critical
section</em>）达成。
临街区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。</p>
<blockquote>
<p>互斥，顾名思义，也就是只有一个线程能持有锁。当然，在 go
中，是只有一个协程能持有锁。</p>
</blockquote>
<p>下面是一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum <span class="type">int</span> <span class="comment">// 和</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex <span class="comment">// 互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add 将 sum 加 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁，只能有一个协程获取到锁，</span></span><br><span class="line">    <span class="comment">// 其他协程需要阻塞等待锁释放才能获取到锁。</span></span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="comment">// 临界区域</span></span><br><span class="line">	sum++</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMutex</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 启动 1000 个协程</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 每个协程里面调用 add()</span></span><br><span class="line">			add()</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待所有协程执行完毕</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="comment">// 最终 sum 的值应该是 1000</span></span><br><span class="line">	assert.Equal(t, <span class="number">1000</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们定义了一个全局变量
<code>sum</code>，用于存储和，然后定义了一个互斥锁 <code>mu</code>， 在
<code>add()</code> 函数中，我们使用 <code>mu.Lock()</code>
来加锁，然后对 <code>sum</code> 进行加 1 操作， 最后使用
<code>mu.Unlock()</code>
来解锁，这样就保证了在任意时刻，只有一个协程能够对 <code>sum</code>
进行加 1 操作， 从而保证了在并发执行 <code>add()</code> 操作的时候
<code>sum</code> 的值是正确的。</p>
<blockquote>
<p>上面这个例子，在我之前的文章中已经作为例子出现过很多次了，这里不再赘述了。</p>
</blockquote>
<h2 id="go-mutex-的基本用法">go Mutex 的基本用法</h2>
<p><code>Mutex</code> 我们一般只会用到它的两个方法：</p>
<ul>
<li><code>Lock</code>：获取互斥锁。(只会有一个协程可以获取到锁，通常用在临界区开始的地方。)</li>
<li><code>Unlock</code>:
释放互斥锁。(释放获取到的锁，通常用在临界区结束的地方。)</li>
</ul>
<p><code>Mutex</code> 的模型可以用下图表示：</p>
<figure>
<img src="/images/go/mutex/mutex_1.png" alt="mutex_1" />
<figcaption aria-hidden="true">mutex_1</figcaption>
</figure>
<p>说明：</p>
<ul>
<li>同一时刻只能有一个协程获取到 <code>Mutex</code>
的使用权，其他协程需要排队等待（也就是上图的
<code>G1-&gt;G2-&gt;Gn</code>）。</li>
<li>拥有锁的协程从临界区退出的时候需要使用 <code>Unlock</code>
来释放锁，这个时候等待队列的下一个协程可以获取到锁（实际实现比这里说的复杂很多，后面会细说），从而进入临界区。</li>
<li>等待的协程会在 <code>Lock</code> 调用处阻塞，<code>Unlock</code>
的时候会使得一个等待的协程解除阻塞的状态，得以继续执行。</li>
</ul>
<blockquote>
<p>上面提到的这几点也是 <code>Mutex</code> 的基本原理。</p>
</blockquote>
<h2 id="互斥锁使用的两个例子">互斥锁使用的两个例子</h2>
<p>了解了 go <code>Mutex</code> 基本原理之后，让我们再来看看
<code>Mutex</code> 的一些使用的例子。</p>
<h3 id="gin-context-中的-set-方法">gin Context 中的 Set 方法</h3>
<p>一个很常见的场景就是，并发对 <code>map</code> 进行读写，熟悉 go
的朋友应该知道，go 中的 <code>map</code> 是不支持并发读写的， 如果我们对
<code>map</code> 进行并发读写会导致 <code>panic</code>。</p>
<p>而在 <code>gin</code> 的 <code>Context</code> 结构体中，也有一个
<code>map</code> 类型的字段
<code>Keys</code>，用来在上下文间传递键值对数据， 所以在通过
<code>Set</code> 来设置键值对的时候需要使用 <code>c.mu.Lock()</code>
来先获取互斥锁，然后再对 <code>Keys</code> 做设置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set is used to store a new key/value pair exclusively for this context.</span></span><br><span class="line"><span class="comment">// It also lazy initializes  c.Keys if it was not used previously.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Set(key <span class="type">string</span>, value any) &#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">	c.mu.Lock()</span><br><span class="line">    <span class="comment">// 如果 Keys 还没初始化，则进行初始化</span></span><br><span class="line">	<span class="keyword">if</span> c.Keys == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Keys = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]any)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置键值对</span></span><br><span class="line">	c.Keys[key] = value</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，对 <code>Keys</code> 做读操作的时候也需要使用互斥锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get returns the value for the given key, ie: (value, true).</span></span><br><span class="line"><span class="comment">// If the value does not exist it returns (nil, false)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Get(key <span class="type">string</span>) (value any, exists <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">	c.mu.RLock()</span><br><span class="line">    <span class="comment">// 读取 key</span></span><br><span class="line">	value, exists = c.Keys[key]</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">	c.mu.RUnlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可能会有人觉得奇怪，为什么从 <code>map</code>
中读也还需要锁。这是因为，如果读的时候没有锁保护， 那么就有可能在
<code>Set</code> 设置的过程中，同时也在进行读操作，这样就会
<code>panic</code> 了。</p>
</blockquote>
<p>这个例子想要说明的是，像 <code>map</code>
这种数据结构本身就不支持并发读写，我们这种情况下只有使用
<code>Mutex</code> 了。</p>
<h3 id="sync.pool-中的-pinslow-方法">sync.Pool 中的 pinSlow 方法</h3>
<p>在 <code>sync.Pool</code> 的实现中，有一个全局变量记录了进程内所有的
<code>sync.Pool</code> 对象，那就是 <code>allPools</code> 变量，
另外有一个锁 <code>allPoolsMu</code> 用来保护对 <code>allPools</code>
的读写操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 保护 allPools 和 oldPools 的互斥锁。</span></span><br><span class="line">	allPoolsMu Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allPools is the set of pools that have non-empty primary</span></span><br><span class="line">	<span class="comment">// caches. Protected by either 1) allPoolsMu and pinning or 2)</span></span><br><span class="line">	<span class="comment">// STW.</span></span><br><span class="line">	allPools []*Pool</span><br><span class="line"></span><br><span class="line">	<span class="comment">// oldPools is the set of pools that may have non-empty victim</span></span><br><span class="line">	<span class="comment">// caches. Protected by STW.</span></span><br><span class="line">	oldPools []*Pool</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>pinSlow</code> 方法中会在 <code>allPoolsMu</code> 的保护下对
<code>allPools</code> 做读写操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// Retry under the mutex.</span></span><br><span class="line">	<span class="comment">// Can not lock the mutex while pinned.</span></span><br><span class="line">	runtime_procUnpin()</span><br><span class="line">	allPoolsMu.Lock() <span class="comment">// 获取锁</span></span><br><span class="line">	<span class="keyword">defer</span> allPoolsMu.Unlock() <span class="comment">// 函数返回的时候释放锁</span></span><br><span class="line">	pid := runtime_procPin()</span><br><span class="line">	<span class="comment">// poolCleanup won&#x27;t be called while we are pinned.</span></span><br><span class="line">	s := p.localSize</span><br><span class="line">	l := p.local</span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">		<span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;</span><br><span class="line">		allPools = <span class="built_in">append</span>(allPools, p) <span class="comment">// 全局变量修改</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.</span></span><br><span class="line">	size := runtime.GOMAXPROCS(<span class="number">0</span>)</span><br><span class="line">	local := <span class="built_in">make</span>([]poolLocal, size)</span><br><span class="line">	atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release</span></span><br><span class="line">	runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release</span></span><br><span class="line">	<span class="keyword">return</span> &amp;local[pid], pid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子主要是为了说明使用 <code>mu</code>
的另外一种非常常见的场景：<strong>并发读写全局变量</strong>。</p>
<h2 id="互斥锁使用的注意事项">互斥锁使用的注意事项</h2>
<p>互斥锁如果使用不当，可能会导致死锁或者出现 <code>panic</code>
的情况，下面是一些常见的错误：</p>
<ol type="1">
<li>忘记使用 <code>Unlock</code> 释放锁。</li>
<li><code>Lock</code> 之后还没 <code>Unlock</code> 之前又使用
<code>Lock</code> 获取锁。也就是重复上锁，go 中的 <code>Mutex</code>
不可重入。</li>
<li>死锁：位于临界区内不同的两个协程都想获取对方持有的不同的锁。</li>
<li>还没 <code>Lock</code> 之前就 <code>Unlock</code>。这会导致
<code>panic</code>，因为这是没有任何意义的。</li>
<li>复制 <code>Mutex</code>，比如将 <code>Mutex</code>
作为参数传递。</li>
</ol>
<p>对于第 1 点，我们往往可以使用 <code>defer</code>
关键字来做释放锁的操作。第 2 点不太好发现，只能在开发的时候多加注意。 第
3 点我们在使用锁的时候可以考虑尽量避免在临界区内再去使用别的锁。
最后，<code>Mutex</code> 是不可以复制的，这个可以在编译之前通过
<code>go vet</code> 来做检查。</p>
<p>为什么 <code>Mutex</code> 不能被复制呢？因为 <code>Mutex</code>
中包含了锁的状态，如果复制了，那么这个状态也会被复制， 如果在复制前进行
<code>Lock</code>，复制后进行 <code>Unlock</code>，那就意味着
<code>Lock</code> 和 <code>Unlock</code> 操作的其实是两个不同的状态，
这样显然是不行的，是释放不了锁的。</p>
<blockquote>
<p>虽然不可以复制，但是我们可以通过传递指针类型的参数来传递
<code>Mutex</code>。</p>
</blockquote>
<h2 id="互斥锁锁定的是什么">互斥锁锁定的是什么？</h2>
<p>在前一篇文章中，我们提到过，原子操作本质上是变量级的互斥锁。而互斥锁本身锁定的又是什么呢？
其实互斥锁本质上是一个信号量，它通过获取释放信号量，最终使得协程获得某一个代码块的执行权力。</p>
<blockquote>
<p>也就是说，互斥锁，锁定的是一块代码块。</p>
</blockquote>
<p>我们以 <code>go-zero</code> 里面的 <code>collection/fifo.go</code>
为例子说明一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Take takes the first element out of q if not empty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> Take() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// 获取互斥锁（只能有一个协程获取到锁）</span></span><br><span class="line">	q.lock.Lock()</span><br><span class="line">	<span class="comment">// 函数返回的时候释放互斥锁（获取到锁的协程释放锁之后，其他协程才能进行抢占锁）</span></span><br><span class="line">	<span class="keyword">defer</span> q.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面的代码只有抢占到（也就是互斥锁锁定的代码块）</span></span><br><span class="line">	<span class="keyword">if</span> q.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	element := q.elements[q.head]</span><br><span class="line">	q.head = (q.head + <span class="number">1</span>) % <span class="built_in">len</span>(q.elements)</span><br><span class="line">	q.count--</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> element, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了锁定代码块的这一个作用，有另外一个比较关键的地方也是我们不能忽视的，
那就是
<strong>互斥锁并不保证临界区内操作的变量不能被其他协程访问。</strong>
互斥锁只能保证一段代码只能一个协程执行，但是对于临界区内涉及的共享资源，
你在临界区外也依然是可以对其进行读写的。</p>
<p>我们以上面的代码说明一下：在上面的 <code>Take</code> 函数中，我们对
<code>q.head</code> 和 <code>q.count</code> 都进行了操作，
虽然这些操作代码位于临界区内，但是临界区并不保证持有锁期间其他协程不会在临界区外去修改
<code>q.head</code> 和 <code>q.count</code>。</p>
<p>下面就是一个非常典型的<strong>错误</strong>的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在锁的保护下对 sum 做读写操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	sum++</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMutex</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			test()</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 位于临界区外，也依然是可以对 sum 做读写操作的。</span></span><br><span class="line">		sum++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>靠谱的做法是，对于有共享资源的读写的操作都使用 <code>Mutex</code>
保护起来。</p>
</blockquote>
<p>当然，如果我们只有一个变量，那么可能使用原子操作就足够了。</p>
<h2 id="互斥锁实现原理">互斥锁实现原理</h2>
<p>互斥锁的实现有以下几个关键的地方：</p>
<ul>
<li>信号量：这是操作系统中的同步对象。</li>
<li>等待队列：获取不到互斥锁的协程，会放入到一个先入先出队列的队列尾部。这样信号量释放的时候，可以依次对它们唤醒。</li>
<li>原子操作：互斥锁的实现中，使用了一个字段来记录了几种不同的状态，使用原子操作可以保证几种状态可以一次性变更完成。</li>
</ul>
<p>我们先来看看 <code>Mutex</code>结构体定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span> <span class="comment">// 状态字段</span></span><br><span class="line">	sema  <span class="type">uint32</span> <span class="comment">// 信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>state</code> 字段记录了四种不同的信息：</p>
<figure>
<img src="/images/go/mutex/mutex_2.png" alt="mutex_2" />
<figcaption aria-hidden="true">mutex_2</figcaption>
</figure>
<p>这四种不同信息在源码中定义了不同的常量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	mutexLocked      = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 表示有 goroutine 拥有锁</span></span><br><span class="line">	mutexWoken                   <span class="comment">// 唤醒（就是第 2 位）</span></span><br><span class="line">	mutexStarving                <span class="comment">// 饥饿（第 3 位）</span></span><br><span class="line">	mutexWaiterShift = <span class="literal">iota</span>      <span class="comment">// 表示第 4 位开始，表示等待者的数量</span></span><br><span class="line"></span><br><span class="line">	starvationThresholdNs = <span class="number">1e6</span>  <span class="comment">// 1ms 进入饥饿模式的等待时间阈值</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>而 <code>sema</code> 的含义比较简单，就是一个用作不同 goroutine
同步的信号量。</p>
<h3 id="信号量">信号量</h3>
<p>go 的 <code>Mutex</code>
是基于信号量来实现的，那信号量又是什么呢？</p>
<blockquote>
<p>维基百科：信号量是一个同步对象，用于保持在 <code>0</code>
至指定最大值之间的一个计数值。当线程完成一次对该 <code>semaphore</code>
对象的等待（<code>wait</code>）时，该计数值减一；当线程完成一次对
<code>semaphore</code>
对象的释放（<code>release</code>）时，计数值加一。</p>
</blockquote>
<p>上面这个解释有点难懂，通俗地说，就是一个数字，调用 <code>wait</code>
的时候，这个数字减去 <code>1</code>，调用 <code>release</code>
的时候，这个数字加上 <code>1</code>。
（还有一个隐含的逻辑是，如果这个数小于 <code>0</code>，那么调用
<code>wait</code> 的时候会阻塞，直到它大于 <code>0</code>。）</p>
<p>对应到 go 的 <code>Mutex</code> 中，有两个操作信号量的函数：</p>
<ul>
<li><code>runtime_Semrelease</code>: 自动递增信号量并通知等待的
goroutine。</li>
<li><code>runtime_SemacquireMutex</code>: 是一直等到信号量大于
0，然后自动递减。</li>
</ul>
<p>我们注意到了，其实 <code>runtime_SemacquireMutex</code>
是有一个前提条件的，那就是等到信号量大于 0。 其实信号量的两个操作
<code>P/V</code> 就是一个加 1 一个减
1，所以在实际使用的时候，也是需要一个获取锁的操作对应一个释放锁的操作，
否则，其他协程都无法获取到锁，因为信号量一直不满足。</p>
<h3 id="等待队列">等待队列</h3>
<p>go 中如果已经有 goroutine 持有互斥锁，那么其他的协程会放入一个
<code>FIFO</code> 队列中，如下图：</p>
<figure>
<img src="/images/go/mutex/mutex_3.png" alt="mutex_3" />
<figcaption aria-hidden="true">mutex_3</figcaption>
</figure>
<p>说明：</p>
<ul>
<li><code>G1</code> 表示持有互斥锁的
goroutine，<code>G2</code>...<code>Gn</code> 表示一个 goroutine
的等待队列，这是一个先入先出的队列。</li>
<li><code>G1</code> 先持有锁，得以进入临界区，其他想抢占锁的 goroutine
阻塞在 <code>Lock</code> 调用处。</li>
<li><code>G1</code> 在使用完锁后，会使用 <code>Unlock</code>
来释放锁，本质上是释放了信号量，然后会唤醒 <code>FIFO</code> 队列头部的
<code>goroutine</code>。</li>
<li><code>G2</code> 从 <code>FIFO</code>
队列中移除，进入临界区。<code>G2</code> 使用完锁之后也会使用
<code>Unlock</code> 来释放锁。</li>
</ul>
<blockquote>
<p>上面只是一个大概模型，在实际实现中，比这个复杂很多倍，下面会继续深入讲解。</p>
</blockquote>
<h3 id="原子操作">原子操作</h3>
<p>go 的 <code>Mutex</code> 实现中，<code>state</code> 字段是一个 32
位的整数，不同的位记录了四种不同信息，在这种情况下，
只需要通过原子操作就可以保证一次性实现对四种不同状态信息的更改，而不需要更多额外的同步机制。</p>
<p>但是毋庸置疑，这种实现会大大降低代码的可读性，因为通过一个整数来记录不同的信息，
就意味着，需要通过各种位运算来实现对这个整数不同位的修改，比如将上锁的操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span> |= mutexLocked</span><br></pre></td></tr></table></figure>
<p>当然，这只是 <code>Mutex</code> 实现中最简单的一种位运算了。下面以
<code>state</code> 记录的四种不同信息为维度来具体讲解一下：</p>
<ul>
<li><code>mutexLocked</code>：这是 <code>state</code>
的最低位，<code>1</code> 表示锁被占用，<code>0</code> 表示锁没有被占用。
<ul>
<li><code>new := mutexLocked</code> 新状态为上锁状态</li>
</ul></li>
<li><code>mutexWoken</code>: 这是表示是否有协程被唤醒了的状态
<ul>
<li><code>new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken</code>
等待者数量减去 1 的同时，设置唤醒标识</li>
<li><code>new &amp;^= mutexWoken</code> 清除唤醒标识</li>
</ul></li>
<li><code>mutexStarving</code>：饥饿模式的标识
<ul>
<li><code>new |= mutexStarving</code> 设置饥饿标识</li>
</ul></li>
<li>等待者数量：<code>state &gt;&gt; mutexWaiterShift</code>
就是等待者的数量，也就是上面提到的 <code>FIFO</code> 队列中 goroutine
的数量
<ul>
<li><code>new += 1 &lt;&lt; mutexWaiterShift</code> 等待者数量加 1</li>
<li><code>delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)</code>
上锁的同时，将等待者数量减 1</li>
</ul></li>
</ul>
<blockquote>
<p>这里并没有涵盖 <code>Mutex</code>
中所有的位运算，其他操作在下文讲解源码实现的时候会提到。</p>
</blockquote>
<p>在上面做了这一系列的位运算之后，我们会得到一个新的 <code>state</code>
状态，假设名为 <code>new</code>，那么我们就可以通过 <code>CAS</code>
操作来将 <code>Mutex</code> 的 <code>state</code> 字段更新：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>)</span><br></pre></td></tr></table></figure>
<p>通过上面这个原子操作，我们就可以一次性地更新 <code>Mutex</code> 的
<code>state</code> 字段，也就是一次性更新了四种状态信息。</p>
<blockquote>
<p>这种通过一个整数记录不同状态的写法在 <code>sync</code>
包其他的一些地方也有用到，比如 <code>WaitGroup</code> 中的
<code>state</code> 字段。</p>
</blockquote>
<p>最后，对于这种操作，我们需要注意的是，因为我们在执行 <code>CAS</code>
前后是没有其他什么锁或者其他的保护机制的， 这也就意味着上面的这个
<code>CAS</code> 操作是有可能会失败的，那如果失败了怎么办呢？</p>
<p>如果失败了，也就意味着肯定有另外一个 goroutine 率先执行了
<code>CAS</code> 操作并且成功了，将 <code>state</code>
修改为了一个新的值。
这个时候，其实我们前面做的一系列位运算得到的结果实际上已经不对了，在这种情况下，<strong>我们需要获取最新的
<code>state</code>，然后再次计算得到一个新的
<code>state</code>。</strong></p>
<p>所以我们会在源码里面看到 <code>CAS</code> 操作是写在 <code>for</code>
循环里面的。</p>
<h2 id="mutex-的公平性">Mutex 的公平性</h2>
<p>在前面，我们提到 goroutien 获取不到锁的时候，会进入一个
<code>FIFO</code> 队列的队列尾，在实际实现中，其实没有那么简单，
为了获得更好的性能，在实现的时候会尽量先让运行状态的 goroutine
获得锁，当然如果队列中的 goroutine 等待太久（大于 1ms），
那么就会先让队列中的 goroutine 获得锁。</p>
<p>下面是文档中的说明：</p>
<blockquote>
<p>Mutex
可以处于两种操作模式：正常模式和饥饿模式。在正常模式下，等待者按照FIFO（先进先出）的顺序排队，但是被唤醒的等待者不拥有互斥锁，会与新到达的
Goroutine 竞争所有权。新到达的 Goroutine 有优势——它们已经在 CPU
上运行，数量可能很多，因此被唤醒的等待者有很大的机会失去锁。在这种情况下，它将排在等待队列的前面。如果等待者未能在1毫秒内获取到互斥锁，则将互斥锁切换到饥饿模式。
在饥饿模式下，互斥锁的所有权直接从解锁 Goroutine
移交给队列前面的等待者。新到达的 Goroutine
即使看起来未被锁定，也不会尝试获取互斥锁，也不会尝试自旋。相反，它们会将自己排队在等待队列的末尾。如果等待者获得互斥锁的所有权并发现（1）它是队列中的最后一个等待者，或者（2）它等待时间少于1毫秒，则将互斥锁切换回正常模式。
正常模式的性能要优于饥饿模式，因为 Goroutine
可以连续多次获取互斥锁，即使有被阻塞的等待者。饥饿模式很重要，可以防止尾部延迟的病态情况。</p>
</blockquote>
<p>简单总结：</p>
<ul>
<li><code>Mutex</code> 有两种模式：正常模式、饥饿模式。</li>
<li>正常模式下：
<ul>
<li>被唤醒的 goroutine 和正在运行的 goroutine
竞争锁。这样可以运行中的协程有机会先获取到锁，从而避免了协程切换的开销。性能更好。</li>
</ul></li>
<li>饥饿模式下：
<ul>
<li>优先让队列中的 goroutine 获得锁，并且直接放弃时间片，让给队列中的
goroutine，运行中的 goroutine 想获取锁要到队尾排队。更加公平。</li>
</ul></li>
</ul>
<h2 id="mutex-源码剖析">Mutex 源码剖析</h2>
<p><code>Mutex</code>
本身的源码其实很少，但是复杂程度是非常高的，所以第一次看的时候可能会非常懵逼，但是不妨碍我们去了解它的大概实现原理。</p>
<p><code>Mutex</code> 中主要有两个方法，<code>Lock</code> 和
<code>Unlock</code>，使用起来非常的简单，但是它的实现可不简单。下面我们就来深入了解一下它的实现。</p>
<h3 id="lock">Lock</h3>
<p><code>Lock</code> 方法的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock 获取锁。</span></span><br><span class="line"><span class="comment">// 如果锁已在使用中，则调用 goroutine 将阻塞，直到互斥量可用。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">	<span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">	<span class="comment">// 上锁成功则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">	<span class="comment">// 没有上锁成功，这个时候需要做的事情就有点多了。</span></span><br><span class="line">	m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Lock</code>
方法中，第一次获取锁的时候是非常简单的，一个简单的原子操作设置一下
<code>mutexLocked</code> 标识就完成了。
但是如果这个原子操作失败了，表示有其他 goroutine
先获取到了锁，这个时候就需要调用 <code>lockSlow</code>
来做一些额外的操作了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 mutex 锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="type">int64</span> <span class="comment">// 当前协程开始等待的时间</span></span><br><span class="line">	starving := <span class="literal">false</span>       <span class="comment">// 当前协程是否是饥饿模式</span></span><br><span class="line">	awoke := <span class="literal">false</span>          <span class="comment">// 唤醒标志（是否当前协程就是被唤醒的协程）</span></span><br><span class="line">	iter := <span class="number">0</span>               <span class="comment">// 自旋次数（超过一定次数如果还没能获得锁，就进入等待）</span></span><br><span class="line">	old := m.state          <span class="comment">// 旧的状态，每次 for 循环会重新获取当前的状态字段</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 自旋：目的是让正在运行中的 goroutine 尽快获取到锁。</span></span><br><span class="line">		<span class="comment">// 两种情况不会自旋：</span></span><br><span class="line">		<span class="comment">// 1. 饥饿模式：在饥饿模式下，锁会直接交给等待队列中的 goroutine，所以不会自旋。</span></span><br><span class="line">		<span class="comment">// 2. 锁被释放了：另外如果运行到这里的时候，发现锁已经被释放了，也就不需要自旋了。</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="comment">// 设置 mutexWoken 标识</span></span><br><span class="line">			<span class="comment">// 如果自旋是有意义的，则会进入到这里，尝试设置 mutexWoken 标识。</span></span><br><span class="line">			<span class="comment">// 设置成功在持有锁的 goroutine 获取锁的时候不会唤醒等待队列中的 goroutine，下一个获取锁的就是当前 goroutine。</span></span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				<span class="comment">// 各个判断的含义：</span></span><br><span class="line">				<span class="comment">// !awoke 已经被唤醒过一次了，说明当前协程是被从等待队列中唤醒的协程/又或者已经成功设置 mutexWoken 标识了，不需要再唤醒了。</span></span><br><span class="line">				<span class="comment">// old&amp;mutexWoken == 0 如果不等于 0 说明有 goroutine 被唤醒了，不会尝试设置 mutexWoken 标识</span></span><br><span class="line">				<span class="comment">// old&gt;&gt;mutexWaiterShift != 0 如果等待队列为空，当前 goroutine 就是下一个抢占锁的 goroutine</span></span><br><span class="line">				<span class="comment">// 前面的判断都通过了，才会进行 CAS 操作尝试设置 mutexWoken 标识</span></span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin() <span class="comment">// 自旋</span></span><br><span class="line">			iter++           <span class="comment">// 自旋次数 +1（超过一定次数会停止自旋）</span></span><br><span class="line">			old = m.state    <span class="comment">// 再次获取锁的最新状态，之后会检查是否锁被释放了</span></span><br><span class="line">			<span class="keyword">continue</span>         <span class="comment">// 继续下一次检查</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">new</span> := old</span><br><span class="line">		<span class="comment">// 饥饿模式下，新到达的 goroutines 必须排队。</span></span><br><span class="line">		<span class="comment">// 不是饥饿状态，直接竞争锁。</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 进入等待队列的两种情况：</span></span><br><span class="line">		<span class="comment">// 1. 锁依然被占用。</span></span><br><span class="line">		<span class="comment">// 2. 进入了饥饿模式。</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift <span class="comment">// 等待者数量 +1</span></span><br><span class="line">		&#125;</span><br><span class="line">		 <span class="comment">// 已经等待超过了 1ms，且锁被其他协程占用，则进入饥饿模式</span></span><br><span class="line">		<span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 唤醒之后，需要重置唤醒标志。</span></span><br><span class="line">		<span class="comment">// 不管有没有获取到锁，都是要清除这个标识的：</span></span><br><span class="line">		<span class="comment">// 获取到锁肯定要清除，如果获取到锁，需要让其他运行中的 goroutine 来抢占锁；</span></span><br><span class="line">		<span class="comment">// 如果没有获取到锁，goroutine 会阻塞，这个时候是需要持有锁的 goroutine 来唤醒的，如果有 mutexWoken 标识，持有锁的 goroutine 唤醒不了。</span></span><br><span class="line">		<span class="keyword">if</span> awoke &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">new</span> &amp;^= mutexWoken <span class="comment">// 重置唤醒标志</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 成功设置新状态</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">			<span class="comment">// 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123; <span class="comment">// 这意味着当前的 goroutine 成功获取了锁</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果已经被唤醒过，会被加入到等待队列头。</span></span><br><span class="line">			queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">				waitStartTime = runtime_nanotime()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 阻塞等待</span></span><br><span class="line">			<span class="comment">// queueLifo 为 true，表示加入到队列头。否则，加入到队列尾。</span></span><br><span class="line">			<span class="comment">// (首次加入队列加入到队尾，不是首次加入则加入队头，这样等待最久的 goroutine 优先能够获取到锁。)</span></span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">			<span class="comment">// 从等待队列中唤醒，检查锁是否应该进入饥饿模式。</span></span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取当前的锁最新状态</span></span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="comment">// 如果锁已经处于饥饿状态，直接抢到锁，返回。</span></span><br><span class="line">			<span class="comment">// 饥饿模式下，被唤醒的协程可以直接获取到锁。</span></span><br><span class="line">			<span class="comment">// 新来的 goroutine 都需要进入队列等待。</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 如果这个 goroutine 被唤醒并且 Mutex 处于饥饿模式，P 的所有权已经移交给我们，</span></span><br><span class="line">				<span class="comment">// 但 Mutex 处于不一致的状态：mutexLocked 未设置，我们仍然被视为等待者。修复这个问题。</span></span><br><span class="line">				<span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">					throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 加锁，并且减少等待者数量。</span></span><br><span class="line">				<span class="comment">// 实际上是两步操作合成了一步：</span></span><br><span class="line">				<span class="comment">// 1. m.state = m.state + 1 （获取锁）</span></span><br><span class="line">				<span class="comment">// 2. m.state = m.state - 1&lt;&lt;mutexWaiterShift（waiter - 1）</span></span><br><span class="line">				delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">				<span class="comment">// 清除饥饿状态的两种情况：</span></span><br><span class="line">				<span class="comment">// 1. 如果不需要进入饥饿模式（当前被唤醒的 goroutine 的等待时间小于 1ms）</span></span><br><span class="line">				<span class="comment">// 2. 原来的等待者数量为 1，说明是最后一个被唤醒的 goroutine。</span></span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// 退出饥饿模式</span></span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 原子操作，设置新状态。</span></span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 设置唤醒标记，重新抢占锁（会与那些运行中的 goroutine 一起竞争锁）</span></span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// CAS 更新状态失败，获取最新状态，然后重试</span></span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>lockSlow</code>
的处理非常的复杂，又要考虑让运行中的 goroutine
尽快获取到锁，又要考虑不能让等待队列中的 goroutine 等待太久。</p>
<p>代码中注释很多，再简单总结一下其中的流程：</p>
<ol type="1">
<li>为了让循环中的 goroutine 可以先获取到锁，会先让 goroutine
自旋等待锁的释放，这是因为运行中的 goroutine 正在占用
CPU，让它先获取到锁可以避免一些不必要的协程切换，从而获得更好的性能。</li>
<li>自旋完毕之后，会尝试获取锁，同时也要根据旧的锁状态来更新锁的不同状态信息，比如是否进入饥饿模式等。</li>
<li>计算得到一个新的 <code>state</code> 后，会进行 <code>CAS</code>
操作尝试更新 <code>state</code> 状态。</li>
<li><code>CAS</code> 失败会重试上面的流程。</li>
<li><code>CAS</code> 成功之后会做如下操作：</li>
</ol>
<ul>
<li>判断当前是否已经获取到锁，如果是，则返回，<code>Lock</code>
成功了。</li>
<li>会判断当前的 goroutine 是否是已经被唤醒过，如果是，会将当前
goroutine 加入到等待队列头部。</li>
<li>调用
<code>runtime_SemacquireMutex</code>，进入阻塞状态，等待下一次唤醒。</li>
<li>唤醒之后，判断是否需要进入饥饿模式。</li>
<li>最后，如果已经是饥饿模式，当前 goroutine
直接获取到锁，退出循环，否则，再进行下一次抢占锁的循环中。</li>
</ul>
<p>具体流程我们可以参考一下下面的流程图：</p>
<figure>
<img src="/images/go/mutex/mutex_4.png" alt="mutex_4" />
<figcaption aria-hidden="true">mutex_4</figcaption>
</figure>
<blockquote>
<p>图中有一些矩形方框描述了 <code>unlockSlow</code> 的关键流程。</p>
</blockquote>
<h3 id="unlock">Unlock</h3>
<p><code>Unlock</code> 方法的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlock 释放互斥锁。</span></span><br><span class="line"><span class="comment">// 如果 m 在进入 Unlock 时未被锁定，则会出现运行时错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">	<span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">	<span class="comment">// unlock 成功</span></span><br><span class="line">	<span class="comment">// unLock 操作实际上是将 state 减去 1。</span></span><br><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123; <span class="comment">// 等待队列为空的时候直接返回了</span></span><br><span class="line">		<span class="comment">// 唤醒一个等待锁的 goroutine</span></span><br><span class="line">		m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Unlock</code> 做了两件事：</p>
<ol type="1">
<li>释放当前 goroutine 持有的互斥锁：也就是将 <code>state</code> 减去
1</li>
<li>唤醒等待队列中的下一个 goroutine</li>
</ol>
<p>如果只有一个 goroutine 在使用锁，只需要简单地释放锁就可以了。
但是如果有其他的 goroutine 在阻塞等待，那么持有互斥锁的 goroutine
就有义务去唤醒下一个 goroutine。</p>
<p>唤醒的流程相对复杂一些：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unlockSlow 唤醒下一个等待锁的协程。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果未加锁，则会抛出错误。</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面的操作是唤醒一个在等待锁的协程。</span></span><br><span class="line">	<span class="comment">// 存在两种情况：</span></span><br><span class="line">	<span class="comment">// 1. 正常模式：</span></span><br><span class="line">	<span class="comment">//	 a. 不需要唤醒：没有等待者、锁已经被抢占、有其他运行中的协程在尝试获取锁、已经进入了饥饿模式</span></span><br><span class="line">	<span class="comment">//   b. 需要唤醒：其他情况</span></span><br><span class="line">	<span class="comment">// 2. 饥饿模式：唤醒等待队列头部的那个协程</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 不是饥饿模式</span></span><br><span class="line">		old := <span class="built_in">new</span></span><br><span class="line">		<span class="comment">// 自旋</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 下面几种情况不需要唤醒：</span></span><br><span class="line">			<span class="comment">// 1. 没有等待者了（没得唤醒）</span></span><br><span class="line">			<span class="comment">// 2. 锁已经被占用（只能有一个 goroutine 持有锁）</span></span><br><span class="line">			<span class="comment">// 3. 有其他运行中的协程已经被唤醒（运行中的 goroutine 通过自旋先抢占到了锁）</span></span><br><span class="line">			<span class="comment">// 4. 饥饿模式（饥饿模式下，所有新的 goroutine 都要排队，饥饿模式会直接唤醒等待队列头部的 gorutine）</span></span><br><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 获取到唤醒等待者的权力，开始唤醒一个等待者。</span></span><br><span class="line">			<span class="comment">// 下面这一行实际上是两个操作：</span></span><br><span class="line">			<span class="comment">// 1. waiter 数量 - 1</span></span><br><span class="line">			<span class="comment">// 2. 设置 mutexWoken 标志</span></span><br><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">				<span class="comment">// 正常模式下唤醒了一个 goroutine</span></span><br><span class="line">				<span class="comment">//（第二个参数为 false，表示当前的 goroutine 在释放信号量后还会继续执行直到用完时间片）</span></span><br><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 唤醒失败，进行下一次尝试。</span></span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 饥饿模式：将互斥锁的所有权移交给下一个等待者，并放弃我们的时间片，以便下一个等待者可以立即开始运行。</span></span><br><span class="line">		<span class="comment">// 注意：如果“mutexLocked”未设置，等待者在唤醒后会将其设置。</span></span><br><span class="line">		<span class="comment">// 但是，如果设置了“mutexStarving”，则仍然认为互斥锁已被锁定，因此新到来的goroutine不会获取它。</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 当前的 goroutine 放弃 CPU 时间片，让给阻塞在 sema 的 goroutine。</span></span><br><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>unlockSlow</code> 逻辑相比 <code>lockSlow</code>
要简单许多，我们可以再结合下面的流程图来阅读上面的源码：</p>
<figure>
<img src="/images/go/mutex/mutex_5.png" alt="mutex_5" />
<figcaption aria-hidden="true">mutex_5</figcaption>
</figure>
<h4 id="runtime_semrelease-第二个参数的含义">runtime_Semrelease
第二个参数的含义</h4>
<p>细心的朋友可能注意到了，在 <code>unlockSlow</code>
的实现中，有两处地方调用了 <code>runtime_Semrelease</code> 这个方法，
这个方法的作用是释放一个信号量，这样可以让阻塞在信号量上的 goroutine
得以继续执行。 它的第一个参数我们都知道，是信号量，而第二个参数
<code>true</code> 和 <code>false</code> 分别传递了一次， 那么
<code>true</code> 和 <code>false</code> 分别有什么作用呢？</p>
<p>答案是，设置为 <code>true</code> 的时候，当前的 goroutine
会直接放弃自己的时间片， 将 P 的使用权交给 <code>Mutex</code>
等待队列中的第一个 goroutine， 这样的目的是，让 <code>Mutex</code>
等待队列中的 goroutine 可以尽快地获取到锁。</p>
<h2 id="总结">总结</h2>
<p>互斥锁在并发编程中也算是非常常见的一种操作了，使用互斥锁可以限制只有一个
goroutine 可以进入临界区，
这对于并发修改全局变量、初始化等情况非常好用。最后，再总结一下本文所讲述的内容：</p>
<ul>
<li>互斥锁是一种用于多线程编程中，防止两个线程同时对同一公共资源进行读写的机制。go
中的互斥锁实现是 <code>sync.Mutex</code>。</li>
<li><code>Mutex</code> 的操作只有两个：
<ul>
<li><code>Lock</code> 获取锁，同一时刻只能有一个 goroutine
可以获取到锁，其他 goroutine 会先通过自旋抢占锁，抢不到则阻塞等待。</li>
<li><code>Unlock</code> 释放锁，释放锁之前必须有 goroutine
持有锁。释放锁之后，会唤醒等待队列中的下一个 goroutine。</li>
</ul></li>
<li><code>Mutex</code> 常见的使用场景有两个：
<ul>
<li>并发读写 <code>map</code>：如 <code>gin</code> 中
<code>Context</code> 的 <code>Keys</code> 属性的读写。</li>
<li>并发读写全局变量：如 <code>sync.Pool</code> 中对
<code>allPools</code> 的读写。</li>
</ul></li>
<li>使用 <code>Mutex</code> 需要注意以下几点：
<ul>
<li>不要忘记使用 <code>Unlock</code> 释放锁</li>
<li><code>Lock</code> 之后，没有释放锁之前，不能再次使用
<code>Lock</code></li>
<li>注意不同 goroutine
竞争不同锁的情况，需要考虑一下是否有可能会死锁</li>
<li>在 <code>Unlock</code> 之前，必须已经调用了
<code>Lock</code>，否则会 <code>panic</code></li>
<li>在第一次使用 <code>Mutex</code> 之后，不能复制，因为这样一来
<code>Mutex</code> 的状态也会被复制。这个可以使用 <code>go vet</code>
来检查。</li>
</ul></li>
<li>互斥锁可以保护一块代码块只能有一个 goroutine
执行，但是不保证临界区内操作的变量不被其他 goroutine
做并发读写操作。</li>
<li>go 的 <code>Mutex</code> 基于以下技术实现：
<ul>
<li>信号量：这是操作系统层面的同步机制</li>
<li>队列：在 goroutine 获取不到锁的时候，会将这些 goroutine 放入一个
FIFO 队列中，下次唤醒会唤醒队列头的 goroutine</li>
<li>原子操作：<code>state</code>
字段记录了四种不同的信息，通过原子操作就可以保证数据的完整性</li>
</ul></li>
<li>go <code>Mutex</code> 的公平性：
<ul>
<li>正在运行的 goroutine
如果需要锁的话，尽量让它先获取到锁，可以避免不必要的协程上下文切换。会和被唤醒的
goroutine 一起竞争锁。</li>
<li>但是如果等待队列中的 goroutine 超过了 1ms
还没有获取到锁，那么会进入饥饿模式</li>
</ul></li>
<li>go <code>Mutex</code> 的两种模式：
<ul>
<li>正常模式：运行中的 goroutine 有一定机会比等待队列中的 goroutine
先获取到锁，这种模式有更好的性能。</li>
<li>饥饿模式：所有后来的 goroutine
都直接进入等待队列，会依次从等待队列头唤醒
goroutine。可以有效避免尾延迟。</li>
</ul></li>
<li>饥饿模式下，<code>Unlock</code> 的时候会直接将当前 goroutine 所在 P
的使用权交给等待队列头部的 goroutine，放弃原本属于自己的时间片。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2023/03/25/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/25/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">深入理解 go 原子操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-25 20:08:30" itemprop="dateCreated datePublished" datetime="2023-03-25T20:08:30+08:00">2023-03-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在我们前面的一些介绍 <code>sync</code>
包相关的文章中，我们应该也发现了，其中有不少地方使用了原子操作。 比如
<code>sync.WaitGroup</code>、<code>sync.Map</code> 再到
<code>sync.Pool</code>，这些结构体的实现中都有原子操作的身影。
原子操作在并发编程中是一种非常重要的操作，它可以保证并发安全，而且效率也很高。
本文将会深入探讨一下 go 中原子操作的原理、使用场景、用法等内容。</p>
<h2 id="什么是原子操作">什么是原子操作？</h2>
<blockquote>
<p>原子操作是变量级别的互斥锁。</p>
</blockquote>
<p>如果让我用一句话来说明什么是原子操作，那就是：<strong>原子操作是变量级别的互斥锁。</strong>
简单来说，就是同一时刻，只能有一个 CPU 对变量进行读或写。
当我们想要对某个<strong>变量</strong>做并发安全的修改，除了使用官方提供的
<code>Mutex</code>，还可以使用 <code>sync/atomic</code> 包的原子操作，
它能够保证对变量的读取或修改期间不被其他的协程所影响。</p>
<p>我们可以用下图来表示：</p>
<figure>
<img src="/images/go/atomic/atomic_1.png" alt="atomic_1" />
<figcaption aria-hidden="true">atomic_1</figcaption>
</figure>
<p>说明：在上图中，我们有三个 CPU 逻辑核，其中 CPU 1 正在对变量
<code>v</code> 做原子操作，这个时候 CPU 2 和 CPU 3 不能对 <code>v</code>
做任何操作， 在 CPU 1 操作完成后，CPU 2 和 CPU 3 可以获取到
<code>v</code> 的最新值。</p>
<blockquote>
<p>从这个角度看，我们可以把 <code>sync/atomic</code>
包中的原子操作看成是变量级别的互斥锁。 就是说，在 go
中，当一个协程对变量做原子操作时，其他协程不能对这个变量做任何操作，直到这个协程操作完成。</p>
</blockquote>
<h2 id="原子操作的使用场景是什么">原子操作的使用场景是什么？</h2>
<p>拿一个简单的例子来说明一下原子操作的使用场景：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAtomic</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动 1000 个协程，每个协程对 sum 做加法操作</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			sum++</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待所有的协程都执行完毕</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(sum) <span class="comment">// 这里输出多少呢？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在自己的电脑上运行一下这段代码，看看输出的结果是多少。
不出意外的话，应该每次可能都不一样，而且应该也不是
1000，这是为什么呢？</p>
<p>这是因为，CPU 在对 <code>sum</code> 做加法的时候，需要先将
<code>sum</code> 目前的值读取到 CPU
的寄存器中，然后再进行加法操作，最后再写回到内存中。 如果有两个 CPU
同时取了 <code>sum</code>
的值，然后都进行了加法操作，然后都再写回到内存中，那么就会导致
<code>sum</code> 的值被覆盖，从而导致结果不正确。</p>
<p>举个例子，目前内存中的 <code>sum</code> 为 1，然后两个 CPU
同时取了这个 1 来做加法，然后都得到了结果 2， 然后这两个 CPU
将各自的计算结果写回到内存中，那么内存中的 <code>sum</code> 就变成了
2，而不是 3。</p>
<p>在这种场景下，我们可以使用原子操作来实现并发安全的加法操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAtomic1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将 sum 的类型改成 int32，因为原子操作只能针对 int32、int64、uint32、uint64、uintptr 这几种类型</span></span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 1000 个协程，每个协程对 sum 做加法操作</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="comment">// 将 sum++ 改成下面这样</span></span><br><span class="line">			atomic.AddInt32(&amp;sum, <span class="number">1</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(sum) <span class="comment">// 输出 1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，我们每次执行都能得到 1000 这个结果。</p>
<blockquote>
<p>因为使用原子操作的时候，同一时刻只能有一个 CPU
对变量进行读或写，所以就不会出现上面的问题了。</p>
</blockquote>
<p>所以很多需要对变量做并发读写的地方，我们都可以考虑一下，是否可以使用原子操作来实现并发安全的操作（而不是使用互斥锁，互斥锁效率相比原子操作要低一些）。</p>
<h2 id="原子操作是怎么实现的">原子操作是怎么实现的？</h2>
<p>看完上面原子操作的介绍，有没有觉得原子操作很神奇，居然有这么好用的东西。那它到底是怎么实现的呢？</p>
<p>一般情况下，原子操作的实现需要特殊的 CPU 指令或者系统调用。
这些指令或者系统调用可以保证在执行期间不会被其他操作或事件中断，从而保证操作的原子性。</p>
<p>例如，在 x86 架构的 CPU 中，可以使用 <code>LOCK</code>
前缀来实现原子操作。 <code>LOCK</code>
前缀可以与其他指令一起使用，用于锁定内存总线，防止其他 CPU
访问同一内存地址，从而实现原子操作。 在使用 <code>LOCK</code>
前缀的指令执行期间，CPU
会将当前处理器缓存中的数据写回到内存中，并锁定该内存地址， 防止其他 CPU
修改该地址的数据（所以原子操作总是可以读取到最新的数据）。 一旦当前 CPU
对该地址的操作完成，CPU 会释放该内存地址的锁定，其他 CPU
才能继续对该地址进行访问。</p>
<h3 id="x86-lock-的时候发生了什么">x86 LOCK 的时候发生了什么</h3>
<p>我们再来捋一下上面的内容，看看 <code>LOCK</code>
前缀是如何实现原子操作的：</p>
<ol type="1">
<li>CPU
会将当前处理器缓存中的数据写回到内存中。（因此我们总能读取到最新的数据）</li>
<li>然后锁定该内存地址，防止其他 CPU 修改该地址的数据。</li>
<li>一旦当前 CPU 对该地址的操作完成，CPU 会释放该内存地址的锁定，其他
CPU 才能继续对该地址进行访问。</li>
</ol>
<blockquote>
<p>其他架构的 CPU 可能会略有不同，但是原理是一样的。</p>
</blockquote>
<h2 id="原子操作有什么特征">原子操作有什么特征？</h2>
<ol type="1">
<li>不会被中断：原子操作是一个不可分割的操作，要么全部执行，要么全部不执行，不会出现中间状态。这是保证原子性的基本前提。同时，<strong>原子操作过程中不会有上下文切换的过程。</strong></li>
<li>操作对象是共享变量：原子操作通常是对共享变量进行的，也就是说，多个协程可以同时访问这个变量，因此需要采用原子操作来保证数据的一致性和正确性。</li>
<li>并发安全：原子操作是并发安全的，可以保证多个协程同时进行操作时不会出现数据竞争问题（虽然说是同时，但是实际上在操作那个变量的时候是互斥的）。</li>
<li>无需加锁：原子操作不需要使用互斥锁来保证数据的一致性和正确性，因此可以避免互斥锁的使用带来的性能损失。</li>
<li>适用场景比较局限：原子操作适用于操作单个变量，如果需要同时并发读写多个变量，可能需要考虑使用互斥锁。</li>
</ol>
<h2 id="go-里面有哪些原子操作">go 里面有哪些原子操作？</h2>
<p>在 go
中，主要有以下几种原子操作：<code>Add</code>、<code>CompareAndSwap</code>、<code>Load</code>、<code>Store</code>、<code>Swap</code>。</p>
<h3 id="增减add">增减（Add）</h3>
<ol type="1">
<li>用于进行增加或减少的原子操作，函数名以 <code>Add</code>
为前缀，后缀针对特定类型的名称。</li>
<li>原子增被操作的类型只能是数值类型，即
<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code></li>
<li>原子增减函数的第一个参数为原值，第二个参数是要增减多少。</li>
<li>方法：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt64</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> (<span class="built_in">new</span> <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint32</span><span class="params">(addr *<span class="type">uint32</span>, delta <span class="type">uint32</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint64</span><span class="params">(addr *<span class="type">uint64</span>, delta <span class="type">uint64</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, delta <span class="type">uintptr</span>)</span></span> (<span class="built_in">new</span> <span class="type">uintptr</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>int32</code> 和 <code>int64</code>
的第二个参数可以是负数，这样就可以做原子减法了。</p>
</blockquote>
<h3 id="比较并交换compareandswap">比较并交换（CompareAndSwap）</h3>
<p>也就是我们常见的 <code>CAS</code>，在 <code>CAS</code>
操作中，会需要拿旧的值跟 <code>old</code> 比较，如果相等，就将
<code>new</code> 赋值给 <code>addr</code>。
如果不相等，则不做任何操作。最后返回一个 <code>bool</code>
值，表示是否成功 <code>swap</code>。</p>
<p>也就是说，这个操作可能是不成功的。这很正常，在并发环境下，多个协程对同一个变量进行操作，肯定会存在竞争的情况。
在这种情况下，偶尔的失败是正常的，我们只需要在失败的时候，重新尝试即可。
因为原子操作需要的时间往往是比较短的，因此在失败的时候，我们可以通过自旋的方式来再次进行尝试。</p>
<blockquote>
<p>在这种情况下，如果不自旋，那就需要将这个协程挂起，等待其他协程完成操作，然后再次尝试。这个过程相比自旋可能会更加耗时。
因为很有可能这次原子操作不成功，下一次就成功了。如果我们每次都将协程挂起，那么效率就会大大降低。</p>
</blockquote>
<p><code>for</code> + 原子操作的方式，在 go 的 <code>sync</code>
包中很多地方都有使用，比如 <code>sync.Map</code>，<code>sync.Pool</code>
等。 这也是使用原子操作时一个非常常见的使用模式。</p>
<p><code>CompareAndSwap</code> 的功能：</p>
<ol type="1">
<li>用于比较并交换的原子操作，函数名以 <code>CompareAndSwap</code>
为前缀，后缀针对特定类型的名称。</li>
<li>原子比较并交换被操作的类型可以是数值类型或指针类型，即
<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>、<code>unsafe.Pointer</code></li>
<li>原子比较并交换函数的第一个参数为原值指针，第二个参数是要比较的值，第三个参数是要交换的值。</li>
<li>方法：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="type">int32</span>, old, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="type">int64</span>, old, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, old, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, old, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapPointer</span><span class="params">(addr *unsafe.Pointer, old, <span class="built_in">new</span> unsafe.Pointer)</span></span> (swapped <span class="type">bool</span>)</span><br></pre></td></tr></table></figure>
<h3 id="载入load">载入（Load）</h3>
<p>原子性的读取操作接受一个对应类型的指针值，返回该指针指向的值。原子性读取意味着读取值的同时，当前计算机的任何
CPU 都不会进行针对值的读写操作。</p>
<p>如果不使用原子 <code>Load</code>，当使用 <code>v := value</code>
这种赋值方式为变量 <code>v</code> 赋值时，读取到的 <code>value</code>
可能不是最新的，因为在读取操作时其他协程对它的读写操作可能会同时发生。</p>
<p>Load 操作有下面这些：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="type">int32</span>)</span></span> (val <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt64</span><span class="params">(addr *<span class="type">int64</span>)</span></span> (val <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint32</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> (val <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint64</span><span class="params">(addr *<span class="type">uint64</span>)</span></span> (val <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUintptr</span><span class="params">(addr *<span class="type">uintptr</span>)</span></span> (val <span class="type">uintptr</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadPointer</span><span class="params">(addr *unsafe.Pointer)</span></span> (val unsafe.Pointer)</span><br></pre></td></tr></table></figure>
<h3 id="存储store">存储（Store）</h3>
<p><code>Store</code> 可以将 <code>val</code> 值保存到
<code>*addr</code> 中，<code>Store</code> 操作是原子性的，因此在执行
<code>Store</code> 操作时，当前计算机的任何 CPU 都不会进行针对
<code>*addr</code> 的读写操作。</p>
<ol type="1">
<li>原子性存储会将 <code>val</code> 值保存到 <code>*addr</code>
中。</li>
<li>与读操作对应的写入操作，<code>sync/atomic</code> 提供了与原子值载入
<code>Load</code> 函数相对应的原子值存储 <code>Store</code>
函数，原子性存储函数均以 <code>Store</code> 为前缀。</li>
</ol>
<p><code>Store</code> 操作有下面这些：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="type">int32</span>, val <span class="type">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt64</span><span class="params">(addr *<span class="type">int64</span>, val <span class="type">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint32</span><span class="params">(addr *<span class="type">uint32</span>, val <span class="type">uint32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint64</span><span class="params">(addr *<span class="type">uint64</span>, val <span class="type">uint64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUintptr</span><span class="params">(addr *uintpre, val <span class="type">uintptr</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorePointer</span><span class="params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="交换swap">交换（Swap）</h3>
<p><code>Swap</code> 跟 <code>Store</code> 有点类似，但是它会返回
<code>*addr</code> 的旧值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt32</span><span class="params">(addr *<span class="type">int32</span>, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (old <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt64</span><span class="params">(addr *<span class="type">int64</span>, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (old <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (old <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (old <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (old <span class="type">uintptr</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapPointer</span><span class="params">(addr *unsafe.Pointer, <span class="built_in">new</span> unsafe.Pointer)</span></span> (old unsafe.Pointer)</span><br></pre></td></tr></table></figure>
<h2 id="原子操作的使用场景是什么-1">原子操作的使用场景是什么？</h2>
<p>文章开头的地方，我们已经说了，原子操作本质上是一种<strong>变量级别的互斥锁</strong>。
因此，原子操作的使用场景也是和互斥锁类似的，但是不一样的是，我们的锁粒度只是一个变量而已。
也就是说，当我们不允许多个 CPU
同时对变量进行读写的时候（保证变量同一时刻只能一个 CPU
操作），就可以使用原子操作。</p>
<h2 id="原子操作任意类型的值---atomic.value">原子操作任意类型的值 -
atomic.Value</h2>
<p>从上一节中，我们知道了在 go 中原子操作可以操作
<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>、<code>unsafe.Pointer</code>
这些类型的值。 但是在实际开发中，我们的类型还有很多，比如
<code>string</code>、<code>struct</code>
等等，那这些类型的值如何进行原子操作呢？答案是使用
<code>atomic.Value</code>。</p>
<p><code>atomic.Value</code> 是一个结构体，它的内部有一个
<code>any</code>
类型的字段，存储了我们要原子操作的值，也就是一个任意类型的值。</p>
<p><code>atomic.Value</code> 支持以下操作：</p>
<ul>
<li><code>Load</code>：原子性的读取 <code>Value</code> 中的值。</li>
<li><code>Store</code>：原子性的存储一个值到 <code>Value</code>
中。</li>
<li><code>Swap</code>：原子性的交换 <code>Value</code>
中的值，返回旧值。</li>
<li><code>CompareAndSwap</code>：原子性的比较并交换 <code>Value</code>
中的值，如果旧值和 <code>old</code> 相等，则将 <code>new</code> 存入
<code>Value</code> 中，返回 <code>true</code>，否则返回
<code>false</code>。</li>
</ul>
<p><code>atomic.Value</code>
的这些操作跟上面讲到的那些操作其实差不多，只不过
<code>atomic.Value</code> 可以操作任意类型的值。 那
<code>atomic.Value</code> 是如何实现的呢？</p>
<h2 id="atomic.value-源码分析">atomic.Value 源码分析</h2>
<p><code>atomic.Value</code> 是一个结构体，这个结构体只有一个字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Value 提供一致类型值的原子加载和存储。</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">	v any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="load---读取">Load - 读取</h3>
<p><code>Load</code> 返回由最近的 <code>Store</code>
设置的值。如果还没有 <code>Store</code> 过任何值，则返回
<code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load 返回由最近的 Store 设置的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Load() (val any) &#123;</span><br><span class="line">	<span class="comment">// atomic.Value 转换为 efaceWords</span></span><br><span class="line">	vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断 atomic.Value 的类型</span></span><br><span class="line">	typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">	<span class="comment">// 第一次 Store 还没有完成，直接返回 nil</span></span><br><span class="line">	<span class="keyword">if</span> typ == <span class="literal">nil</span> || typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">		<span class="comment">// firstStoreInProgress 是一个特殊的变量，存储到 typ 中用来表示第一次 Store 还没有完成</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 atomic.Value 的值</span></span><br><span class="line">	data := LoadPointer(&amp;vp.data)</span><br><span class="line">	<span class="comment">// 将 val 转换为 efaceWords 类型</span></span><br><span class="line">	vlp := (*efaceWords)(unsafe.Pointer(&amp;val))</span><br><span class="line">	<span class="comment">// 分别赋值给 val 的 typ 和 data</span></span><br><span class="line">	vlp.typ = typ</span><br><span class="line">	vlp.data = data</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>atomic.Value</code> 的源码中，我们都可以看到
<code>efaceWords</code> 的身影，它实际上代表的是
<code>interface&#123;&#125;/any</code> 类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示一个 interface&#123;&#125;/any 类型</span></span><br><span class="line"><span class="keyword">type</span> efaceWords <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  unsafe.Pointer</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里我们会不会觉得很困惑，直接返回 <code>val</code>
不就可以了吗？为什么要将 <code>val</code> 转换为 <code>efaceWords</code>
类型呢？</p>
<p>这是因为 go 中的原子操作只能操作
<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>、<code>unsafe.Pointer</code>
这些类型的值， 不支持 <code>interface&#123;&#125;</code> 类型，但是如果了解
<code>interface&#123;&#125;</code> 底层结构的话，我们就知道
<code>interface&#123;&#125;</code> 底层其实就是一个结构体， 它有两个字段，一个是
<code>type</code>，一个是 <code>data</code>，<code>type</code> 用来存储
<code>interface&#123;&#125;</code> 的类型，<code>data</code> 用来存储
<code>interface&#123;&#125;</code> 的值。 而且这两个字段都是
<code>unsafe.Pointer</code> 类型的，所以其实我们可以对
<code>interface&#123;&#125;</code> 的 <code>type</code> 和 <code>data</code>
分别进行原子操作， 这样最终其实也可以达到了原子操作
<code>interface&#123;&#125;</code> 的目的了，是不是非常地巧妙呢？</p>
<h3 id="store---存储">Store - 存储</h3>
<p><code>Store</code> 将 <code>Value</code> 的值设置为
<code>val</code>。对给定值的所有存储调用必须使用相同具体类型的值。不一致类型的存储会发生恐慌，<code>Store(nil)</code>
也会 <code>panic</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store 将 Value 的值设置为 val。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Store(val any) &#123;</span><br><span class="line">	<span class="comment">// 不能存储 nil 值</span></span><br><span class="line">	<span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: store of nil value into Value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// atomic.Value 转换为 efaceWords</span></span><br><span class="line">	vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">	<span class="comment">// val 转换为 efaceWords</span></span><br><span class="line">	vlp := (*efaceWords)(unsafe.Pointer(&amp;val))</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 自旋进行原子操作，这个过程不会很久，开销相比互斥锁小</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// LoadPointer 可以保证获取到的是最新的</span></span><br><span class="line">		typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">		<span class="comment">// 第一次 store 的时候 typ 还是 nil，说明是第一次 store</span></span><br><span class="line">		<span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 尝试开始第一次 Store。</span></span><br><span class="line">			<span class="comment">// 禁用抢占，以便其他 goroutines 可以自旋等待完成。</span></span><br><span class="line">			<span class="comment">// （如果允许抢占，那么其他 goroutine 自旋等待的时间可能会比较长，因为可能会需要进行协程调度。）</span></span><br><span class="line">			runtime_procPin()</span><br><span class="line">			<span class="comment">// 抢占失败，意味着有其他 goroutine 成功 store 了，允许抢占，再次尝试 Store</span></span><br><span class="line">			<span class="comment">// 这也是一个原子操作。</span></span><br><span class="line">			<span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;</span><br><span class="line">				runtime_procUnpin()</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 完成第一次 store</span></span><br><span class="line">			<span class="comment">// 因为有 firstStoreInProgress 标识的保护，所以下面的两个原子操作是安全的。</span></span><br><span class="line">			StorePointer(&amp;vp.data, vlp.data) <span class="comment">// 存储值（原子操作）</span></span><br><span class="line">			StorePointer(&amp;vp.typ, vlp.typ)   <span class="comment">// 存储类型（原子操作）</span></span><br><span class="line">			runtime_procUnpin()              <span class="comment">// 允许抢占</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 另外一个 goroutine 正在进行第一次 Store。自旋等待。</span></span><br><span class="line">		<span class="keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第一次 Store 已经完成了，下面不是第一次 Store 了。</span></span><br><span class="line">		<span class="comment">// 需要检查当前 Store 的类型跟第一次 Store 的类型是否一致，不一致就 panic。</span></span><br><span class="line">		<span class="keyword">if</span> typ != vlp.typ &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: store of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 后续的 Store 只需要 Store 值部分就可以了。</span></span><br><span class="line">		<span class="comment">// 因为 atomic.Value 只能保存一种类型的值。</span></span><br><span class="line">		StorePointer(&amp;vp.data, vlp.data)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Store</code> 中，有以下几个注意的点：</p>
<ol type="1">
<li>使用 <code>firstStoreInProgress</code> 来确保第一次
<code>Store</code> 的时候，只有一个 <code>goroutine</code> 可以进行
<code>Store</code> 操作，其他的 <code>goroutine</code>
需要自旋等待。如果没有这个保护，那么存储 <code>typ</code> 和
<code>data</code>
的时候就会出现竞争（因为需要两个原子操作），导致数据不一致。在这里其实可以将
<code>firstStoreInProgress</code> 看作是一个互斥锁。</li>
<li>在进行第一次 <code>Store</code> 的时候，会将当前的 goroutine 和
<code>P</code> 绑定，这样拿到 <code>firstStoreInProgress</code>
锁的协程就可以尽快地完成第一次 <code>Store</code>
操作，这样一来，其他的协程也不用等待太久。</li>
<li>在第一次 <code>Store</code>
的时候，会有两个原子操作，分别存储类型和值，但是因为有
<code>firstStoreInProgress</code> 的保护，所以这两个原子操作本质上是对
<code>interface&#123;&#125;</code> 的一个原子存储操作。</li>
<li>其他协程在看到有 <code>firstStoreInProgress</code>
标识的时候，就会自旋等待，直到第一次 <code>Store</code> 完成。</li>
<li>在后续的 <code>Store</code> 操作中，只需要存储值就可以了，因为
<code>atomic.Value</code> 只能保存一种类型的值。</li>
</ol>
<h3 id="swap---交换">Swap - 交换</h3>
<p><code>Swap</code> 将 <code>Value</code> 的值设置为 <code>new</code>
并返回旧值。对给定值的所有交换调用必须使用相同具体类型的值。同时，不一致类型的交换会发生恐慌，<code>Swap(nil)</code>
也会 <code>panic</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swap 将 Value 的值设置为 new 并返回旧值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Swap(<span class="built_in">new</span> any) (old any) &#123;</span><br><span class="line">	<span class="comment">// 不能存储 nil 值</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: swap of nil value into Value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// atomic.Value 转换为 efaceWords</span></span><br><span class="line">	vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">	<span class="comment">// new 转换为 efaceWords</span></span><br><span class="line">	np := (*efaceWords)(unsafe.Pointer(&amp;<span class="built_in">new</span>))</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 自旋进行原子操作，这个过程不会很久，开销相比互斥锁小</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 下面这部分代码跟 Store 一样，不细说了。</span></span><br><span class="line">		<span class="comment">// 这部分代码是进行第一次存储的代码。</span></span><br><span class="line">		typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">		<span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">			runtime_procPin()</span><br><span class="line">			<span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;</span><br><span class="line">				runtime_procUnpin()</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			StorePointer(&amp;vp.data, np.data)</span><br><span class="line">			StorePointer(&amp;vp.typ, np.typ)</span><br><span class="line">			runtime_procUnpin()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> typ != np.typ &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: swap of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ---- 下面是 Swap 的特有逻辑 ----</span></span><br><span class="line">		<span class="comment">// op 是返回值</span></span><br><span class="line">		op := (*efaceWords)(unsafe.Pointer(&amp;old))</span><br><span class="line">		<span class="comment">// 返回旧的值</span></span><br><span class="line">		op.typ, op.data = np.typ, SwapPointer(&amp;vp.data, np.data)</span><br><span class="line">		<span class="keyword">return</span> old</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="compareandswap---比较并交换">CompareAndSwap - 比较并交换</h3>
<p><code>CompareAndSwap</code> 将 <code>Value</code> 的值与
<code>old</code> 比较，如果相等则设置为 <code>new</code> 并返回
<code>true</code>，否则返回 <code>false</code>。
对给定值的所有比较和交换调用必须使用相同具体类型的值。同时，不一致类型的比较和交换会发生恐慌，<code>CompareAndSwap(nil, nil)</code>
也会 <code>panic</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompareAndSwap 比较并交换。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> CompareAndSwap(old, <span class="built_in">new</span> any) (swapped <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// 注意：old 是可以为 nil 的，new 不能为 nil。</span></span><br><span class="line">	<span class="comment">// old 是 nil 表示是第一次进行 Store 操作。</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: compare and swap of nil value into Value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// atomic.Value 转换为 efaceWords</span></span><br><span class="line">	vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">	<span class="comment">// new 转换为 efaceWords</span></span><br><span class="line">	np := (*efaceWords)(unsafe.Pointer(&amp;<span class="built_in">new</span>))</span><br><span class="line">	<span class="comment">// old 转换为 efaceWords</span></span><br><span class="line">	op := (*efaceWords)(unsafe.Pointer(&amp;old))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// old 和 new 类型必须一致，且不能为 nil</span></span><br><span class="line">	<span class="keyword">if</span> op.typ != <span class="literal">nil</span> &amp;&amp; np.typ != op.typ &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: compare and swap of inconsistently typed values&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自旋进行原子操作，这个过程不会很久，开销相比互斥锁小</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// LoadPointer 可以保证获取到的 typ 是最新的</span></span><br><span class="line">		typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">		<span class="keyword">if</span> typ == <span class="literal">nil</span> &#123; <span class="comment">// atomic.Value 是 nil，还没 Store 过</span></span><br><span class="line">			<span class="comment">// 准备进行第一次 Store，但是传递进来的 old 不是 nil，compare 这一步就失败了。直接返回 false</span></span><br><span class="line">			<span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 下面这部分代码跟 Store 一样，不细说了。 </span></span><br><span class="line">			<span class="comment">// 这部分代码是进行第一次存储的代码。</span></span><br><span class="line">			runtime_procPin()</span><br><span class="line">			<span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;</span><br><span class="line">				runtime_procUnpin()</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			StorePointer(&amp;vp.data, np.data)</span><br><span class="line">			StorePointer(&amp;vp.typ, np.typ)</span><br><span class="line">			runtime_procUnpin()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> typ != np.typ &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: compare and swap of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过运行时相等性检查比较旧版本和当前版本。</span></span><br><span class="line">		<span class="comment">// 这允许对值类型进行比较，这是包函数所没有的。</span></span><br><span class="line">		<span class="comment">// 下面的 CompareAndSwapPointer 仅确保 vp.data 自 LoadPointer 以来没有更改。</span></span><br><span class="line">		data := LoadPointer(&amp;vp.data)</span><br><span class="line">		<span class="keyword">var</span> i any</span><br><span class="line">		(*efaceWords)(unsafe.Pointer(&amp;i)).typ = typ</span><br><span class="line">		(*efaceWords)(unsafe.Pointer(&amp;i)).data = data</span><br><span class="line">		<span class="keyword">if</span> i != old &#123; <span class="comment">// atomic.Value 跟 old 不相等</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 只做 val 部分的 cas 操作</span></span><br><span class="line">		<span class="keyword">return</span> CompareAndSwapPointer(&amp;vp.data, data, np.data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要特别说明的只有最后那个比较相等的判断，也就是
<code>data := LoadPointer(&amp;vp.data)</code> 以及往后的几行代码。
在开发 <code>atomic.Value</code>
第一版的时候，那个开发者其实是将这几行写成
<code>CompareAndSwapPointer(&amp;vp.data, old.data, np.data)</code>
这种形式的。 但是在旧的写法中，会存在一个问题，如果我们做
<code>CAS</code> 操作的时候，如果传递的参数 <code>old</code>
是一个结构体的值这种类型，那么这个结构体的值是会被拷贝一份的，
同时再会被转换为 <code>interface&#123;&#125;/any</code>
类型，这个过程中，其实参数的 <code>old</code> 的 <code>data</code>
部分指针指向的内存跟 <code>vp.data</code> 指向的内存是不一样的。
这样的话，<code>CAS</code> 操作就会失败，这个时候就会返回
<code>false</code>，但是我们本意是要比较它的值，出现这种结果显然不是我们想要的。</p>
<blockquote>
<p>将值作为 <code>interface&#123;&#125;</code>
参数使用的时候，会存在一个将值转换为 <code>interface&#123;&#125;</code>
的过程。具体我们可以看看 <code>interface&#123;&#125;</code> 的实现原理。</p>
</blockquote>
<p>所以，在上面的实现中，会将旧值的 <code>typ</code> 和
<code>data</code> 赋值给一个 <code>any</code> 类型的变量， 然后使用
<code>i != old</code>
这种方式进行判断，这样就可以实现在比较的时候，比较的是值，而不是由值转换为
<code>interface&#123;&#125;</code> 后的指针。</p>
<h2 id="其他原子类型">其他原子类型</h2>
<p>我们现在知道了，<code>atomic.Value</code> 可以对任意类型做原子操作。
而对于其他的原子类型，比如
<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>、<code>unsafe.Pointer</code>
等， 其实在 go
中也提供了包装的类型，让我们可以以对象的方式来操作这些类型。</p>
<p>对应的类型如下：</p>
<ul>
<li><code>atomic.Bool</code>：这个比较特别，但底层实际上是一个
<code>uint32</code> 类型的值。我们对 <code>atomic.Bool</code>
做原子操作的时候，实际上是对 <code>uint32</code> 做原子操作。</li>
<li><code>atomic.Int32</code>：<code>int32</code> 类型的包装类型</li>
<li><code>atomic.Int64</code>：<code>int64</code> 类型的包装类型</li>
<li><code>atomic.Uint32</code>：<code>uint32</code> 类型的包装类型</li>
<li><code>atomic.Uint64</code>：<code>uint64</code> 类型的包装类型</li>
<li><code>atomic.Uintptr</code>：<code>uintptr</code>
类型的包装类型</li>
<li><code>atomic.Pointer</code>：<code>unsafe.Pointer</code>
类型的包装类型</li>
</ul>
<p>这几种类型的实现的代码基本一样，除了类型不一样，我们可以看看
<code>atomic.Int32</code> 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An Int32 is an atomic int32. The zero value is zero.</span></span><br><span class="line"><span class="keyword">type</span> Int32 <span class="keyword">struct</span> &#123;</span><br><span class="line">	_ noCopy</span><br><span class="line">	v <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load atomically loads and returns the value stored in x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int32)</span></span> Load() <span class="type">int32</span> &#123; <span class="keyword">return</span> LoadInt32(&amp;x.v) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store atomically stores val into x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int32)</span></span> Store(val <span class="type">int32</span>) &#123; StoreInt32(&amp;x.v, val) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swap atomically stores new into x and returns the previous value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int32)</span></span> Swap(<span class="built_in">new</span> <span class="type">int32</span>) (old <span class="type">int32</span>) &#123; <span class="keyword">return</span> SwapInt32(&amp;x.v, <span class="built_in">new</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareAndSwap executes the compare-and-swap operation for x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int32)</span></span> CompareAndSwap(old, <span class="built_in">new</span> <span class="type">int32</span>) (swapped <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> CompareAndSwapInt32(&amp;x.v, old, <span class="built_in">new</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>atomic.Int32</code> 的实现都是基于
<code>atomic</code> 包中 <code>int32</code>
类型相关的原子操作函数来实现的。</p>
<h2 id="原子操作与互斥锁比较">原子操作与互斥锁比较</h2>
<p>那我们有了互斥锁，为什么还要有原子操作呢？我们进行比较一下就知道了：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>原子操作</th>
<th>互斥锁</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>保护的范围</td>
<td>变量</td>
<td>代码块</td>
</tr>
<tr class="even">
<td>保护的粒度</td>
<td>小</td>
<td>大</td>
</tr>
<tr class="odd">
<td>性能</td>
<td>高</td>
<td>低</td>
</tr>
<tr class="even">
<td>如何实现的</td>
<td>硬件指令</td>
<td>软件层面实现，逻辑较多</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果我们只需要对某一个变量做并发读写，那么使用原子操作就可以了，因为原子操作的性能比互斥锁高很多。
但是如果我们需要对多个变量做并发读写，那么就需要用到互斥锁了，这种场景往往是在一段代码中对不同变量做读写。</p>
</blockquote>
<h3 id="性能比较">性能比较</h3>
<p>我们前面这个表格提到了原子操作与互斥锁性能上有差异，我们写几行代码来进行比较一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统信息 cpu: Intel(R) Core(TM) i7-8700 CPU @ 3.20GHz</span></span><br><span class="line"><span class="comment">// 10.13 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMutex</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">      mu.Lock()</span><br><span class="line">      mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.849 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAtomic</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> sum atomic.Uint64</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">      sum.Add(<span class="type">uint64</span>(<span class="number">1</span>))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对 <code>Mutex</code> 的性能测试中，我只是写了简单的
<code>Lock()</code> 和 <code>UnLock()</code> 操作，因为这种比较才算是对
<code>Mutex</code> 本身的测试，而在 <code>Atomic</code> 的性能测试中，对
<code>sum</code> 做原子累加的操作。最终结果是，使用 <code>Atomic</code>
的操作耗时大概比 <code>Mutex</code> 少了 <code>40%</code> 以上。</p>
<blockquote>
<p>在实际开发中，<code>Mutex</code>
保护的临界区内往往有更多操作，也就意味着 <code>Mutex</code>
锁需要耗费更长的时间才能释放，也就是会需要耗费比上面这个
<code>40%</code> 还要多的时间另外一个协程才能获取到 <code>Mutex</code>
锁。</p>
</blockquote>
<h2 id="go-的-sync-包中的原子操作">go 的 sync 包中的原子操作</h2>
<p>在文章的开头，我们就说了，在 go 的 <code>sync.Map</code> 和
<code>sync.Pool</code>
中都有用到了原子操作，本节就来看一看这些操作。</p>
<h3 id="sync.map-中的原子操作">sync.Map 中的原子操作</h3>
<p>在 <code>sync.Map</code> 中使用到了一个 <code>entry</code>
结构体，这个结构体中大部分操作都是原子操作，我们可以看看它下面这两个方法的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除 entry</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := e.p.Load()</span><br><span class="line">		<span class="comment">// 已经被删除了，不需要再删除</span></span><br><span class="line">		<span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 删除成功</span></span><br><span class="line">		<span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果条目尚未删除，trySwap 将交换一个值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> trySwap(i *any) (*any, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := e.p.Load()</span><br><span class="line">		<span class="comment">// 已经被删除了</span></span><br><span class="line">		<span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// swap 成功</span></span><br><span class="line">		<span class="keyword">if</span> e.p.CompareAndSwap(p, i) &#123;</span><br><span class="line">			<span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到一个非常典型的特征就是 <code>for</code> +
<code>CompareAndSwap</code> 的组合，这个组合在 <code>entry</code>
中出现了很多次。</p>
<blockquote>
<p>如果我们也需要对变量做并发读写，也可以尝试一下这种 for +
CompareAndSwap 的组合。</p>
</blockquote>
<h3 id="sync.waitgroup-中的原子操作">sync.WaitGroup 中的原子操作</h3>
<p>在 <code>sync.WaitGroup</code> 中有一个类型为
<code>atomic.Uint64</code> 的 <code>state</code>
字段，这个变量是用来记录 <code>WaitGroup</code> 的状态的。
在实际使用中，它的高 32 位用来记录 <code>WaitGroup</code> 的计数器，低
32 位用来记录 <code>WaitGroup</code> 的 <code>Waiter</code>
的数量，也就是等待条件变量满足的协程数量。</p>
<p>如果不使用一个变量来记录这两个值，那么我们就需要使用两个变量来记录，这样就会导致我们需要对两个变量做并发读写，
在这种情况下，我们就需要使用互斥锁来保护这两个变量，这样就会导致性能的下降。</p>
<p>而使用一个变量来记录这两个值，我们就可以使用原子操作来保护这个变量，这样就可以保证并发读写的安全性，同时也能得到更好的性能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WaitGroup 的 Add 函数：高 32 位加上 delta</span></span><br><span class="line">state := wg.state.Add(<span class="type">uint64</span>(delta) &lt;&lt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WaitGroup 的 Wait 函数：低 32 位加 1</span></span><br><span class="line"><span class="comment">// 等待者的数量加 1</span></span><br><span class="line">wg.state.CompareAndSwap(state, state+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="cas-操作有失败必然有成功">CAS 操作有失败必然有成功</h2>
<p>当然这里是指指向同一行 <code>CAS</code>
代码的时候（也就是有竞争的时候），如果是指向不同行 <code>CAS</code>
代码的时候，那么就不一定了。 比如下面这个例子，我们把前面计算
<code>sum</code> 的例子改一改，改成用 <code>CAS</code> 操作来完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCas</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="comment">// 这一行是有可能会失败的</span></span><br><span class="line">			atomic.CompareAndSwapInt32(&amp;sum, sum, sum+<span class="number">1</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(sum) <span class="comment">// 不是 1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们把 <code>atomic.AddInt32(&amp;sum, 1)</code> 改成了
<code>atomic.CompareAndSwapInt32(&amp;sum, sum, sum+1)</code>，
这样就会导致有可能会有多个 goroutine 同时执行到
<code>atomic.CompareAndSwapInt32(&amp;sum, sum, sum+1)</code>
这一行代码， 这样肯定会有不同的 goroutine 同时拿到一个相同的
<code>sum</code> 的旧值，那么在这种情况下，就会导致 <code>CAS</code>
操作失败。 也就是说，将 <code>sum</code> 替换为 <code>sum + 1</code>
的操作可能会失败。</p>
<p>失败意味着什么呢？意味着另外一个协程序先把 <code>sum</code> 的值加 1
了，这个时候其实我们不应该在旧的 <code>sum</code> 上加 1 了，
而是应该在最新的 <code>sum</code> 上加上
1，那我们应该怎么做呢？我们可以在 <code>CAS</code>
操作失败的时候，重新获取 <code>sum</code> 的值， 然后再次尝试
<code>CAS</code> 操作，直到成功为止：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCas</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// cas 失败的时候，重新获取 sum 的值进行计算。</span></span><br><span class="line">			<span class="comment">// cas 成功则返回。</span></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;sum, sum, sum+<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>原子操作是并发编程中非常重要的一个概念，它可以保证并发读写的安全性，同时也能得到更好的性能。</p>
<p>最后，总结一下本文讲到的内容：</p>
<ul>
<li>原子操作是更加底层的操作，它保护的是单个变量，而互斥锁可以保护一个代码片段，它们的使用场景是不一样的。</li>
<li>原子操作需要通过 CPU 指令来实现，而互斥锁是在软件层面实现的。</li>
<li>go 里面的原子操作有以下这些：
<ul>
<li><code>Add</code>：原子增减</li>
<li><code>CompareAndSwap</code>：原子比较并交换</li>
<li><code>Load</code>：原子读取</li>
<li><code>Store</code>：原子写入</li>
<li><code>Swap</code>：原子交换</li>
</ul></li>
<li>go
里面所有类型都能使用原子操作，只是不同类型的原子操作使用的函数不太一样。</li>
<li><code>atomic.Value</code> 可以用来原子操作任意类型的变量。</li>
<li>go 里面有些底层实现也使用了原子操作，比如：
<ul>
<li><code>sync.WaitGroup</code>：使用原子操作来保证计数器和等待者数量的并发读写安全性。</li>
<li><code>sync.Map</code>：<code>entry</code>
结构体中基本所有操作都有原子操作的身影。</li>
</ul></li>
<li>原子操作有失败必然有成功（说的是同一行 <code>CAS</code> 操作），如果
<code>CAS</code> 操作失败了，那么我们可以重新获取旧值，然后再次尝试
<code>CAS</code> 操作，直到成功为止。</li>
</ul>
<p>总的来说，原子操作本身其实没有太复杂的逻辑，我们理解了它的原理之后，就可以很容易的使用它了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2023/03/22/golang/go%20sync.Pool%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/22/golang/go%20sync.Pool%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">go sync.Pool 设计与实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-22 20:28:30" itemprop="dateCreated datePublished" datetime="2023-03-22T20:28:30+08:00">2023-03-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文基于 Go 1.19</p>
</blockquote>
<p><code>Pool</code> 是一组可以安全在多个 <code>goroutine</code>
间共享的临时对象的集合。 存储在 <code>Pool</code>
中的任何项目都可能在任何时候被移除，因此 <code>Pool</code>
不适合保存那些有状态的对象，如数据库连接、TCP 连接等。 <code>Pool</code>
的目的是缓存已分配但未使用的项以供以后使用，从而减少垃圾收集器的压力。
也就是说，它可以轻松构建高效、线程安全的空闲列表，但是，它并不适用于所有空闲列表。</p>
<h2 id="使用实例">使用实例</h2>
<p>下面以几个实际的例子来说明 <code>Pool</code> 的一些使用场景。
下面是两个非常典型的使用场景，但是在实际使用中，对于那些需要频繁创建和销毁的对象的场景，我们都可以考虑使用
<code>Pool</code>。</p>
<h3 id="gin-里面-context-对象使用-pool-保存">gin 里面 Context 对象使用
Pool 保存</h3>
<p>在 <code>gin</code> 的 <code>Engine</code> 结构体中的
<code>ServeHTTP</code> 方法中，可以看到 <code>Context</code> 对象是从
<code>Pool</code> 中获取的。 然后在处理完请求之后，将
<code>Context</code> 对象放回 <code>Pool</code> 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	<span class="comment">// 从 Pool 中获取 Context</span></span><br><span class="line">	c := engine.pool.Get().(*Context)</span><br><span class="line">	<span class="comment">// 重置 writermem</span></span><br><span class="line">	c.writermem.reset(w)</span><br><span class="line">	<span class="comment">// 重置 Request</span></span><br><span class="line">	c.Request = req</span><br><span class="line">	<span class="comment">// 重置其他字段</span></span><br><span class="line">	c.reset()</span><br><span class="line"></span><br><span class="line">	engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 Context 对象放回 Pool</span></span><br><span class="line">	engine.pool.Put(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以去看看 <code>gin</code> 中 <code>Context</code>
对象的定义，我们会发现，它其中有很多字段。
设想一下，如果每一个请求都创建一个 <code>Context</code>
对象，那么每一个请求都要对 <code>Context</code> 进行内存分配，
分配了之后，如果请求结束了，这些申请的内存在后续就要被回收掉（当然，不是马上就回收）。</p>
<p>这样一来，如果待回收的 <code>Context</code>
对象很多，那么垃圾回收器就会被压力很大。</p>
<blockquote>
<p>同样的做法在 <code>echo</code> 这个框架中也有出现。</p>
</blockquote>
<h3 id="fmt-里面的-pp-结构体">fmt 里面的 pp 结构体</h3>
<p>在我们使用 <code>fmt</code> 包来打印的时候（比如，调用
<code>fmt.Fprintf</code>），其实底层是要使用一个名为 <code>pp</code>
的结构体来进行打印的。 如果我们的系统中需要大量地使用 <code>fmt</code>
库来做格式化字符串的操作，如果每次进行格式化操作的时候都
<code>new</code> 一个 <code>pp</code> 对象，
那么也会在某个时刻导致垃圾回收器的压力很大。</p>
<p>所以，<code>fmt</code> 包中使用 <code>pp</code> 的时候，都是从
<code>Pool</code> 中获取的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newPrinter allocates a new pp struct or grabs a cached one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPrinter</span><span class="params">()</span></span> *pp &#123;</span><br><span class="line">	<span class="comment">// 从 Pool 中获取 pp 对象</span></span><br><span class="line">	p := ppFree.Get().(*pp)</span><br><span class="line">	p.panicking = <span class="literal">false</span></span><br><span class="line">	p.erroring = <span class="literal">false</span></span><br><span class="line">	p.wrapErrs = <span class="literal">false</span></span><br><span class="line">	p.fmt.init(&amp;p.buf)</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法是获取 <code>pp</code> 对象的方法。我们在这里没有看到重置
<code>pp</code> 字段的代码，因为这些操作在 <code>pp</code> 的
<code>free</code> 方法中了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free saves used pp structs in ppFree; avoids an allocation per invocation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span></span> free() &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span>(p.buf) &gt; <span class="number">64</span>&lt;&lt;<span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置 p.buf</span></span><br><span class="line">	p.buf = p.buf[:<span class="number">0</span>]</span><br><span class="line">	p.arg = <span class="literal">nil</span></span><br><span class="line">	p.value = reflect.Value&#123;&#125;</span><br><span class="line">	p.wrappedErr = <span class="literal">nil</span></span><br><span class="line">	<span class="comment">// 将 pp 放回 Pool 中</span></span><br><span class="line">	ppFree.Put(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们不能对 <code>sync.Pool</code> 有任何假设，比如，不要想着 Put
进去的对象带了一个状态，然后 Get 出来的时候就能拿到这个状态。
因为这个对象可能在任何时候被清除掉。</p>
</blockquote>
<p>从上面这个例子中，我们可以看到 <code>p.buf = p.buf[:0]</code>
这一行对 <code>buf</code> 进行了重置， 这给我我们的启示是，我们在使用
<code>sync.Pool</code>
的时候，如果我们存取的对象会带有一些不同的字段值，
<strong>那么我们可能需要对这些字段进行重置后再使用</strong>，这样就可以避免
<code>Get</code> 到的对象带有之前的一些状态，
不过重置这些字段的开销相比分配新的内存以及后续
GC，其实开销可以忽略不计。</p>
<h2 id="pool-整体模型">Pool 整体模型</h2>
<p><code>Pool</code> 本质上是一个双端队列，这个队列支持以下操作：</p>
<ul>
<li><code>pushHead</code>：将一个对象放到队列的头部，这也是唯一的入队操作。</li>
<li><code>popHead</code>：从队列的头部取出一个对象。如果取不到则使用
<code>New</code> 方法创建一个新的对象。</li>
<li><code>popTail</code>：从队列的尾部取出一个对象。如果取不到则使用
<code>New</code> 方法创建一个新的对象。</li>
</ul>
<p>可以简单地用下图表示：</p>
<figure>
<img src="/images/go/sync_pool/pool_1.png" alt="pool_1" />
<figcaption aria-hidden="true">pool_1</figcaption>
</figure>
<blockquote>
<p>在阅读本文过程中，想不清楚的时候，回想一下这个模型，可能会有所帮助。</p>
</blockquote>
<p>当然，在实际的实现中，比这个复杂多了，但是这个模型已经足够我们理解
<code>Pool</code> 的工作原理了。</p>
<h3 id="pool-的双端队列是使用数组还是链表">Pool
的双端队列是使用数组还是链表</h3>
<p>我们知道，队列的存储通常有两种方式，一种是数组，一种是链表，两者的优缺点如下：</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 36%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数组</td>
<td>存储空间连续，可以根据下标快速访问</td>
<td>大小固定，扩容成本高</td>
</tr>
<tr class="even">
<td>链表</td>
<td>大小不固定，可以很容易增加新的元素</td>
<td>访问效率不如数组。需要额外的空间来存储前后元素的指针</td>
</tr>
</tbody>
</table>
<p>那么 <code>Pool</code> 里面用的是数组还是链表呢？答案是：<strong>数组
+ 链表</strong>。</p>
<h3 id="pool-为什么要用数组-链表">Pool 为什么要用数组 + 链表</h3>
<p>为了快速访问队列中的元素，使用数组是最好的选择，但是数组的大小是固定的，如果队列中的元素很多，那么数组就会很快被填满。
如果我们还想继续往队列中添加元素，那么就需要对数组进行扩容，这个成本是很高的（因为本来就是需要频繁分配/销毁对象的场景才会使用
<code>Pool</code>）。 同时，我们知道 <code>Pool</code>
设计的目的就是为了减少频繁内存分配带来的性能问题，如果在使用
<code>Pool</code> 的过程中频繁对其进行扩容，那么就违背了
<code>Pool</code> 设计的初衷了。</p>
<p>为了解决数组扩容的问题，我们可以考虑一下使用链表。在我们
<code>Put</code> 的时候往链表的头部添加一个元素，然后 <code>Get</code>
的时候从链表的尾部取出一个元素（还需要移除）。
但是这样我们就需要一个结构体来表示我们的节点了，那么问题来了，我们又需要频繁地分配/销毁这个结构体，这样就又回到了最开始的问题了（频繁创建/销毁对象）。
所以，只使用链表也不是一个好的选择。</p>
<p>所以，<code>Pool</code> 采用了 <strong>数组 + 链表</strong>
的方式来实现双端队列，它们的关系如下：</p>
<ul>
<li>数组：存储队列中的元素，数组的大小是固定的。</li>
<li>链表：当一个数组存储满了之后，就会新建一个数组，然后通过链表将这两个数组串联起来。</li>
</ul>
<p>最终，<code>Pool</code> 的双端队列的结构如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_2.png" alt="pool_2" />
<figcaption aria-hidden="true">pool_2</figcaption>
</figure>
<h3 id="数组如何实现队列">数组如何实现队列</h3>
<p>我们知道，数组的存储空间是固定的一块连续的内存，所以我们可以通过下标来访问数组中的元素。
我们 <code>push</code> 的时候，将 <code>head</code> 下标
<code>+1</code>，然后 <code>pop</code> 的时候，也要修改对应的下标，
但是这样会导致一个问题是，早晚 <code>head</code>
会超出数组的下标范围，但这个时候数组可能还有很多空间， 因为在我们
<code>push</code> 的时候，可能也同时在
<code>pop</code>，所以数组中的空间可能还有很多。</p>
<p>所以，就可以在 <code>head</code> 超出数组下标范围的时候，将
<code>head</code> 对数组长度取模，这样就可以循环使用数组了：</p>
<figure>
<img src="/images/go/sync_pool/pool_3.png" alt="pool_3" />
<figcaption aria-hidden="true">pool_3</figcaption>
</figure>
<p>不过对于这种情况，使用下面的图更加直观：</p>
<figure>
<img src="/images/go/sync_pool/pool_4.png" alt="pool_4" />
<figcaption aria-hidden="true">pool_4</figcaption>
</figure>
<blockquote>
<p><code>Pool</code> 里面是使用 <code>poolDequeue</code>
这个结构体来表示上图这个队列的，本身是一个数组，但是是当作环形队列使用的。</p>
</blockquote>
<h3 id="poolchain-的最终模型">poolChain 的最终模型</h3>
<p><code>poolChain</code> 就是上面说的 <strong>数组 + 链表</strong>
的组合，它的最终模型如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_5.png" alt="pool_5" />
<figcaption aria-hidden="true">pool_5</figcaption>
</figure>
<p>说明：</p>
<ul>
<li><code>poolChain</code> 本身是一个双向链表，每个节点都是一个
<code>poolDequeue</code>，每个节点都有 <code>prev</code> 和
<code>next</code> 指针指向前后节点。上图的 <code>head</code>
是头节点，<code>tail</code> 是尾节点。</li>
<li><code>poolDequeue</code>
是一个数组，它的大小是固定的，但是它是当作环形队列使用的。</li>
<li><code>tail</code> 初始化的时候长度为 8，具体可参考
<code>poolChain</code> 的 <code>pushHead</code> 方法，后面会说到。</li>
<li><code>pushHead</code> 的时候，如果 <code>head</code>
中的环形队列已经满了，那么就会新建一个
<code>poolDequeue</code>，然后将它插入到 <code>head</code>
的前面。（新的 <code>head</code> 节点的大小为前一个 <code>head</code>
节点的两倍）</li>
<li><code>popTail</code>、<code>popHead</code> 的时候，如果
<code>tail</code> 或者 <code>head</code>
中的环形队列（<code>poolDequeue</code>）已经空了，那么就会将它从链表中移除。</li>
</ul>
<h3 id="多个-p-的情况下的-poolchain">多个 P 的情况下的 poolChain</h3>
<blockquote>
<p>这里假设 P 跟我们机器的逻辑处理器的数量一致。（这里涉及到了 goroutine
的调度机制，不了解可以先了解一下再回来看。）</p>
</blockquote>
<p>我们知道，在 go 中，每一个 goroutine 都会绑定一个
P，这样才可以充分利用多核的优势。 设想一下，如果我们有多个 goroutine
同时存储一个 <code>Pool</code>，会出现什么情况呢？
会导致很激烈的数据竞争，虽然没有使用 <code>Mutex</code>
这种相对低效的互斥锁来解决竞争问题，使用的是原子操作，但是也会导致性能下降。</p>
<p>所以，在 <code>Pool</code> 的实现中，会为每一个 P 都创建一个
<code>poolChain</code>，每次存取，先操作本地 P 绑定的
<code>poolChain</code>，这样就可以减少多个 goroutine 同时操作一个
<code>Pool</code> 的竞争问题了。</p>
<p>所以，最终的 <code>Pool</code> 的模型会长成下面这个样子，每个 G
关联了一个 <code>poolChain</code>：</p>
<figure>
<img src="/images/go/sync_pool/pool_6.png" alt="pool_6" />
<figcaption aria-hidden="true">pool_6</figcaption>
</figure>
<blockquote>
<p>注意：这里不是 <code>Pool</code> 实际的样子，只是为了说明
<code>Pool</code> 的实现原理。</p>
</blockquote>
<h3 id="最终实现中的-pool">最终实现中的 <code>Pool</code></h3>
<p>在实际的实现中，其实会跟上一个图有一些差异，可以说复杂很多：</p>
<figure>
<img src="/images/go/sync_pool/pool_7.png" alt="pool_7" />
<figcaption aria-hidden="true">pool_7</figcaption>
</figure>
<p>从上图可以看出，其实每个 P 关联的并不是 <code>poolChain</code>，而是
<code>poolLocal</code>，<code>poolLocal</code> 里面包含了一个
<code>poolLocalInternal</code> 和一个 <code>pad</code>，<code>pad</code>
是为了避免伪共享而添加的。而 <code>poolLocalInternal</code> 就是实际上
<code>Pool</code> 中存储数据的一个结构体。<code>poolLocalInternal</code>
中包含了两个字段，<code>private</code> 和
<code>shared</code>，<code>shared</code> 就是我们上面说的
<code>poolChain</code>，而 <code>private</code> 是一个 <code>any</code>
类型的字段，在我们调用 <code>Pool</code> 的 <code>Put</code>
方法的时候，会先尝试将数据存储到 <code>private</code> 中，如果
<code>private</code> 中已经有数据了，那么就会将数据存储到
<code>shared</code> 中。同样的，在 <code>Get</code> 的时候，也会先从
<code>private</code> 中获取数据，如果 <code>private</code>
中没有数据，那么就会从 <code>shared</code> 中获取数据。</p>
<p>而相应的，<code>Pool</code> 存取数据会变成：</p>
<ul>
<li><code>pushHead</code>：我们调用 <code>Pool</code> 的
<code>Put</code> 方法的时候，只会写入到本地 P 关联的那个
<code>poolLocal</code> 中。</li>
<li><code>popHead</code>：这个方法也只能从本地 P 关联的
<code>poolLocal</code> 中取数据。</li>
<li><code>popTail</code>：这个方法会从本地 P 关联的
<code>poolLocal</code> 中取数据，如果取不到，那么就会从其他 P 关联的
<code>poolLocal</code> 中取数据。</li>
</ul>
<blockquote>
<p>这样就可以减少多个 goroutine 同时操作一个 <code>Pool</code>
的竞争问题了（但是无法避免）。</p>
</blockquote>
<h3 id="pool-模型总结">Pool 模型总结</h3>
<p>最后，我们将这一节的内容总结一下，可以得到下面这个图：</p>
<figure>
<img src="/images/go/sync_pool/pool_8.png" alt="pool_8" />
<figcaption aria-hidden="true">pool_8</figcaption>
</figure>
<p>说明：</p>
<ul>
<li>go 进程内会有多个 P，每个 P 都会关联一个
<code>poolLocal</code>。</li>
<li><code>poolLocal</code> 中包含了一个 <code>poolLocalInternal</code>
和一个 <code>pad</code>，<code>poolLocalInternal</code>
中包含了两个字段，<code>private</code> 和 <code>shared</code>。</li>
<li><code>private</code> 是一个 <code>any</code>
类型的字段，用来存储我们调用 <code>Pool</code> 的 <code>Put</code>
方法的时候传入的数据，<code>Get</code> 的时候如果 <code>private</code>
中有数据，那么就会直接返回 <code>private</code> 中的数据。</li>
<li><code>shared</code> 是一个 <code>poolChain</code>，用来存储我们调用
<code>Pool</code> 的 <code>Put</code>
方法的时候传入的数据，<code>Get</code> 的时候如果当前 P 绑定的
<code>poolLocal</code> 内是空的，那么可以从其他 <code>P</code> 绑定的
<code>shared</code> 的尾部获取。</li>
<li><code>poolChain</code> 是一个双向链表，每个节点都是一个
<code>poolDequeue</code>，每个节点都有 <code>prev</code> 和
<code>next</code> 指针指向前后节点。上图的 <code>head</code>
是头节点，<code>tail</code> 是尾节点。</li>
<li><code>poolDequeue</code>
是一个数组，它的大小是固定的，但是它是当作环形队列使用的。</li>
<li><code>pushHead</code> 的时候，如果 <code>poolChain</code>
的节点满了，那么会新建一个节点，其容量为前一个节点的两倍。</li>
<li><code>poolChain</code>
支持三种操作：<code>pushHead</code>、<code>popHead</code>、<code>popTail</code>。</li>
<li><code>pushHead</code> 会将数据存储到当前 P 关联的
<code>poolChain</code> 的头部。</li>
</ul>
<h2 id="pool-中的结构体">Pool 中的结构体</h2>
<p>在开始分析源码之前，我们先来看一下 <code>Pool</code> 的 UML 图：</p>
<figure>
<img src="/images/go/sync_pool/pool_9.png" alt="pool_9" />
<figcaption aria-hidden="true">pool_9</figcaption>
</figure>
<p>上图中已经包含 <code>Pool</code>
实现的所有关键结构体了，下面我们来分析一下这些结构体的作用。</p>
<h3 id="sync.pool-结构体">sync.Pool 结构体：</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// noCopy 用于防止 Pool 被复制（可以使用 go vet 检测）</span></span><br><span class="line">	noCopy noCopy</span><br><span class="line"></span><br><span class="line">	<span class="comment">// local 的主要作用是，多个 goroutine 同时访问 Pool 时，可以减少竞争，提升性能。</span></span><br><span class="line">	<span class="comment">// 实际类型是 [P]poolLocal。长度是 localSize。</span></span><br><span class="line">	local unsafe.Pointer</span><br><span class="line">	<span class="comment">// []poolLocal 的长度。也就是 local 切片的长度</span></span><br><span class="line">	localSize <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存放的是上一轮 GC 时的 local 字段的值。</span></span><br><span class="line">	victim unsafe.Pointer</span><br><span class="line">	<span class="comment">// victim 数组的长度</span></span><br><span class="line">	victimSize <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新建对象的方法。</span></span><br><span class="line">	<span class="comment">// Get 的时候如果 Pool 中没有对象可用，会调用这个方法来新建一个对象。</span></span><br><span class="line">	New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字段说明：</p>
<ul>
<li><code>local</code>：就是我们上文说到的 <code>poolLocal</code>
类型的切片，长度是 <code>runtime.GOMAXPROCS(0)</code>，也就是当前 P
的数量。之所以使用切片类型是因为我们可以在运行的过程中调整 P
的数量，所以它的长度并不是固定的，如果 P
的数量变了，<code>poolLocal</code> 也会跟着改变。</li>
<li><code>localSize</code>：<code>local</code> 的长度。</li>
<li><code>victim</code>：上一轮 GC 时的 <code>local</code>
字段的值。</li>
<li><code>victimSize</code>：<code>victim</code> 的长度。</li>
<li><code>New</code>：新建对象的方法。</li>
</ul>
<p><code>victim</code> 的作用是在 GC 的时候，将 <code>local</code>
的值赋值给 <code>victim</code>，然后将 <code>local</code> 置为
<code>nil</code>，这样就可以避免在 GC 的时候，<code>local</code>
中的对象被回收掉。 当然，并不是完全不会回收，再经历一次 GC
之后，<code>victim</code>
中的对象就会被回收掉。这样做的好处是，<strong>可以避免 GC 的时候清除
Pool 中的所有对象， 这样在 GC 之后如果需要大量地从 <code>Pool</code>
中获取对象也不至于产生瞬时的性能抖动</strong>。</p>
<p><code>victim cache</code>
是计算机科学中的一个术语，<code>victim cache</code> 是位于 cpu cache
和主存之间的又一级 cache，用于存放由于失效而被丢弃（替换）的那些块。
每当失效发生时，在访问主存之前，victim cache
都会被检查，如果命中，就不会访问主存。</p>
<h4 id="pool-获取对象的流程">Pool 获取对象的流程</h4>
<p>最终，当我们调用 <code>Pool</code> 的 <code>Get</code>
方法的时候，会按下图的流程来获取对象：</p>
<figure>
<img src="/images/go/sync_pool/pool_10.png" alt="pool_10" />
<figcaption aria-hidden="true">pool_10</figcaption>
</figure>
<p>说明：</p>
<ol type="1">
<li>首先会从当前 P 关联的 <code>poolLocal</code> 中的
<code>private</code> 字段中获取对象，如果获取到了，那么直接返回。</li>
<li>如果 <code>private</code> 字段中没有对象，那么会从当前 P 关联的
<code>poolLocal</code> 中的 <code>shared</code>
字段中获取对象，如果获取到了，那么直接返回（这里使用的是
<code>popHead</code> 方法）。</li>
<li>尝试从其他 P 关联的 <code>poolLocal</code> 中的 <code>shared</code>
字段中获取对象，如果获取到了，那么直接返回（这里使用的是
<code>popTail</code> 方法）。</li>
<li>如果其他 P 关联的 <code>poolLocal</code> 中的 <code>shared</code>
字段中也没有对象，那么会从 <code>victim</code>
中获取对象，如果获取到了，那么直接返回。</li>
<li>如果 <code>victim</code> 中也没有对象，那么会调用 <code>New</code>
方法来创建一个新的对象（当然前提是我们创建 <code>Pool</code>
对象的时候设置了 <code>New</code> 字段）。</li>
<li>如果 <code>New</code> 字段也没有设置，那么会返回
<code>nil</code>。</li>
</ol>
<h3 id="poollocal-和-poollocalinternal-结构体">poolLocal 和
poolLocalInternal 结构体：</h3>
<p>在 <code>Pool</code> 中，使用了 <code>poolLocal</code> 和
<code>poolLocalInternal</code> 两个结构体来表示实际存储数据的结构体。
当然我们也可以只使用 <code>poolLocalInternal</code>
这个结构体，但是为了避免伪共享，在 <code>Pool</code> 的实现中， 将
<code>poolLocalInternal</code> 放在了 <code>poolLocal</code>
的第一个字段，然后在 <code>poolLocal</code> 中添加了一个
<code>pad</code> 字段，用来填充 <code>poolLocalInternal</code> 到 cache
line 的大小。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际存储 Pool 的数据的结构体</span></span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// private 用于存储 Pool 的 Put 方法传入的数据。</span></span><br><span class="line">	<span class="comment">// Get 的时候如果 private 不为空，那么直接返回 private 中的数据。</span></span><br><span class="line">	<span class="comment">// 只能被当前 P 使用。</span></span><br><span class="line">	private any</span><br><span class="line">	<span class="comment">// 本地 P 可以pushHead/popHead</span></span><br><span class="line">	<span class="comment">// 任何 P 都可以 popTail。</span></span><br><span class="line">	shared poolChain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pool 中的 local 属性的元素类型。</span></span><br><span class="line"><span class="comment">// Pool 中的 local 是一个元素类型为 poolLocal 的切片，长度为 runtime.GOMAXPROCS(0)。</span></span><br><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">	poolLocalInternal</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pad 用于填充 poolLocalInternal 到 cache line 的大小。</span></span><br><span class="line">	<span class="comment">// 为了避免伪共享，将 poolLocalInternal 放在第一个字段。</span></span><br><span class="line">	pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这里比较关键的地方是 <code>pad</code> 字段的作用，我们知道，CPU
会将内存分成多个 cache line，CPU 从内存中读取数据的时候，
并不是一个字节一个字节地读取，而是一次性读取一个 cache line
的数据。但是如果我们的数据结构中的字段不是按照 cache line
的大小来排列的， 比如跨了两个 cache
line，那么在读取的时候就会产生伪共享，这样就会降低性能。</p>
<figure>
<img src="/images/go/sync_pool/pool_11.png" alt="pool_11" />
<figcaption aria-hidden="true">pool_11</figcaption>
</figure>
<p>伪共享的原因是，数据跨了两个 cache line，那么在读取的时候，就会将两个
cache line 都读取到 CPU 的 cache 中， 这样有可能会导致不同 CPU
在发生数据竞争的时候，会使一些不相关的数据也会失效，从而导致性能下降。
如果对齐到 cache
line，那么从内存读取数据的时候，就不会将一些不相关的数据也读取到 CPU 的
cache 中，从而避免了伪共享。</p>
<h3
id="poolchainpoolchainelt-和-pooldequeue-结构体">poolChain、poolChainElt
和 poolDequeue 结构体</h3>
<p>为什么要把这三个放一起讲呢？因为这三个结构体就是 <code>Pool</code>
中做实际存取数据的结构体，三者作用如下：</p>
<ul>
<li><code>poolChain</code>：<code>poolChain</code>
是一个链表，每个节点都是 <code>poolChainElt</code>。</li>
<li><code>poolChainElt</code>：每个 <code>poolChainElt</code>
中包含了一个
<code>poolDequeue</code>，同时包含了指向前一个节点和后一个节点的指针。</li>
<li><code>poolDequeue</code>：<code>poolDequeue</code>
是一个双端队列（环形队列，使用数组存储），用来存储 <code>Pool</code>
中的数据。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poolChain 是 poolDequeue 的动态大小版本。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这是作为 poolDequeues 的双向链表队列实现的，其中每个 dequeue 都是前一个 dequeue 大小的两倍。</span></span><br><span class="line"><span class="comment">// 一旦 dequeue 填满，就会分配一个新的 dequeue，并且 pushHead 只会 push 到最新的 dequeue。</span></span><br><span class="line"><span class="comment">// pop 可以从头部或者尾部进行，一旦 dequeue 空了，它就会从 poolChain 中删除。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// poolChain 的实现是一个双向链表，每个 poolChainElt 都是一个 poolDequeue。</span></span><br><span class="line"><span class="comment">//（也就是元素是 poolDequeue 的双向链表）</span></span><br><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// head 是要推送到的 poolDequeue。</span></span><br><span class="line">	<span class="comment">// 只能由生产者访问，因此不需要同步。</span></span><br><span class="line">	head *poolChainElt</span><br><span class="line"></span><br><span class="line">	<span class="comment">// tail 是从 poolDequeue 中 pop 的节点。</span></span><br><span class="line">	<span class="comment">// 这是由消费者访问的，因此读取和写入必须是原子的。</span></span><br><span class="line">	tail *poolChainElt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poolChainElt 是 poolChain 中的元素。</span></span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;</span><br><span class="line">	poolDequeue</span><br><span class="line"></span><br><span class="line">	<span class="comment">// next 和 prev 链接到此 poolChain 中相邻的 poolChainElts。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// next 由生产者原子写入，由消费者原子读取。 它只从 nil 过渡到 non-nil。</span></span><br><span class="line">	<span class="comment">// prev 由消费者原子写入，由生产者原子读取。 它只会从 non-nil 过渡到 nil。</span></span><br><span class="line">	next, prev *poolChainElt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poolDequeue 是一个无锁的固定大小的单生产者、多消费者队列。</span></span><br><span class="line"><span class="comment">// 单个生产者既可以从头部 push 也可以从头部 pop，消费者只可以从尾部 pop。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 它有一个附加功能，它会清空不使用的槽，从而避免不必要的对象保留。</span></span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// headTail 将 32 位头索引和 32 位尾索引打包在一起。</span></span><br><span class="line">	<span class="comment">// 两者都是 vals modulo len(vals)-1 的索引。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// tail = 队列尾的索引</span></span><br><span class="line">	<span class="comment">// head = 下一个要填充的插槽的索引</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// [tail, head) 范围内的槽位归消费者所有。</span></span><br><span class="line">	<span class="comment">// 消费者继续拥有此范围之外的槽，直到它清空槽，此时所有权传递给生产者。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 头索引存储在最高有效位中，以便我们可以原子地对它做 add 操作，同时溢出是无害的。</span></span><br><span class="line">	headTail <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// vals 是存储在此 dequeue 中的 interface&#123;&#125; 值的环形缓冲区。它的大小必须是 2 的幂。</span></span><br><span class="line">	<span class="comment">// （队列存储的元素，接口类型）</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 如果插槽为空，则 vals[i].typ 为 nil，否则为非 nil。</span></span><br><span class="line">	<span class="comment">// 一个插槽仍在使用中，直到 *both* 尾部索引超出它并且 typ 已设置为 nil。（both？）</span></span><br><span class="line">	<span class="comment">// 这由消费者原子地设置为 nil，并由生产者原子地读取。</span></span><br><span class="line">	vals []eface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolChain</code> 的结构大概如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_12.png" alt="pool_12" />
<figcaption aria-hidden="true">pool_12</figcaption>
</figure>
<p><code>poolDequeue</code> 的结构大概如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_dequeue.png" alt="pool_dequeue" />
<figcaption aria-hidden="true">pool_dequeue</figcaption>
</figure>
<p>在 <code>poolDequeue</code> 中，<code>headTail</code> 是一个
<code>uint64</code> 类型，它的高 32 位是 <code>head</code>，低 32 位是
<code>tail</code>。 这样一来，这样就可以使用原子操作来保证
<code>head</code> 和 <code>tail</code> 的协程安全了。</p>
<p>在 <code>poolDequeue</code> 中，<code>vals</code>
是一个切片类型，元素类型是 <code>eface</code>，<code>eface</code>
是一个空接口类型，内存布局跟 <code>interface&#123;&#125;</code> 一样，
因此可以看作是一个 <code>interface&#123;&#125;</code>
类型。如果这里看不明白可以看看<a
target="_blank" rel="noopener" href="https://blog.baiguiren.com/2022/12/06/golang/go%20interface%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《go
interface 设计与实现》</a>。</p>
<p>那为什么不直接使用 <code>interface&#123;&#125;</code> 类型呢？因为如果用了
<code>interface&#123;&#125;</code> 类型， 那么 <code>poolDequeue</code>
就无法区分保存的 <code>val</code> 是 <code>nil</code> 还是一个空的槽。
那有什么解决办法呢？在 <code>push</code> 和 <code>pop</code>
的时候使用互斥锁可以解决这个问题（因为目前的实现是使用原子操作的，所以这才需要判断保存的
<code>val</code> 是 <code>nil</code> 还是空槽），
但是这样就会导致性能下降。</p>
<h2 id="pool-源码剖析">Pool 源码剖析</h2>
<blockquote>
<p>在源码剖析的开始部分，不会深入去讲底层的存取细节，我们将其当作一个抽象的队列来看待即可，这样可能会更加便于理解。不过在讲完
<code>Pool</code> 的实现之后，最后还是会展开讲述这个复杂的 "队列"
的那些实现细节。</p>
</blockquote>
<p>接下来，我们来看看 <code>Pool</code> 的源码实现。 <code>Pool</code>
提供的接口非常简单，只有 <code>Put</code>、<code>Get</code>
两个方法，还有一个 <code>New</code> 字段，用来指定 <code>Pool</code>
中的元素是如何创建的：</p>
<ul>
<li><code>New</code> 属性：<code>New</code> 是一个函数，用来创建
<code>Pool</code> 中的元素。</li>
<li><code>Put</code> 方法：<code>Put</code> 方法用来向 <code>Pool</code>
中放入一个元素。</li>
<li><code>Get</code> 方法：<code>Get</code> 方法用来从 <code>Pool</code>
中获取一个元素。</li>
</ul>
<h3 id="get">Get</h3>
<p><code>Get</code> 方法的实现如下：</p>
<p><code>Get</code> 从 <code>Pool</code> 中选择一个任意项，将其从
<code>Pool</code> 中移除，并将其返回给调用者。 <code>Get</code>
可能会选择忽略池并将其视为空的。 调用方不应假定传递给 <code>Put</code>
的值与 <code>Get</code> 返回的值之间存在任何关系。 (<code>Put</code> 和
<code>Get</code> 之间可能会发生 <code>GC</code>，然后 <code>Pool</code>
里面的元素可能会被 <code>GC</code> 回收掉)</p>
<p>如果 <code>Get</code> 否则返回 <code>nil</code> 并且
<code>p.New</code> 不为 <code>nil</code>，则 <code>Get</code> 返回调用
<code>p.New</code> 的结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get 从 Pool 中获取一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() any &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// pin 将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 的本地缓存（poolLocal）和 P 的 ID。</span></span><br><span class="line">	l, pid := p.pin()</span><br><span class="line">	<span class="comment">// 先看 private 是否为 nil，如果不为 nil，就直接返回 private，并将 private 置为 nil。</span></span><br><span class="line">	x := l.private</span><br><span class="line">	l.private = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 尝试从本地 shared 的头部取。</span></span><br><span class="line">		x, _ = l.shared.popHead()</span><br><span class="line">		<span class="keyword">if</span> x == <span class="literal">nil</span> &#123; <span class="comment">// 如果本地 shared 的头部取不到，就从其他 P 的 shared 的尾部取。</span></span><br><span class="line">			x = p.getSlow(pid)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将当前的 goroutine 和 P 解绑，允许被抢占。</span></span><br><span class="line">	runtime_procUnpin()</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 如果 x 为 nil 并且 p.New 不为 nil，则返回 p.New() 的结果。</span></span><br><span class="line">	<span class="comment">// 没有就 New 一个。</span></span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">		x = p.New()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Pool</code> <code>Get</code> 的流程可以总结如下：</p>
<ol type="1">
<li>将当前的 <code>goroutine</code> 和 <code>P</code>
绑定，禁止被抢占，返回当前 <code>P</code>
的本地缓存（<code>poolLocal</code>）和 <code>P</code> 的
<code>ID</code>。</li>
<li>从本地 <code>private</code> 取，如果取不到，就从本地
<code>shared</code> 的头部取，如果取不到，就从其他 <code>P</code> 的
<code>shared</code> 的尾部取。获取到则返回</li>
<li>如果从其他的 <code>P</code> 的 <code>shared</code>
的尾部也获取不到，则从 <code>victim</code> 获取。获取到则返回</li>
<li>将当前的 <code>goroutine</code> 和 <code>P</code>
解绑，允许被抢占。</li>
<li>如果 <code>p.New</code> 不为 <code>nil</code>，则返回
<code>p.New</code> 的结果。</li>
</ol>
<p>再贴一下上面那个图（当然，下图包含了下面的 <code>getSlow</code>
的流程，并不只是 <code>Get</code>）：</p>
<figure>
<img src="/images/go/sync_pool/pool_10.png" alt="pool_10" />
<figcaption aria-hidden="true">pool_10</figcaption>
</figure>
<p>在 <code>Pool</code> 中一个很关键的操作是
<code>pin</code>，它的作用是将当前的 <code>goroutine</code> 和
<code>P</code> 绑定，禁止被抢占。 这样就可以保证在 <code>Get</code> 和
<code>Put</code> 的时候，都可以获取到当前 <code>P</code>
的本地缓存（<code>poolLocal</code>）， 否则，有可能在 <code>Get</code>
和 <code>Put</code> 的时候，<code>P</code> 会被抢占，导致获取到的
<code>poolLocal</code> 不一致，这样 <code>poolLocal</code>
就会失去意义， 不得不再次陷入跟其他 <code>goroutine</code>
竞争的状态，又不得不考虑在如何在不同 <code>goroutine</code>
之间进行同步了。</p>
<p>而绑定了 <code>P</code> 后，在 <code>Get</code> 和 <code>Put</code>
的时候，就可以使用原子操作来代替其他更大粒度的锁了，
但是我们也不必太担心，因为绑定 <code>P</code> 的时间窗口其实很小。</p>
<h3 id="getslow-源码剖析">getSlow 源码剖析</h3>
<p>在 <code>Get</code> 中，如果从 <code>private</code> 和
<code>shared</code> 中都取不到，就会调用 <code>getSlow</code>
方法。它的作用是：</p>
<ol type="1">
<li>尝试从其他 <code>P</code> 的 <code>shared</code> 的尾部取。</li>
<li>尝试从 <code>victim</code> 获取。</li>
</ol>
<p><code>getSlow</code> 的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从其他 P 的 shared 的尾部取。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> getSlow(pid <span class="type">int</span>) any &#123;</span><br><span class="line">	<span class="comment">// 获取 local 的大小和 local。</span></span><br><span class="line">	size := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">	locals := p.local                            <span class="comment">// load-consume</span></span><br><span class="line">	<span class="comment">// 尝试从其他 P 的 shared 的尾部取。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;</span><br><span class="line">		l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="type">int</span>(size)) <span class="comment">// pid+i+1 的用途从下一个 P 开始取。</span></span><br><span class="line">		<span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123; <span class="comment">// 尝试从每一个 P 的 shared 的尾部取，获取到则返回。</span></span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尝试从 victim cache 取。</span></span><br><span class="line">	<span class="comment">// 我们在尝试从所有主缓存中偷取之后执行此操作，</span></span><br><span class="line">	<span class="comment">// 因为我们希望 victim cache 中的对象尽可能地老化。</span></span><br><span class="line">	size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(pid) &gt;= size &#123; <span class="comment">// 如果 pid 大于 size，会发生越界，直接返回 nil。这意味着 gomaxprocs 相比上一次 poolCleanup 的时候变大了。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	locals = p.victim</span><br><span class="line">	l := indexLocal(locals, pid)</span><br><span class="line">	<span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123; <span class="comment">// victim 实际上也是一个 poolLocal 数组，每个 poolLocal 都有一个 private 字段，这个字段就是 victim cache。</span></span><br><span class="line">		l.private = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;</span><br><span class="line">		l := indexLocal(locals, (pid+i)%<span class="type">int</span>(size))</span><br><span class="line">		<span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 victim cache 标记为空，以便将来的 Get 不会再考虑它。</span></span><br><span class="line">	atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pin-源码剖析">pin 源码剖析</h3>
<p><code>pin</code> 方法的实现如下：</p>
<p><code>pin</code> 将当前 <code>goroutine</code> 固定到 <code>P</code>
上，禁用抢占并返回 <code>poolLocal</code> 池中对应的
<code>poolLocal</code>。 调用方必须在完成取值后调用
<code>runtime_procUnpin()</code> 来取消抢占。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前的 goroutine 和 P 绑定，禁止被抢。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// procPin 函数的目的是为了当前 G 绑定到 P 上。</span></span><br><span class="line">	pid := runtime_procPin() <span class="comment">// 返回当前 P 的 id。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 pinSlow 中，我们会存储 local，然后再存储 localSize，</span></span><br><span class="line">	<span class="comment">// 这里我们以相反的顺序读取。 由于我们禁用了抢占，</span></span><br><span class="line">	<span class="comment">// 因此 GC 不能在两者之间发生。</span></span><br><span class="line">	s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">	l := p.local                              <span class="comment">// load-consume</span></span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;                     <span class="comment">// pid &lt; s，说明当前 P 已经初始化过了。</span></span><br><span class="line">		<span class="keyword">return</span> indexLocal(l, pid), pid <span class="comment">// 返回当前 P 的 poolLocal。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p.pinSlow() <span class="comment">// 如果当前 P 没有初始化过，那么就调用 pinSlow()。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 在互斥锁下重试。</span></span><br><span class="line">	<span class="comment">// 在固定时无法锁定互斥锁。</span></span><br><span class="line">	runtime_procUnpin()       <span class="comment">// 解除当前 P 的绑定。</span></span><br><span class="line">	allPoolsMu.Lock()         <span class="comment">// 加全局锁。</span></span><br><span class="line">	<span class="keyword">defer</span> allPoolsMu.Unlock() <span class="comment">// 解锁。</span></span><br><span class="line">	pid := runtime_procPin()  <span class="comment">// 重新绑定当前 P。</span></span><br><span class="line">	<span class="comment">// 在固定时不会调用 poolCleanup。（无法被抢占，GC 不会发生）</span></span><br><span class="line">	s := p.localSize</span><br><span class="line">	l := p.local</span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123; <span class="comment">// 这其实是一个 double-checking，如果在加锁期间，其他 goroutine 已经初始化过了，就直接返回。</span></span><br><span class="line">		<span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// p.local == nil 说明 pool 还没有初始化过。</span></span><br><span class="line">	<span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123; <span class="comment">// 如果当前 P 没有初始化过，那么就将当前 P 添加到 allPools 中。</span></span><br><span class="line">		allPools = <span class="built_in">append</span>(allPools, p)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当 local 数组为空，或者和当前的 runtime.GOMAXPROCS 不一致时，</span></span><br><span class="line">	<span class="comment">// 将触发重新创建 local 数组，以和 P 的个数保持一致。</span></span><br><span class="line">	<span class="comment">// 如果在 GC 之间更改了 GOMAXPROCS，我们将重新分配数组并丢弃旧数组。</span></span><br><span class="line">	size := runtime.GOMAXPROCS(<span class="number">0</span>)                            <span class="comment">// 获取当前 GOMAXPROCS（也就是 P 的个数）</span></span><br><span class="line">	local := <span class="built_in">make</span>([]poolLocal, size)                         <span class="comment">// 创建一个 poolLocal 数组</span></span><br><span class="line">	atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release // 将当前 P 的 poolLocal 添加到 p.local 中</span></span><br><span class="line">	runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release // 将当前 P 的 poolLocal 添加到 p.localSize 中</span></span><br><span class="line">	<span class="keyword">return</span> &amp;local[pid], pid                                  <span class="comment">// 返回当前 P 关联的 poolLocal，以及当前 P 的 id。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>pinSlow</code> 中比较关键的操作是，它会初始化当前
<code>P</code> 关联的 <code>poolLocal</code>，并将其添加到
<code>allPools</code> 中。 关于 <code>allPools</code>
的作用，可以看下一小节。</p>
<p><code>pinSlow</code> 的流程： 1. 解除当前 <code>P</code> 的绑定。 2.
加全局 <code>Pool</code> 的锁。 3. 重新绑定当前 <code>P</code>。 4.
如果当前 <code>P</code> 的 <code>id</code> 小于
<code>localSize</code>，那么就返回当前 <code>P</code> 的
<code>poolLocal</code>。（典型的 <code>double-checking</code>） 5. 如果
<code>local</code> 还没初始化，那么将当前 <code>P</code> 的
<code>poolLocal</code> 添加到 <code>allPools</code> 中。 6. 初始化
<code>local</code>。最后返回当前 <code>P</code> 的
<code>poolLocal</code>。</p>
<p>对于 <code>local</code>
的初始化，我们可以参考一下下图（我们需要知道的是，切片的底层结构体的第一个字段是一个数组）:</p>
<figure>
<img src="/images/go/sync_pool/pool_13.png" alt="pool_13" />
<figcaption aria-hidden="true">pool_13</figcaption>
</figure>
<p><code>&amp;local[0]</code> 是 <code>[]poolLocal</code>
的首地址，<code>unsafe.Pointer(&amp;local[0])</code> 就是
<code>poolLocal</code> 数组的首地址。</p>
<h4 id="indexlocal-源码剖析">indexLocal 源码剖析</h4>
<p>我们在上面的代码中还可以看到一个 <code>indexLocal</code>
函数，它的作用是返回 <code>poolLocal</code> 数组中的第 <code>i</code>
个元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// l 指向了 poolLocal 数组的首地址，i 是数组的索引。</span></span><br><span class="line"><span class="comment">// 返回了数组中第 i 个元素，其类型是 poolLocal。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexLocal</span><span class="params">(l unsafe.Pointer, i <span class="type">int</span>)</span></span> *poolLocal &#123;</span><br><span class="line">	lp := unsafe.Pointer(<span class="type">uintptr</span>(l) + <span class="type">uintptr</span>(i)*unsafe.Sizeof(poolLocal&#123;&#125;))</span><br><span class="line">	<span class="keyword">return</span> (*poolLocal)(lp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前在看 <code>Pool</code> 结构体的时候，看到过
<code>local</code> 字段，它的类型是
<code>unsafe.Pointer</code>，也就是一个指针。 然后我们再结合一下
<code>indexLocal</code> 的实现，就可以知道 <code>local</code>
字段指向的是一个 <code>poolLocal</code> 数组了。 其中 <code>l</code> 是
<code>poolLocal</code> 数组的首地址，<code>i</code>
是数组的索引，<code>unsafe.Sizeof(poolLocal&#123;&#125;)</code> 是
<code>poolLocal</code> 的大小。</p>
<p>这一小节没看懂可以参考一下我写的另外一篇文章 <a
target="_blank" rel="noopener" href="https://blog.baiguiren.com/2022/11/23/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20unsafe/">《深入理解
go unsafe》</a>。</p>
<h3 id="allpools-的作用">allPools 的作用</h3>
<p><code>allPools</code> 的目的是在 <code>GC</code> 的时候，遍历所有的
<code>Pool</code> 对象，将其中的 <code>victim</code> 替换为
<code>local</code>，然后将 <code>local</code> 设置为 <code>nil</code>。
这样后续的 <code>Get</code> 操作在 <code>local</code>
获取不到的时候，可以从 <code>victim</code> 中获取。一定程度上减少了
<code>GC</code> 后的性能抖动。</p>
<p>在 <code>Pool</code> 中，还定义了下面几个全局变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 保护 allPools 和 oldPools 的互斥锁。</span></span><br><span class="line">	allPoolsMu Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allPools 是所有非空 primary cache 的 pool 的集合。</span></span><br><span class="line">	<span class="comment">// 该集合由 allPoolsMu 和 pinning 保护，或者 STW 保护。</span></span><br><span class="line">	allPools []*Pool</span><br><span class="line"></span><br><span class="line">	<span class="comment">// oldPools 是所有可能非空 victim cache 的 pool 的集合。</span></span><br><span class="line">	oldPools []*Pool</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果我们第一次看这些变量，可能会有点懵，不知道它们的作用是什么。
我们可以再结合一下 <code>poolCleanup</code>
函数的实现，就可以知道它们的作用了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在垃圾收集开始时，这个函数会被调用。</span></span><br><span class="line">	<span class="comment">// 它不能分配并且可能不应该调用任何运行时函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 allPools 中删除 victim 缓存。</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;</span><br><span class="line">		p.victim = <span class="literal">nil</span> <span class="comment">// 作用是让 GC 可以回收 victim 缓存中的对象。</span></span><br><span class="line">		p.victimSize = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 primary 缓存移动到 victim 缓存。</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">		p.victim = p.local</span><br><span class="line">		p.victimSize = p.localSize</span><br><span class="line">		p.local = <span class="literal">nil</span></span><br><span class="line">		p.localSize = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具有非空主缓存的池现在具有非空 victim 缓存，并且没有池具有 primary 缓存。</span></span><br><span class="line">	oldPools, allPools = allPools, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolCleanup</code> 这个函数会在 <code>GC</code>
开始的时候被调用，它的作用是将 <code>local</code> 移动到
<code>victim</code> 中。 同时，将 <code>victim</code> 置为
<code>nil</code>，这样 <code>GC</code> 就可以回收 <code>victim</code>
中的对象了，也就是说要经历两轮 <code>GC</code> <code>local</code>
才会真正地被回收。 也就意味着，<code>GC</code>
的时候，<code>local</code> 其实并没有被回收，而是被移动到了
<code>victim</code> 中。</p>
<p><code>poolCleanup</code> 可以用下图表示，实际上就是使用
<code>local</code> 和 <code>localSize</code> 覆盖 <code>victim</code> 和
<code>victimSize</code>：</p>
<figure>
<img src="/images/go/sync_pool/pool_14.png" alt="pool_14" />
<figcaption aria-hidden="true">pool_14</figcaption>
</figure>
<h3 id="put">Put</h3>
<p><code>Put</code> 的实现比较简单，就是将对象放到 <code>local</code>
中，不需要 <code>Get</code> 那种操作其他 <code>P</code> 绑定的
<code>poolLocal</code> 的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Put 将 x 添加到 Pool 中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x any) &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 获取 poolLocal</span></span><br><span class="line">	l, _ := p.pin() <span class="comment">// 将当前 goroutine 与 P 绑定。获取当前 P 关联的 poolLocal，以及当前 P 的 id。</span></span><br><span class="line">	<span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123; <span class="comment">// 优先放入 private</span></span><br><span class="line">		l.private = x</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 private 已经有值了，就放入 shared</span></span><br><span class="line">		l.shared.pushHead(x) <span class="comment">// 这部分其他 P 也是可以访问的。</span></span><br><span class="line">	&#125;</span><br><span class="line">	runtime_procUnpin() <span class="comment">// 解除当前 P 的绑定。</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Pool</code> <code>Put</code> 的流程： 1. 如果 <code>Put</code>
的值是 <code>nil</code>，则直接返回。 2. 将当前的 <code>goroutine</code>
和 <code>P</code> 绑定，禁止被抢占，返回当前 <code>P</code>
的本地缓存（<code>poolLocal</code>）和 <code>P</code> 的
<code>ID</code>。 3. 如果本地 <code>private</code> 为空，则将
<code>x</code> 放入本地 <code>private</code>。 4. 如果本地
<code>private</code> 不为空，则将 <code>x</code> 放入本地
<code>shared</code> 的头部。 5. 将当前的 <code>goroutine</code> 和
<code>P</code> 解绑，允许被抢占。</p>
<p>这里面的 <code>pin</code> 和
<code>runtime_procUnpin</code>，我们在前文已经介绍过了，这里就不再赘述了。</p>
<h3 id="new">New</h3>
<p>这里说的 <code>New</code> 是 <code>sync.Pool</code> 中的
<code>New</code> 字段，在我们尝试了所有方法都获取不到对象的时候， 会判断
<code>Pool</code> 的 <code>New</code> 属性是否为
<code>nil</code>，如果不为 <code>nil</code>，则会调用 <code>New</code>
方法，创建一个新的对象。</p>
<h2 id="poolchain-和-pooldequeue-源码剖析">poolChain 和 poolDequeue
源码剖析</h2>
<p><code>poolChain</code> 是一个双向链表，它的每一个节点的元素是
<code>poolDequeue</code>。</p>
<p>在上文中，对于 <code>Get</code> 和 <code>Put</code>
的细节，还没有具体展开，因为不了解这些细节也不影响我们理解
<code>Pool</code> 的整体流程。 现在是时候来看看 <code>poolChain</code>
和 <code>poolDequeue</code> 这两个结构体的实现了，会结合起来一起看。</p>
<p><code>poolChain</code> 和 <code>poolDequeue</code>
里面都提供了以下三个方法：</p>
<ul>
<li><code>pushHead</code>：将对象放到队列的头部。</li>
<li><code>popHead</code>：从队列的头部取出一个对象。</li>
<li><code>popTail</code>：从队列的尾部取出一个对象。</li>
</ul>
<p>不一样的是，<code>poolChain</code>
里面的方法会处理链表节点的创建和销毁，而 <code>poolDequeue</code>
里面的方法才是实际从队列存取对象的方法。</p>
<h3 id="pushhead">pushHead</h3>
<p><code>poolChain</code> 的 <code>pushHead</code> 方法的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个元素到队列头部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> pushHead(val any) &#123;</span><br><span class="line">	<span class="comment">// 链表头</span></span><br><span class="line">	d := c.head</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123; <span class="comment">// 链表为空</span></span><br><span class="line">		<span class="comment">// 初始化链表。</span></span><br><span class="line">		<span class="comment">// 新建 poolChainElt，然后 c 的 head 和 tail 都指向这个新建的元素。</span></span><br><span class="line">		<span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// 初始化大小为 8</span></span><br><span class="line">		<span class="comment">// 新建一个节点，类型为 poolChainElt</span></span><br><span class="line">		d = <span class="built_in">new</span>(poolChainElt)</span><br><span class="line">		d.vals = <span class="built_in">make</span>([]eface, initSize)</span><br><span class="line">		<span class="comment">// 将 c 的 head 和 tail 都指向这个新建的元素</span></span><br><span class="line">		c.head = d</span><br><span class="line">		<span class="comment">// 使用原子操作保存 c.tail，因为其他 goroutine 也可能会修改 c.tail。</span></span><br><span class="line">		storePoolChainElt(&amp;c.tail, d)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// poolQueue 还没满的时候可以成功 push，pushHead 会返回 true。</span></span><br><span class="line">	<span class="comment">// poolQueue 满的时候 pushHead 返回 false。</span></span><br><span class="line">	<span class="keyword">if</span> d.pushHead(val) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前 dequeue 已满。分配一个两倍大小的新 dequeue。</span></span><br><span class="line">	newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> newSize &gt;= dequeueLimit &#123; <span class="comment">// 限制单个 dequeue 的最大大小</span></span><br><span class="line">		newSize = dequeueLimit</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新建 poolChainElt，然后 c 的 head 指向这个新建的元素。</span></span><br><span class="line">	<span class="comment">// 同时，d 的 next 指向这个新建的元素。</span></span><br><span class="line">	d2 := &amp;poolChainElt&#123;prev: d&#125; <span class="comment">// 因为是加到队列头，所以 prev 指向 d</span></span><br><span class="line">	d2.vals = <span class="built_in">make</span>([]eface, newSize)</span><br><span class="line">	c.head = d2</span><br><span class="line">	storePoolChainElt(&amp;d.next, d2)</span><br><span class="line">	d2.pushHead(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolChain</code> 的 <code>pushHead</code> 方法的流程：</p>
<ol type="1">
<li>如果链表为空，那么就初始化链表。</li>
<li>如果链表不为空，那么就尝试 <code>pushHead</code>。</li>
<li>如果 <code>pushHead</code> 失败，那么就分配一个两倍大小的新
<code>dequeue</code>。</li>
<li>然后把新 <code>dequeue</code> 放到链表头部。（<code>push</code>
的时候已经锁定了 <code>goroutine</code> 在 <code>P</code>
上，所以这一步是没有并发问题的）</li>
</ol>
<p>在 <code>poolChain</code> 的 <code>pushHead</code>
方法中，唯一需要特别注意的是
<code>storePoolChainElt(&amp;c.tail, d)</code> 这一行代码。 这里使用了
<code>storePoolChainElt</code> 方法，而不是直接使用
<code>c.tail = d</code>。 这是因为 <code>c.tail</code> 是会和其他
<code>goroutine</code> 存在竞争的（其他 <code>goroutine</code>
获取对象的时候可能会修改
<code>tail</code>），因此不能直接赋值，而是使用了原子操作。</p>
<p><code>poolChain</code> 的 <code>pushHead</code>
方法的流程图如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_15.png" alt="pool_15" />
<figcaption aria-hidden="true">pool_15</figcaption>
</figure>
<blockquote>
<p>队列头来说，<code>prev</code> 实际上指向的是 <code>head</code>
的下一个元素，但是又不能叫 <code>next</code>，因为 <code>next</code>
被用来表示 <code>tail</code> 的下一个元素，所以就叫了
<code>prev</code>。我们需要知道 <code>prev</code>、<code>next</code>
本质上都是指向了下一个元素，就看你是从队列头还是队列尾来查找。</p>
</blockquote>
<p>在 <code>poolChain</code> 中，其实实际存储对象的时候并不是在
<code>poolChain</code>，而是在 <code>poolChain</code> 的每一个节点中的
<code>poolDequeue</code> 中。 所以我们再来看看 <code>poolDequeue</code>
中的 <code>pushHead</code> 实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pushHead 在队列的头部添加 val。</span></span><br><span class="line"><span class="comment">// 如果队列已满，则返回 false。</span></span><br><span class="line"><span class="comment">// 它只能由单个生产者调用。（也就是当前 goroutine 绑定的 P）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意：head 指向的是下一个要插入的元素的位置，所以插入的时候，先将 head 指向的位置设置为 val，然后 head++。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pushHead(val any) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 读取 head 和 tail 的值。</span></span><br><span class="line">	ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">	head, tail := d.unpack(ptrs)</span><br><span class="line">	<span class="keyword">if</span> (tail+<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123; <span class="comment">// 队列满了</span></span><br><span class="line">		<span class="comment">// 不能直接 tail == head，因为初始化的时候，head 和 tail 都是 0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 取模意味着，当 head 超过 len(d.vals) 时，会从头开始。也就是一个环。</span></span><br><span class="line">	slot := &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)] <span class="comment">// 获取 head 对应的槽位。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// push 只有当前协程能 push，所以不需要加锁。</span></span><br><span class="line">	<span class="comment">// 但是 popTail 可能会在另一个协程中执行，所以需要判断当前的槽位是否被 popTail 释放了。</span></span><br><span class="line">	<span class="comment">// 因为 popTail 的操作是先 cas 修改 headTail，然后再获取 slot 的值，最后才将 slot 置 0 的。</span></span><br><span class="line">	<span class="comment">// 如果修改了 headTail 之后还没有来得及将 slot 置 0，那么这里就会判断出槽位还没有被释放。</span></span><br><span class="line">	typ := atomic.LoadPointer(&amp;slot.typ) <span class="comment">// 获取槽位的类型</span></span><br><span class="line">	<span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;                      <span class="comment">// 槽位不为空</span></span><br><span class="line">		<span class="comment">// 队列依然是满的</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 typ 已经是 nil，那么这里后续的操作是安全的。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> val == <span class="literal">nil</span> &#123; <span class="comment">// put 进来的值是 nil，使用 dequeueNil 代替</span></span><br><span class="line">		val = dequeueNil(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 val 赋值给槽位</span></span><br><span class="line">	*(*any)(unsafe.Pointer(slot)) = val</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加 head。为什么是 1&lt;&lt;dequeueBits 呢？</span></span><br><span class="line">	<span class="comment">// 因为 head 是高 32 位，所以要左移 32 位</span></span><br><span class="line">	<span class="comment">// 本质上是：head = head + 1</span></span><br><span class="line">	atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolDequeue</code> 的 <code>pushHead</code> 方法的流程：</p>
<p><code>pushHead</code> 的处理流程： 1.
判断队列是否已满，如果已满则返回 <code>false</code>。 2. 获取下一个
<code>push</code> 的位置，先判断这个位置是否可用，如果不可用则返回
<code>false</code>。（可能和 <code>popTail</code> 冲突，如果
<code>popTail</code> 没来得及将其中的值取出来，那么这个槽就还不能使用）
3. 如果可用，则将值放入这个位置，然后将 <code>head</code> 指针加
<code>1</code>。</p>
<p>在 <code>poolDequeue</code>
中，我们看到有一行代码比较奇怪：<code>atomic.LoadUint64(&amp;d.headTail)</code>，这是为了可以原子操作存取
<code>head</code> 和 <code>tail</code>
两个值。这样就可以避免锁的使用了。</p>
<h3 id="pophead">popHead</h3>
<p><code>poolChain</code> 的 <code>popHead</code> 方法的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// popHead 会从链表头部 pop 出一个元素。</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 1. any：pop 出的元素。</span></span><br><span class="line"><span class="comment">// 2. bool：是否成功 pop 出元素。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popHead() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">	d := c.head</span><br><span class="line">	<span class="comment">// d == nil 的情况：</span></span><br><span class="line">	<span class="comment">// 1. 链表为空。</span></span><br><span class="line">	<span class="comment">// 2. 链表只有一个元素，且这个元素已经 pop 完了。（被其他协程 pop 了）</span></span><br><span class="line">	<span class="keyword">for</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 这是因为，在我们拿到 d 之后，还没来得及 pop 的话，其他协程可能已经 pop 了。</span></span><br><span class="line">		<span class="comment">// 所以需要 for 循环。典型的无锁编程。</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// poolQueue 还没空的时候可以成功 pop，popHead 会返回 true。</span></span><br><span class="line">		<span class="keyword">if</span> val, ok := d.popHead(); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> val, ok</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 之前的 dequeue 中可能仍有未消费的元素，因此尝试后退。</span></span><br><span class="line">		d = loadPoolChainElt(&amp;d.prev) <span class="comment">// 获取下一个 poolChainElt</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>prev 虽然从命名上看是前一个，但是实际上是下一个节点。从 head
开始遍历的话，prev 就是下一个节点，从 tail 开始遍历的话，next
就是下一个节点。</p>
</blockquote>
<p><code>poolChain</code> 的 <code>popHead</code> 的处理流程：</p>
<ol type="1">
<li>如果链表为空，那么就返回 <code>false</code>。</li>
<li>如果链表不为空，那么就尝试 <code>popHead</code>。</li>
<li>如果 <code>popHead</code> 失败，那么就尝试从链表下一个 dequeue
<code>popHead</code>。（循环直到最后一个
<code>poolChainElt</code>）</li>
</ol>
<p><code>poolChain</code> 的 <code>popHead</code> 方法的流程图如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_16.png" alt="pool_16" />
<figcaption aria-hidden="true">pool_16</figcaption>
</figure>
<p>在 <code>poolChain</code> 中，实际上调用的是 <code>poolDequeue</code>
的 <code>popHead</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// popHead 删除并返回队列头部的元素。</span></span><br><span class="line"><span class="comment">// 如果队列为空，则返回 false。</span></span><br><span class="line"><span class="comment">// 它只能由单个生产者调用。（也就是当前 goroutine 绑定的 P）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popHead() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// slot 用来保存从队列头部取出的值</span></span><br><span class="line">	<span class="keyword">var</span> slot *eface</span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">// 获取不到槽会继续循环，直到获取到槽或者发现队列为空为止。</span></span><br><span class="line">		ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">		head, tail := d.unpack(ptrs)</span><br><span class="line">		<span class="keyword">if</span> tail == head &#123; <span class="comment">// 队列为空</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 先将 head 减 1，然后再获取槽位。</span></span><br><span class="line">		head--</span><br><span class="line">		ptrs2 := d.pack(head, tail)</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line">			<span class="comment">// 成功获取到槽</span></span><br><span class="line">			slot = &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成功获取到 slot，将 slot 的值取出来</span></span><br><span class="line">	<span class="comment">// head - 1 了，说明这个槽是可以被安全使用的，所以不需要加锁。</span></span><br><span class="line">	<span class="comment">// 因为 popTail 不会影响到 head，所以不会影响到这里。</span></span><br><span class="line">	<span class="comment">// 另外，pushHead 也没有影响，因为在实际使用中，只有一个协程会 pushHead。</span></span><br><span class="line"></span><br><span class="line">	val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line">	<span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">		val = nils</span><br><span class="line">	&#125;</span><br><span class="line">	*slot = eface&#123;&#125; <span class="comment">// 将 slot 置 0</span></span><br><span class="line">	<span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolDequeue</code> 的 <code>popHead</code> 的处理流程：</p>
<ol type="1">
<li>判断队列是否为空，如果为空则返回 <code>false</code>。</li>
<li>尝试将 <code>head</code> 指针减
<code>1</code>，如果失败则进行下一轮尝试（自旋，for +
原子操作是无锁编程中很常见的写法）。</li>
<li>将 <code>head</code> 指针对应的槽位的值取出来，然后将槽位置为
<code>nil</code>。</li>
</ol>
<h3 id="poptail">popTail</h3>
<p><code>poolChain</code> 的 <code>popTail</code> 方法的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从队列尾取出一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popTail() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// 获取链表尾部的 poolChainElt</span></span><br><span class="line">	<span class="comment">// 如果链表为空，返回 nil，false</span></span><br><span class="line">	d := loadPoolChainElt(&amp;c.tail)</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 在我们 popTail 之前获取 next 指针很重要。</span></span><br><span class="line">		<span class="comment">// 一般来说，d 可能暂时为空，但如果 next 在 pop 之前为非 nil，</span></span><br><span class="line">		<span class="comment">// 并且 pop 失败，则 d 永久为空，这是唯一可以安全地将 d 从链中删除的条件。</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 解析：next 非 nil，但是 pop 失败：d 肯定是空的了，这个时候我们可以安全地将 d 从链表中删除。</span></span><br><span class="line">		d2 := loadPoolChainElt(&amp;d.next)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// poolQueue 还没空的时候可以成功 pop，popTail 会返回 true。</span></span><br><span class="line">		<span class="keyword">if</span> val, ok := d.popTail(); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> val, ok</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 队列已经空了</span></span><br><span class="line">		<span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// d 是唯一的 dequeue。它现在是空的，但以后可能会有新的元素 push 进来。</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 链表的尾部已经被消费完了，所以转到下一个 dequeue。</span></span><br><span class="line">		<span class="comment">// 尝试从链表中删除它，这样下一次 pop 就不必再次查看空的 dequeue。</span></span><br><span class="line">		<span class="comment">// （本质：移除空的 tail 元素）</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 开始处理 d2，d2 是 d 的下一个 dequeue。（开始尝试从 d2 中 pop）</span></span><br><span class="line">		<span class="comment">// cas：c.tail 由 d 变为 d2。</span></span><br><span class="line">		<span class="comment">// 如果 cas 成功，说明 d2 是最新的 tail，d 可以被移除。</span></span><br><span class="line">		<span class="comment">// d2 的 prev 指针设置为 nil，这样 gc 可以回收 d。（d2 没有下一个元素了）</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// c.tail(d) 指向下一个 poolChainElt</span></span><br><span class="line">		<span class="comment">// 同时下一个 poolChainElt 的 prev 指针(d)设置为 nil。</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;</span><br><span class="line">			<span class="comment">// 我们赢得了竞争。清除 prev 指针，以便垃圾收集器可以收集空的 dequeue，</span></span><br><span class="line">			<span class="comment">// 以便 popHead 的时候不做多余的查找操作。</span></span><br><span class="line">			storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// d 指向 d2，继续处理下一个 dequeue</span></span><br><span class="line">		d = d2</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolChain</code> 中 <code>popTail</code> 的处理流程：</p>
<ol type="1">
<li>如果链表为空，那么就返回 <code>false</code>。</li>
<li>如果链表不为空，那么就尝试 <code>popTail</code>。</li>
<li>如果 <code>popTail</code> 失败，那么就尝试从链表上一个 dequeue
<code>popTail</code>。（循环直到第一个 <code>poolChainElt</code>）</li>
</ol>
<p><code>poolChain</code> 的 <code>popTail</code> 方法的流程图如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_17.png" alt="pool_17" />
<figcaption aria-hidden="true">pool_17</figcaption>
</figure>
<p>在 <code>popTail</code> 的时候，如果发现 <code>poolChainElt</code>
已经为空了，那么就会从链表中移除它：</p>
<figure>
<img src="/images/go/sync_pool/pool_18.png" alt="pool_18" />
<figcaption aria-hidden="true">pool_18</figcaption>
</figure>
<p><code>poolDequeue</code> 的 <code>popTail</code> 方法的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// popHead 和 popTail 都有取值，然后将槽置空的过程，但是它们的实现是不一样的。</span></span><br><span class="line"><span class="comment">// 在 popHead 中，是直接将槽的值设置为 eface&#123;&#125;，而在 popTail 中，</span></span><br><span class="line"><span class="comment">// 先将 val 设置为 nil，然后将 typ 通过原子操作设置为 nil。</span></span><br><span class="line"><span class="comment">// 这样在 pushHead 的时候就可以安全操作了，只要先使用原子操作判断 typ 是否为 nil 就可以了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// popTail removes and returns the element at the tail of the queue.</span></span><br><span class="line"><span class="comment">// It returns false if the queue is empty. It may be called by any</span></span><br><span class="line"><span class="comment">// number of consumers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// popTail 删除并返回队列尾部的元素。</span></span><br><span class="line"><span class="comment">// 如果队列为空，则返回 false。</span></span><br><span class="line"><span class="comment">// 它可以被任意数量的消费者调用。（如何保证并发安全？原子操作）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// slot 用来保存从队列尾取出来的值</span></span><br><span class="line">	<span class="keyword">var</span> slot *eface</span><br><span class="line">	<span class="comment">// 获取队列尾部的值</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">		head, tail := d.unpack(ptrs)</span><br><span class="line">		<span class="keyword">if</span> tail == head &#123;</span><br><span class="line">			<span class="comment">// Queue is empty.</span></span><br><span class="line">			<span class="comment">// 队列为空，直接返回</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Confirm head and tail (for our speculative check</span></span><br><span class="line">		<span class="comment">// above) and increment tail. If this succeeds, then</span></span><br><span class="line">		<span class="comment">// we own the slot at tail.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 确认 head 和 tail（对于我们上面的推测性检查）并增加 tail。</span></span><br><span class="line">		<span class="comment">// 如果成功，那么我们就拥有 tail 的插槽。</span></span><br><span class="line">		ptrs2 := d.pack(head, tail+<span class="number">1</span>) <span class="comment">// 新的 headTail</span></span><br><span class="line">		<span class="comment">// 如果返回 false，说明从 Load 到 CompareAndSwap 期间，有其他 goroutine 修改了 headTail。</span></span><br><span class="line">		<span class="comment">// 则需要重新 Load，再次尝试（再次执行 for 循环）。</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line">			<span class="comment">// Success.</span></span><br><span class="line">			slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成功获取到 slot，将 slot 的值取出来</span></span><br><span class="line">	<span class="comment">// 问题来了：</span></span><br><span class="line">	<span class="comment">// 在这里 cas 成功的时候，这个 slot 实际上可能是还没有释放的，在这个时候，pushHead 其实不能写入到这个 slot 中。</span></span><br><span class="line">	<span class="comment">// 因此，我们可以在 pushHead 的代码中看到，会先判断 slot.typ 是否为 nil，如果不为 nil，说明 slot 还没有被释放，那么就直接 return 了。</span></span><br><span class="line">	<span class="comment">// 这种情况发生在 poolDequeue 满了的时候。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// We now own slot.</span></span><br><span class="line">	val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line">	<span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123; <span class="comment">// 这是什么情况？非空，但是值等于 dequeueNil(nil) ？</span></span><br><span class="line">		val = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取出值之后，将 slot 置 0。</span></span><br><span class="line">	<span class="comment">// 在 poolDequeue 中，值是允许为 nil 的，但是 pool 的 Put 中判断值为 nil 的时候就直接 return 了。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 告诉 pushHead 我们已经操作完这个插槽。</span></span><br><span class="line">	<span class="comment">// 将插槽归零也很重要，这样我们就不会留下可能使该对象比必要时间更长的引用。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 我们首先写入 val，然后通过原子写入 typ 来发布我们已完成此插槽。</span></span><br><span class="line">	slot.val = <span class="literal">nil</span></span><br><span class="line">	atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>) <span class="comment">// 为什么要用原子操作？因为 pushHead 也会读取这个值，所以需要保证读取的是最新的值。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此时 pushHead 可以操作这个槽了。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolDequeue</code> 的 <code>popTail</code> 的处理流程：</p>
<ol type="1">
<li>判断队列是否为空，如果为空则返回 <code>false</code>。</li>
<li>尝试将 <code>tail</code> 指针加
<code>1</code>，如果失败则进行下一轮尝试（自旋）。</li>
<li>将 <code>tail</code> 指针对应的槽位的值取出来，然后将槽位置为
<code>nil</code>。</li>
</ol>
<h2 id="sync.pool-设计要点">sync.Pool 设计要点</h2>
<p>在 <code>sync.Pool</code>
中，我们可以看到它有许许多多的编程技巧，为了实现一个高性能的
<code>Pool</code> 要做的东西是非常复杂的，
但是对于我们而言，我们只会用到它暴露出来的两个非常简单的接口
<code>Put</code>、<code>Get</code>，这其实也算是 Go
语言的一种设计哲学吧，
把复杂留给自己，把简单留给用户。但是，我们还是要知道它的实现原理，这样才能更好的使用它。</p>
<p>接下来，我们就再来总结一下 <code>sync.Pool</code>
高性能的一些设计要点：</p>
<ol type="1">
<li><code>noCopy</code> 字段，防止 <code>sync.Pool</code>
被复制。<code>sync.Pool</code>
是不能被复制的，否则会导致一些隐晦的错误。</li>
<li><code>local</code> 字段，用于存储与 <code>P</code> 关联的一个
<code>poolLocal</code> 对象，在多个 <code>goroutine</code>
同时操作的时候，可以减少不同 <code>goroutine</code>
之间的竞争，只有在本地的 <code>poolLocal</code>
中没有找到对象的时候，才会去其他 <code>goroutine</code>
关联的队列中去取。</li>
<li><code>poolDequeue</code> 中 <code>pushHead</code> 跟
<code>popTail</code> 之间会存在 <code>head</code>、<code>tail</code>
指针上的一些竞争，这些竞争问题是通过原子操作来解决的（相比互斥锁效率更高）。使用了原子操作可能就会有失败的时候，这个时候，再次重试就可以了。</li>
<li><code>poolDequeue</code> 中的 <code>head</code>/<code>tail</code>
指针使用一个字段来保存，然后通过原子操作保证
<code>head</code>/<code>tail</code> 的一致性。</li>
<li><code>poolChain</code>
使用链表的方式解决容量问题，并且新增一个元素到链表的时候，容量为上一个元素（<code>poolChain</code>
链表头）的两倍（非常常见的扩容策略）。双向链表，可以接受别的
<code>P</code> 的 <code>popTail</code>
操作，减少竞争的同时可以充分利用多核。</li>
<li><code>pin</code> 保证 <code>P</code> 不会被抢占。如果一个
<code>goroutine</code> 在执行 <code>Put</code> 或者 <code>Get</code>
期间被挂起，有可能下次恢复时，绑定的就不是上次的 <code>P</code>
了。那整个过程就会完全乱掉，因为获取到的 <code>poolLocal</code>
不是之前那个了。使用 <code>pin</code> 可以解决这种并发问题。</li>
<li>自旋操作，因为原子操作失败的时候可能存在竞争，这个时候再尝试一下就可能成功了。（<code>for</code>
+ 原子操作是无锁编程中很常见的一种编程模式，在 <code>sync.Map</code>
中也有很多类似操作）</li>
<li><code>pad</code> 内存对齐，可以避免伪共享。</li>
<li><code>poolDequeue</code>
中存储数据的结构是一个环形队列，是连续的内存，可以充分利用 CPU 的
<code>cache</code>。在访问 <code>poolDequeue</code>
某一项时，其附近的数据项都有可能加载到统一 <code>cache line</code>
中，有利于提升性能。同时它是预先分配内存的，因此其中的数据项可不断复用。</li>
</ol>
<h2 id="总结">总结</h2>
<p>最后，总结一下本文内容：</p>
<ul>
<li><code>sync.Pool</code>
是一个非常有用的工具，它可以帮助我们减少内存的分配和回收（通过复用对象），提升程序的性能。但是，我们要注意它的使用场景，它适合那些没有状态的对象，同时，我们不能对那些从
<code>Pool</code> 中 <code>Get</code> 出来的对象做任何假设。</li>
<li>我们在 <code>Put</code> 或者 <code>Get</code>
之前，可能需要对我们操作的对象重置一下，防止对后续的操作造成影响。</li>
<li><code>Pool</code>
中的对象存储是使用队列的方式，这个队列的实现是一个链表（<code>poolChain</code>），链表的每一个节点都是一个环形队列（<code>poolDequeue</code>）。这个队列支持以下三种操作：
<ul>
<li><code>pushHead</code>：将一个对象放到队列的头部。</li>
<li><code>popHead</code>：将队列的头部的对象取出来。</li>
<li><code>popTail</code>：将队列的尾部的对象取出来。</li>
</ul></li>
<li><code>sync.Pool</code> 的实现中，使用了很多编程技巧，比如
<code>noCopy</code>、<code>pin</code>、<code>pad</code>、原子操作等等，这些技巧都是为了实现一个高性能的
<code>Pool</code>
而做的一些优化，我们可以学习一下，具体参考上一节。</li>
<li><code>sync.Pool</code> 中，<code>Put</code> 和 <code>Get</code>
操作的时候会先将 <code>goroutine</code> 与 <code>P</code>
绑定，然后再去操作 <code>P</code> 关联的
<code>poolLocal</code>，这样可以减少竞争，提升性能。因为每一个
<code>P</code> 都有一个关联的 <code>poolLocal</code>，所以多个
<code>goroutine</code>
操作的时候，可以充分利用多核。在操作完成后，再解除绑定。</li>
<li>考虑到 <code>GC</code> 直接清除 <code>Pool</code> 中的对象会在
<code>GC</code> 后可能会产生性能抖动，所以在 <code>GC</code>
的时候，其实并不会马上清除 <code>Pool</code>
中的对象，而是将这些对象放到 <code>victim</code> 字段中，在
<code>Get</code> 的过程中，如果所有的 <code>poolLocal</code>
中获取不到对象，则会从 <code>victim</code> 中去找。但是再进行
<code>GC</code> 的时候，旧的 <code>victim</code> 会被清除。也就是
<code>Pool</code> 中对象的淘汰会经历两次 <code>GC</code>。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2023/01/31/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20sync.Cond/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/31/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20sync.Cond/" class="post-title-link" itemprop="url">深入理解 go sync.Cond</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-01-31 20:28:30" itemprop="dateCreated datePublished" datetime="2023-01-31T20:28:30+08:00">2023-01-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 go 的标准库中，提供了 <code>sync.Cond</code>
这个并发原语，让我们可以实现多个 <code>goroutine</code>
等待某一条件满足之后再继续执行。 它需要配合 <code>sync.Mutex</code>
一起使用，因为 <code>Cond</code> 的 <code>Wait</code> 方法需要在
<code>Mutex</code> 的保护下才能正常工作。
对于条件变量，可能大多数人只是知道它的存在，但是用到它的估计寥寥无几，因为很多并发场景的处理都能使用
<code>chan</code> 来实现， 而且 <code>chan</code> 的使用也更加简单。
但是在某些场景下，<code>Cond</code> 可能是最好的选择，本文就来探讨一下
<code>Cond</code> 的使用场景，基本用法，以及它的实现原理。</p>
<h2 id="sync.cond-是什么">sync.Cond 是什么？</h2>
<p><code>sync.Cond</code>
表示的是条件变量，它是一种同步机制，用来协调多个 <code>goroutine</code>
之间的同步，当共享资源的状态发生变化的时候，
可以通过条件变量来通知所有等待的 <code>goroutine</code>
去重新获取共享资源。</p>
<h3 id="适用场景">适用场景</h3>
<p>在实际使用中，我们可能会有多个 <code>goroutine</code>
在执行的过程中，由于某一条件不满足而阻塞的情况。
这个时候，我们就可以使用条件变量来实现 <code>goroutine</code>
之间的同步。比如，我们有一个 <code>goroutine</code> 用来获取数据，
但是可能会比较耗时，这个时候，我们就可以使用条件变量来实现
<code>goroutine</code> 之间的同步，
当数据准备好之后，就可以通过条件变量来通知所有等待的
<code>goroutine</code> 去重新获取共享资源。</p>
<blockquote>
<p><code>sync.Cond</code> 条件变量用来协调想要访问共享资源的那些
<code>goroutine</code>，当共享资源的状态发生变化的时候，
它可以用来通知所有等待的 <code>goroutine</code> 去重新获取共享资源。</p>
</blockquote>
<h2 id="sync.cond-的基本用法">sync.Cond 的基本用法</h2>
<p><code>sync.Cond</code> 的基本用法非常简单，我们只需要通过
<code>sync.NewCond</code> 方法来创建一个 <code>Cond</code> 实例，
然后通过 <code>Wait</code> 方法来等待条件满足，通过 <code>Signal</code>
或者 <code>Broadcast</code> 方法来通知所有等待的 <code>goroutine</code>
去重新获取共享资源。</p>
<h3 id="newcond-创建实例">NewCond 创建实例</h3>
<p><code>sync.NewCond</code> 方法用来创建一个 <code>Cond</code>
实例，它的参数是一个 <code>Locker</code> 接口，我们可以传入一个
<code>Mutex</code> 或者 <code>RWMutex</code> 实例。 这个条件变量的
<code>Locker</code> 接口就是用来保护共享资源的。</p>
<h3 id="wait-等待条件满足">Wait 等待条件满足</h3>
<p><code>Wait</code> 方法用来等待条件满足，它会先释放 <code>Cond</code>
的锁(<code>Cond.L</code>)，然后阻塞当前
<code>goroutine</code>(实际调用的是 <code>goparkunlock</code>)，直到被
<code>Signal</code> 或者 <code>Broadcast</code> 唤醒。</p>
<p>它做了如下几件事情：</p>
<ol type="1">
<li>释放 <code>Cond</code> 的锁(<code>Cond.L</code>)，然后阻塞当前
<code>goroutine</code>。（所以，使用之前需要先锁定）</li>
<li>被 <code>Signal</code> 或者 <code>Broadcast</code>
唤醒之后，会重新获取 <code>Cond</code> 的锁(<code>Cond.L</code>)。</li>
<li>之后，就返回到 <code>goroutine</code> 阻塞的地方继续执行。</li>
</ol>
<h3 id="signal-通知一个等待的-goroutine">Signal 通知一个等待的
goroutine</h3>
<p><code>Signal</code> 方法用来通知一个等待的
<code>goroutine</code>，它会唤醒一个等待的
<code>goroutine</code>，然后继续执行当前 <code>goroutine</code>。
如果没有等待的 <code>goroutine</code>，则不会有任何操作。</p>
<h3 id="broadcast-通知所有等待的-goroutine">Broadcast 通知所有等待的
goroutine</h3>
<p><code>Broadcast</code> 方法用来通知所有等待的
<code>goroutine</code>，它会唤醒所有等待的
<code>goroutine</code>，然后继续执行当前 <code>goroutine</code>。
如果没有等待的 <code>goroutine</code>，则不会有任何操作。</p>
<h2 id="sync.cond-使用实例">sync.Cond 使用实例</h2>
<p>下面我们通过一个实例来看一下 <code>sync.Cond</code> 的使用方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cond</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> data <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;writing.&quot;</span>)</span><br><span class="line">	<span class="comment">// 让 reader 先获取锁，模拟条件不满足然后 wait 的情况</span></span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	<span class="comment">// 模拟耗时的写操作</span></span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">	data = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;writing done.&quot;</span>)</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">	c.Broadcast()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;reading&quot;</span>)</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	<span class="keyword">for</span> !done &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;reader wait.&quot;</span>)</span><br><span class="line">		c.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;read done.&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;data:&quot;</span>, data)</span><br><span class="line">	<span class="keyword">defer</span> c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCond</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c = sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> read(c)  <span class="comment">// 读操作</span></span><br><span class="line">	<span class="keyword">go</span> read(c)  <span class="comment">// 读操作</span></span><br><span class="line">	<span class="keyword">go</span> write(c) <span class="comment">// 写操作</span></span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">100</span>) <span class="comment">// 等待操作完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">reading</span><br><span class="line">reader wait. // 还没获取完数据，需要等待</span><br><span class="line">writing.</span><br><span class="line">reading</span><br><span class="line">reader wait.</span><br><span class="line">writing done. // 获取完数据了，通知所有等待的 reader</span><br><span class="line">read done. // 读取到数据了</span><br><span class="line">data: hello world // 输出读取到的数据</span><br><span class="line">read done.</span><br><span class="line">data: hello world</span><br></pre></td></tr></table></figure>
<p>这个例子可以粗略地用下图来表示：</p>
<figure>
<img src="/images/go/cond/cond_1.png" alt="cond_1" />
<figcaption aria-hidden="true">cond_1</figcaption>
</figure>
<p>说明：</p>
<ul>
<li><code>read1</code> 和 <code>reader2</code> 表示两个
<code>goroutine</code>，它们都会调用 <code>read</code> 函数。</li>
<li>在 <code>done</code> 为 <code>false</code>
的时候，<code>reader1</code> 和 <code>reader2</code> 都会调用
<code>c.Wait()</code> 函数，然后阻塞等待。</li>
<li><code>write</code> 表示一个 <code>goroutine</code>，它会调用
<code>write</code> 函数。</li>
<li>在 <code>write</code> 函数中，获取完数据之后，会将 <code>done</code>
设置为 <code>true</code>，然后调用 <code>c.Broadcast()</code>
函数，通知所有等待的 <code>reader</code> 去重新获取共享资源。</li>
<li><code>reader1</code> 和 <code>reader2</code>
在解除阻塞状态后，都会重新获取共享资源，然后输出读取到的数据。</li>
</ul>
<p>在这个例子中，<code>done</code>
的功能是标记，用来表示共享资源是否已经获取完毕，如果没有获取完毕，那么
<code>reader</code> 就会阻塞等待。</p>
<h2 id="为什么要用-sync.cond">为什么要用 sync.Cond？</h2>
<p>在文章开头，我们说了，很多并发编程的问题都可以通过
<code>channel</code> 来解决。 同样的，在上面提到的
<code>sync.Cond</code> 的使用场景，使用 <code>channel</code>
也是可以实现的， 我们只要 <code>close(ch)</code> 来关闭
<code>channel</code> 就可以实现通知多个等待的协程了。</p>
<p>那么为什么还要用 <code>sync.Cond</code> 呢？
主要原因是，<code>sync.Cond</code> 可以重复地进行 <code>Wait()</code> 和
<code>Signal()</code>、<code>Broadcast()</code> 操作，
但是，如果想通过关闭 <code>chan</code>
来实现这个功能的话，那就只能通知一次了。 因为 <code>channel</code>
只能关闭一次，关闭一个已经关闭的 <code>channel</code> 会导致程序
panic。</p>
<p>使用 <code>channel</code> 的另外一种方式是，记录 <code>reader</code>
的数量，然后通过往 <code>channel</code> 中发送多次数据来实现通知多个
<code>reader</code>。
但是这样一来代码就会复杂很多，从另一个角度说，出错的概率大了很多。</p>
<h3 id="close-channel-广播实例">close channel 广播实例</h3>
<p>下面的例子模拟了使用 <code>close(chan)</code> 来实现
<code>sync.Cond</code> 中那种广播功能，但是只能通知一次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> close_chan</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;reading.&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 chan 接收数据，如果 chan 中没有数据，会阻塞。</span></span><br><span class="line">	<span class="comment">// 如果能接收到数据，或者 chan 被关闭，会解除阻塞状态。</span></span><br><span class="line">	&lt;-c</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;data:&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;writing.&quot;</span>)</span><br><span class="line">	<span class="comment">// 模拟耗时的写操作</span></span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">	data = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;write done.&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭 chan 的时候，会通知所有的 reader</span></span><br><span class="line">	<span class="comment">// 所有等待从 chan 接收数据的 goroutine 都会被唤醒</span></span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCloseChan</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> read(ch)</span><br><span class="line">	<span class="keyword">go</span> read(ch)</span><br><span class="line">	<span class="keyword">go</span> write(ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不能关闭已经关闭的 chan</span></span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">20</span>)</span><br><span class="line">	<span class="comment">// panic: close of closed channel</span></span><br><span class="line">	<span class="comment">// 下面这行代码会导致 panic</span></span><br><span class="line">	<span class="comment">//go write(ch)</span></span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">writing.</span><br><span class="line">reading. // 会阻塞直到写完</span><br><span class="line">reading. // 会阻塞直到写完</span><br><span class="line">write done. // 写完之后，才能读</span><br><span class="line">data: hello world</span><br><span class="line">data: hello world</span><br></pre></td></tr></table></figure>
<p>上面例子的 <code>write</code> 不能多次调用，否则会导致 panic。</p>
<h2 id="sync.cond-基本原理">sync.Cond 基本原理</h2>
<p>go 的 <code>sync.Cond</code>
中维护了一个链表，这个链表记录了所有阻塞的
<code>goroutine</code>，也就是由于调用了 <code>Wait</code> 而阻塞的
<code>goroutine</code>。 而 <code>Signal</code> 和
<code>Broadcast</code> 方法就是用来唤醒这个链表中的
<code>goroutine</code> 的。 <code>Signal</code>
方法只会唤醒链表中的第一个 <code>goroutine</code>，而
<code>Broadcast</code> 方法会唤醒链表中的所有
<code>goroutine</code>。</p>
<p>下图是 <code>Signal</code> 方法的效果，可以看到，<code>Signal</code>
方法只会唤醒链表中的第一个 <code>goroutine</code>：</p>
<figure>
<img src="/images/go/cond/cond_2.png" alt="cond_2" />
<figcaption aria-hidden="true">cond_2</figcaption>
</figure>
<p>说明：</p>
<ul>
<li><code>notifyList</code> 是 <code>sync.Cond</code>
中维护的一个链表，这个链表记录了所有阻塞的 <code>goroutine</code>。</li>
<li><code>head</code> 是链表的头节点，<code>tail</code>
是链表的尾节点。</li>
<li><code>Signal</code> 方法只会唤醒链表中的第一个
<code>goroutine</code>。</li>
</ul>
<p>而 <code>Broadcast</code> 方法会唤醒 <code>notifyList</code> 中的所有
<code>goroutine</code>。</p>
<h2 id="sync.cond-的设计与实现">sync.Cond 的设计与实现</h2>
<p>最后，我们来看一下 <code>sync.Cond</code> 的设计与实现。</p>
<h3 id="sync.cond-模型">sync.Cond 模型</h3>
<p><code>sync.Cond</code> 的模型如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line"></span><br><span class="line">	<span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">	L Locker <span class="comment">// L 在观察或改变条件时被持有</span></span><br><span class="line"></span><br><span class="line">	notify  notifyList</span><br><span class="line">	checker copyChecker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性说明：</p>
<ul>
<li><code>noCopy</code> 是一个空结构体，用来检查 <code>sync.Cond</code>
是否被复制。（在编译前通过 <code>go vet</code> 命令来检查）</li>
<li><code>L</code> 是一个 <code>Locker</code>
接口，用来保护条件变量。</li>
<li><code>notify</code> 是一个 <code>notifyList</code>
类型，用来记录所有阻塞的 <code>goroutine</code>。</li>
<li><code>checker</code> 是一个 <code>copyChecker</code> 类型，用来检查
<code>sync.Cond</code> 是否被复制。（如果在运行时被复制，会导致
<code>panic</code>）</li>
</ul>
<h3 id="notifylist-结构体">notifyList 结构体</h3>
<p><code>notifyList</code> 是 <code>sync.Cond</code>
中维护的一个链表，这个链表记录了所有因为共享资源还没准备好而阻塞的
<code>goroutine</code>。它的定义如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">	wait atomic.Uint32</span><br><span class="line">	notify <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 阻塞的 waiter 名单。</span></span><br><span class="line">	lock mutex <span class="comment">// 锁</span></span><br><span class="line">	head *sudog <span class="comment">// 阻塞的 goroutine 链表（链表头）</span></span><br><span class="line">	tail *sudog <span class="comment">// 阻塞的 goroutine 链表（链表尾）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性说明：</p>
<ul>
<li><code>wait</code> 是下一个 <code>waiter</code>
的编号。它在锁外自动递增。</li>
<li><code>notify</code> 是下一个要通知的 <code>waiter</code>
的编号。它可以在锁外读取，但只能在持有锁的情况下写入。</li>
<li><code>lock</code> 是一个 <code>mutex</code> 类型，用来保护
<code>notifyList</code>。</li>
<li><code>head</code> 是一个 <code>sudog</code> 类型，用来记录阻塞的
<code>goroutine</code> 链表的头节点。</li>
<li><code>tail</code> 是一个 <code>sudog</code> 类型，用来记录阻塞的
<code>goroutine</code> 链表的尾节点。</li>
</ul>
<p><code>notifyList</code> 的方法说明：</p>
<blockquote>
<p><code>notifyList</code> 中包含了几个操作阻塞的 <code>goroutine</code>
链表的方法。</p>
</blockquote>
<ul>
<li><code>notifyListAdd</code> 方法将 <code>waiter</code> 的编号加
1。</li>
<li><code>notifyListWait</code> 方法将当前的 <code>goroutine</code>
加入到 <code>notifyList</code> 中。（也就是将当前协程挂起）</li>
<li><code>notifyListNotifyOne</code> 方法将 <code>notifyList</code>
中的第一个 <code>goroutine</code> 唤醒。</li>
<li><code>notifyListNotifyAll</code> 方法将 <code>notifyList</code>
中的所有 <code>goroutine</code> 唤醒。</li>
<li><code>notifyListCheck</code> 方法检查 notifyList
的大小是否正确。</li>
</ul>
<h3 id="sync.cond-的方法">sync.Cond 的方法</h3>
<p><code>notifyList</code> 就不细说了，本文重点讲解一下
<code>sync.Cond</code> 的实现。</p>
<h4 id="wait-方法">Wait 方法</h4>
<p><code>Wait</code>
方法用在当条件不满足的时候，将当前运行的协程挂起。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">	<span class="comment">// 检查是否被复制</span></span><br><span class="line">	c.checker.check()</span><br><span class="line">	<span class="comment">// 更新 notifyList 中需要等待的 waiter 的数量</span></span><br><span class="line">	<span class="comment">// 返回当前需要插入 notifyList 的编号</span></span><br><span class="line">	t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">	<span class="comment">// 解锁</span></span><br><span class="line">	c.L.Unlock()</span><br><span class="line">	<span class="comment">// 挂起当前 g，直到被唤醒</span></span><br><span class="line">	runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">	<span class="comment">// 唤醒之后，重新加锁。</span></span><br><span class="line">	<span class="comment">// 因为阻塞之前解锁了。</span></span><br><span class="line">	c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Wait</code>
方法，我们需要注意的是，使用之前，我们需要先调用 <code>L.Lock()</code>
方法加锁，然后再调用 <code>Wait</code> 方法，否则会报错。</p>
<p>文档里面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> !condition() &#123;</span><br><span class="line">    c.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...使用条件...</span></span><br><span class="line"><span class="comment">// 这里是我们在条件满足之后，需要执行的代码。</span></span><br><span class="line">c.L.Unlock()</span><br></pre></td></tr></table></figure>
<p>好了，问题来了，<strong>调用 <code>Wait</code>
方法之前为什么要先加锁呢？</strong></p>
<p>这是因为在我们使用共享资源的时候，可能一些代码是互斥的，所以我们需要加锁。
这样我们就可以保证在我们使用共享资源的时候，不会被其他协程修改。
但是如果因为条件不满足，我们需要等待的话，我们不可能在持有锁的情况下等待，
因为在修改条件的时候，可能也需要加锁，这样就会造成死锁。</p>
<p>另外一个问题是，<strong>为什么要使用 <code>for</code>
来检查条件是否满足，而不是使用 <code>if</code> 呢？</strong></p>
<p>这是因为在我们调用 <code>Wait</code>
方法之后，可能会有其他协程唤醒我们，但是条件并没有满足，
这个时候依然是需要继续 <code>Wait</code> 的。</p>
<h4 id="signal-方法">Signal 方法</h4>
<p><code>Signal</code> 方法用在当条件满足的时候，将
<code>notifyList</code> 中的第一个 <code>goroutine</code> 唤醒。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">	<span class="comment">// 检查 sync.Cond 是否被复制了</span></span><br><span class="line">	c.checker.check()</span><br><span class="line">	<span class="comment">// 唤醒 notifyList 中的第一个 goroutine</span></span><br><span class="line">	runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="broadcast-方法">Broadcast 方法</h4>
<p><code>Broadcast</code> 方法用在当条件满足的时候，将
<code>notifyList</code> 中的所有 <code>goroutine</code> 唤醒。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">	<span class="comment">// 检查 sync.Cond 是否被复制了</span></span><br><span class="line">	c.checker.check()</span><br><span class="line">	<span class="comment">// 唤醒 notifyList 中的所有 goroutine</span></span><br><span class="line">	runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="copychecker-结构体">copyChecker 结构体</h4>
<p><code>copyChecker</code> 结构体用来检查 <code>sync.Cond</code>
是否被复制。它实际上只是一个 <code>uintptr</code> 类型的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> copyChecker <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// check 方法检查 copyChecker 是否被复制了。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyChecker)</span></span> check() &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;</span><br><span class="line">		!atomic.CompareAndSwapUintptr((*<span class="type">uintptr</span>)(c), <span class="number">0</span>, <span class="type">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;</span><br><span class="line">		<span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync.Cond is copied&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>copyChecker</code> 的值只有两种可能：</p>
<ol type="1">
<li><code>0</code>，表示还没有调用过 <code>Wait</code>,
<code>Signal</code> 或 <code>Broadcast</code> 方法。</li>
<li><code>uintptr(unsafe.Pointer(&amp;copyChecker))</code>，表示已经调用过
<code>Wait</code>, <code>Signal</code> 或 <code>Broadcast</code>
方法。在这几个方法里面会调用 <code>check</code> 方法，所以
<code>copyChecker</code> 的值会被修改。</li>
</ol>
<p>所以如果 <code>copyChecker</code> 的值不是 <code>0</code>，也不是
<code>uintptr(unsafe.Pointer(&amp;copyChecker))</code>（也就是最初的
<code>copyChecker</code> 的内存地址），则表示 <code>copyChecker</code>
被复制了。</p>
<blockquote>
<p>需要注意的是，这个方法在调用 <code>CompareAndSwapUintptr</code>
还会检查一下，这是因为有可能会并发调用
<code>CompareAndSwapUintptr</code>， 如果另外一个协程调用了
<code>CompareAndSwapUintptr</code> 并且成功了，那么当前协程的这个
<code>CompareAndSwapUintptr</code> 调用会返回 <code>false</code>，
这个时候就需要检查是否是因为另外一个协程调用了
<code>CompareAndSwapUintptr</code> 而导致的，如果是的话，就不会
<code>panic</code>。</p>
</blockquote>
<h2 id="为什么-sync.cond-不能被复制">为什么 sync.Cond 不能被复制？</h2>
<p>从上一小节中我们可以看到，<code>sync.Cond</code>
其实是不允许被复制的，但是如果是在调用 <code>Wait</code>,
<code>Signal</code> 或 <code>Broadcast</code>
方法之前复制，那倒是没关系。</p>
<p>这是因为 <code>sync.Cond</code> 中维护了一个阻塞的
<code>goroutine</code> 列表。如果 <code>sync.Cond</code>
被复制了，那么这个列表就会被复制，这样就会导致两个
<code>sync.Cond</code>
都包含了这个列表；但是我们唤醒的时候，只会有其中一个
<code>sync.Cond</code> 被唤醒，另外一个 <code>sync.Cond</code>
就会一直阻塞。 所以 go 直接从语言层面限制了这种情况，不允许
<code>sync.Cond</code> 被复制。</p>
<h2 id="总结">总结</h2>
<ul>
<li><code>sync.Cond</code> 是一个条件变量，它可以用来协调多个
<code>goroutine</code>
之间的同步，当条件满足的时候，去通知那些因为条件不满足被阻塞的
<code>goroutine</code> 继续执行。</li>
<li><code>sync.Cond</code> 的接口比较简单，只有 <code>Wait</code>,
<code>Signal</code> 和 <code>Broadcast</code> 三个方法。
<ul>
<li><code>Wait</code> 方法用来阻塞当前
<code>goroutine</code>，直到条件满足。调用 <code>Wait</code>
方法之前，需要先调用 <code>L.Lock</code> 方法加锁。</li>
<li><code>Signal</code> 方法用来唤醒 <code>notifyList</code> 中的第一个
<code>goroutine</code>。</li>
<li><code>Broadcast</code> 方法用来唤醒 <code>notifyList</code> 中的所有
<code>goroutine</code>。</li>
</ul></li>
<li><code>sync.Cond</code> 的实现也比较简单，它的核心就是
<code>notifyList</code>，它是一个链表，用来保存所有因为条件不满足而被阻塞的
<code>goroutine</code>。</li>
<li>用关闭 <code>channel</code>
的方式也可以实现类似的广播功能，但是有个问题是 <code>channel</code>
不能被重复关闭，所以这种方式无法被多次使用。也就是说使用这种方式无法多次广播。</li>
<li>使用 <code>channel</code>
发送通知的方式也是可以的，但是这样实现起来就复杂很多了，就更容易出错了。</li>
<li><code>sync.Cond</code> 中使用 <code>copyChecker</code> 来检查
<code>sync.Cond</code> 是否被复制，如果被复制了，就会
<code>panic</code>。需要注意的是，这里的复制是指调用了
<code>Wait</code>，<code>Signal</code> 或 <code>Broadcast</code>
方法之后，<code>sync.Cond</code>
被复制了。在调用这几个方法之前进行复制是没有影响的。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/70/">70</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/14/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">eleven26</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eleven26" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
