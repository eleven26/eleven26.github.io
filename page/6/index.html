<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eleven26.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="eleven26">
<meta property="og:url" content="https://eleven26.github.io/page/6/index.html">
<meta property="og:site_name" content="eleven26">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="eleven26">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="PHP">
<meta property="article:tag" content="Laravel">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://eleven26.github.io/page/6/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>eleven26</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">eleven26</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">100</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">346</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eleven26</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eleven26" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eleven26" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2024/05/14/golang/Go%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/14/golang/Go%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">Go 单元测试完全指南（四）- 模糊测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-05-14 20:08:30" itemprop="dateCreated datePublished" datetime="2024-05-14T20:08:30+08:00">2024-05-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是模糊测试">什么是模糊测试</h2>
<p>在 Go 1.18 版本中，Go
引入了一个新的测试工具：模糊测试（<code>Fuzzing</code>）。模糊测试是一种自动化测试技术，它通过随机输入来发现程序中的错误。</p>
<p>模糊测试的原理很简单：随机生成输入，然后运行程序，检查程序的输出是否符合预期。如果程序的输出不符合预期，那么就说明程序中存在错误。</p>
<p>模糊测试的优点是可以发现一些边缘情况下的错误或者可能导致程序崩溃的输入，这些错误很难通过手工测试来发现。因此，模糊测试是一种非常有效的测试方法。</p>
<h2 id="如何进行模糊测试">如何进行模糊测试</h2>
<p>在这里引入一下官方博客的图：</p>
<p><img src="/images/go/unittest/fuzz_0.png" /></p>
<p>下面是详细说明：</p>
<ol type="1">
<li>首先，我们需要创建一个模糊测试函数，函数名以 <code>Fuzz</code>
开头，后面跟着要测试的函数名，函数名第一个字母大写，接收一个
<code>*testing.F</code> 参数。</li>
<li>模糊测试需要写在 <code>_test.go</code> 文件中。</li>
<li>一个模糊测试函数里面，必须包含一个模糊目标，也就是需要调用
<code>(*testing.F).Fuzz</code> 方法，这个方法的第一个参数是
<code>*testing.T</code>，后续是模糊测试自动生成的输入（我们需要使用这些随机的输入去调用我们的函数）。这个模糊目标没有返回值。</li>
<li>一个模糊测试只能有一个模糊目标（也就是上图的
<code>Fuzz target</code> 只能有一个）。</li>
<li>所有的种子语料库的类型必须和 <code>Fuzz</code>
函数的输入参数（上图的 <code>Seed corpus addition</code> 跟
<code>Fuzzing arguments</code>）类型一致，因为模糊测试是根据
<code>Seed corpus</code> 的类型生成的随机参数来传递给
<code>Fuzzing arguments</code> 的。</li>
<li>模糊测试的参数只能是以下的类型：
<ul>
<li><code>string</code>, <code>[]byte</code></li>
<li><code>int</code>, <code>int8</code>, <code>int16</code>,
<code>int32</code>, <code>int64</code></li>
<li><code>uint</code>, <code>uint8/byte</code>, <code>uint16</code>,
<code>uint32</code>, <code>uint64</code></li>
<li><code>float32</code>, <code>float64</code></li>
<li><code>bool</code></li>
</ul></li>
</ol>
<h2 id="模糊测试示例">模糊测试示例</h2>
<p>假设我们有以下这个反转字符串的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	runes := []<span class="type">rune</span>(s)</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(runes)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		runes[i], runes[j] = runes[j], runes[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(runes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>rune</code> 在 Go 里面是 <code>int32</code> 的别名，用来表示
Unicode 字符（因为 Unicode 字符最多只有 4 字节，所以 <code>rune</code>
足够存储一个 Unicode 字符）。</p>
</blockquote>
<p>接着，为这个 <code>Reverse</code> 函数写一个模糊测试函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuzzReverse</span><span class="params">(f *testing.F)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 种子语料库</span></span><br><span class="line">	testcases := []<span class="type">string</span>&#123;<span class="string">&quot;Hello, world&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;!12345&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, tc := <span class="keyword">range</span> testcases &#123;</span><br><span class="line">		f.Add(tc)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 模糊目标，orig 是随机生成的输入（根据上面的种子语料库生成）</span></span><br><span class="line">	f.Fuzz(<span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, orig <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 使用随机生成的输入去调用 Reverse 函数</span></span><br><span class="line">        <span class="comment">// 如果 Reverse 函数返回的结果不等于 orig 的反转，那么就说明 Reverse 函数有问题</span></span><br><span class="line">		rev := Reverse(orig)</span><br><span class="line">		doubleRev := Reverse(rev)</span><br><span class="line">		<span class="keyword">if</span> orig != doubleRev &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;Before: %q, after: %q&quot;</span>, orig, doubleRev)</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 又或者，如果 Reverse 函数返回的结果不是一个有效的 UTF-8 字符串，那么就说明 Reverse 函数有问题</span></span><br><span class="line">		<span class="keyword">if</span> utf8.ValidString(orig) &amp;&amp; !utf8.ValidString(rev) &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;Reverse produced invalid UTF-8 string %q&quot;</span>, rev)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，通过下面的命令来执行一下模糊测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -fuzz=FuzzReverse -fuzztime=3s .</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 0/4 completed</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 4/4 completed, now fuzzing with 20 workers</span><br><span class="line">fuzz: minimizing 51-byte failing input file</span><br><span class="line">fuzz: elapsed: 0s, minimizing</span><br><span class="line">--- FAIL: FuzzReverse (0.03s)</span><br><span class="line">    --- FAIL: FuzzReverse (0.00s)</span><br><span class="line">        hello_test.go:25: Before: &quot;\x80&quot;, after: &quot;�&quot;</span><br><span class="line">    </span><br><span class="line">    Failing input written to testdata/fuzz/FuzzReverse/98fce631eb9c5dd5</span><br><span class="line">    To re-run:</span><br><span class="line">    go test -run=FuzzReverse/98fce631eb9c5dd5</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    main  0.033s</span><br></pre></td></tr></table></figure>
<p>从上述输出可以看到，我们有一个模糊测试的用例失败了，然后 Go
帮我们把错误的测试用例写入到了
<code>testdata/fuzz/FuzzReverse/98fce631eb9c5dd5</code> 文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go test fuzz v1</span><br><span class="line">string(&quot;\x80&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="修正这个问题">修正这个问题</h3>
<p>我们从 <code>98fce631eb9c5dd5</code>
这个文件可以看出，模糊测试给我们生成的字符串并不是一个有效的 UTF-8
字符串，所以我们需要在 <code>FuzzReverse</code> 函数中加入一些判断：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断是否是有效的 utf-8 字符串</span></span><br><span class="line">	<span class="keyword">if</span> !utf8.ValidString(s) &#123;</span><br><span class="line">		<span class="keyword">return</span> s, errors.New(<span class="string">&quot;input is not valid UTF-8&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	runes := []<span class="type">rune</span>(s)</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(runes)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		runes[i], runes[j] = runes[j], runes[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(runes), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在判断到传入的字符串不是有效的 UTF-8
字符串的时候，我们返回一个错误。然后在 <code>FuzzReverse</code>
函数中加入对错误的判断：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuzzReverse</span><span class="params">(f *testing.F)</span></span> &#123;</span><br><span class="line">	testcases := []<span class="type">string</span>&#123;<span class="string">&quot;Hello, world&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;!12345&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, tc := <span class="keyword">range</span> testcases &#123;</span><br><span class="line">		f.Add(tc)</span><br><span class="line">	&#125;</span><br><span class="line">	f.Fuzz(<span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, orig <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		rev, err := Reverse(orig)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		doubleRev, err := Reverse(rev)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> orig != doubleRev &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;Before: %q, after: %q&quot;</span>, orig, doubleRev)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> utf8.ValidString(orig) &amp;&amp; !utf8.ValidString(rev) &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;Reverse produced invalid UTF-8 string %q&quot;</span>, rev)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跳过不是 UTF-8 字符串的测试用例，然后再次执行模糊测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -fuzz=FuzzReverse -fuzztime=3s .</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 0/6 completed</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 6/6 completed, now fuzzing with 20 workers</span><br><span class="line">fuzz: elapsed: 3s, execs: 1431158 (477041/sec), new interesting: 39 (total: 45)</span><br><span class="line">fuzz: elapsed: 3s, execs: 1431158 (0/sec), new interesting: 39 (total: 45)</span><br><span class="line">PASS</span><br><span class="line">ok      main  3.117s</span><br></pre></td></tr></table></figure>
<p>这次模糊测试通过了，没有发现问题。</p>
<h2 id="运行模糊测试一些建议">运行模糊测试一些建议</h2>
<h3 id="模糊测试的时间">模糊测试的时间</h3>
<p>需要注意的是，在进行模糊测试的时候，我们可能需要指定一个合适的时间，否则模糊测试可能会一直运行下去。可以通过
<code>-fuzztime</code> 参数来指定模糊测试的时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -fuzz=FuzzReverse -fuzztime=3s .</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们需要在 CI 中集成，这个可能是必须的。否则，CI
会一直运行模糊测试。</p>
</blockquote>
<h3 id="调整种子语料库">调整种子语料库</h3>
<p>检查提供给模糊器的种子语料库，确保其多样性足以探索各种代码路径，但又不会过于宽泛，导致模糊器陷入过多路径。有时，过于通用的种子会导致模糊器在无益路径上花费过多时间。</p>
<h3 id="并行模糊测试">并行模糊测试</h3>
<p>如果我们需要控制模糊测试的并行度，可以通过 <code>-parallel</code>
参数来指定模糊测试的并行度：</p>
<blockquote>
<p>默认情况下，Go 会使用所有的 CPU 核心来运行模糊测试。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -fuzz=FuzzReverse -fuzztime=3s -parallel=10 .</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 0/52 completed</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 52/52 completed, now fuzzing with 10 workers</span><br><span class="line">fuzz: elapsed: 3s, execs: 1164562 (388133/sec), new interesting: 0 (total: 52)</span><br><span class="line">fuzz: elapsed: 3s, execs: 1164562 (0/sec), new interesting: 0 (total: 52)</span><br><span class="line">PASS</span><br><span class="line">ok      main  3.109s</span><br></pre></td></tr></table></figure>
<p>我们从第二行输出可以看到 <code>10 workers</code>，因为我们通过了
<code>-parallel</code> 参数指定了只使用 10 个 CPU
核心来运行模糊测试。</p>
<h2 id="总结">总结</h2>
<p>模糊测试是一种自动化测试技术，它通过随机输入来发现程序中的错误。Go
1.18 版本引入了模糊测试，我们可以通过 <code>(*testing.F).Fuzz</code>
方法来进行模糊测试。模糊测试是一种非常有效的测试方法，可以发现一些边缘情况下的错误或者可能导致程序崩溃的输入。</p>
<p>单元测试可以帮助我们发现一些常规路径上的错误，而模糊测试可以帮助我们发现一些边缘情况下的错误。因此，单元测试和模糊测试是互补的，我们可以同时使用这两种测试方法来提高代码的质量。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2024/05/11/golang/Go%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/11/golang/Go%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">Go 单元测试完全指南（三）- Example 测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-05-11 20:08:30" itemprop="dateCreated datePublished" datetime="2024-05-11T20:08:30+08:00">2024-05-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是-example-测试">什么是 Example 测试</h2>
<p>Example 测试是 Go
语言中的一种特殊测试，它用于展示函数或方法的使用方式。Example
测试的代码位于 <code>_test.go</code> 文件中，以 <code>Example</code>
开头，后面跟着函数名。</p>
<p>其实，Example 测试是 godoc 工具的一部分，它会读取代码中的 Example
测试，并将其展示在文档中。这样，用户就可以直接在文档中看到函数或方法的使用方式。</p>
<p>可以说，Example
测试是一种文档测试，它不仅可以测试代码，还可以帮助用户更好地理解代码。</p>
<h2 id="一个简单的-example-测试">一个简单的 Example 测试</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Hello()</span><br><span class="line">	<span class="comment">// Output: Hello, World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们执行 <code>go test</code> 命令就可以运行 Example 测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -v</span><br></pre></td></tr></table></figure>
<p>如果我们的 Example 测试通过，那么输出结果会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   ExampleHello</span><br><span class="line">--- PASS: ExampleHello (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      go-test 0.004s</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol type="1">
<li><code>ExampleHello</code> 是我们的 Example
测试函数名。（注意：<code>Hello</code>
是规范的一部分，实际上是我们的函数名）</li>
<li><code>Example</code> 测试的格式是在代码后面加上
<code>// Output:</code>
注释，后面跟着期望的输出结果。如果实际输出结果和期望的输出结果一致，那么
Example 测试就通过了。</li>
<li><code>Example</code>
测试的目的是展示函数或方法的使用方式，而不只是测试。</li>
</ol>
<h2 id="example-跟文档的关系">Example 跟文档的关系</h2>
<p>我们写的所有的 Example 测试都会被 godoc
工具读取，然后展示在文档中。这样，用户就可以直接在文档中看到函数或方法的使用方式。</p>
<p>我们可以通过下面的命令预览文档：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godoc -http=:8080</span><br></pre></td></tr></table></figure>
<p>注意，如果找不到 <code>godoc</code> 命令，通过下面的命令安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install golang.org/x/tools/cmd/godoc@latest</span><br></pre></td></tr></table></figure>
<p>安装完成后，再将 <code>$GOPATH/bin</code> 目录添加到环境变量中。</p>
<h3 id="示例">示例</h3>
<p>假设我的目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// go.mod</span><br><span class="line">module mytest</span><br><span class="line"></span><br><span class="line">go 1.22</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x/hello.go</span></span><br><span class="line"><span class="keyword">package</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello prints &quot;Hello, World!&quot; to the console.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x/hello_test.go</span></span><br><span class="line"><span class="keyword">package</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Hello()</span><br><span class="line">	<span class="comment">// Output: Hello, World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在运行了 <code>godoc -http=:8080</code>
命令后，我们可以在浏览器中输入
<code>http://localhost:8080/pkg/mytest/x/</code> 来查看文档：</p>
<p><img src="/images/go/unittest/example_test_0.png" /></p>
<p>我们可以看到 <code>Hello</code> 的文档以及其使用示例。</p>
<blockquote>
<p>Example 测试既是测试，又是文档。</p>
</blockquote>
<h2 id="example-测试的命名规范">Example 测试的命名规范</h2>
<ol type="1">
<li>Example 测试的函数名必须以 <code>Example</code> 开头。</li>
<li>遵循以下的命名规范，可以让我们的 <code>Example</code> 在 godoc
中展示在不同的位置。</li>
</ol>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>命名规范</th>
<th>位置</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Example</td>
<td>在包的概述中列出</td>
</tr>
<tr class="even">
<td>ExampleXxx</td>
<td>在 Xxx 函数/结构体/接口 中列出</td>
</tr>
<tr class="odd">
<td>ExampleXxx_Yyy</td>
<td>Xxx 结构体的 Yyy 方法</td>
</tr>
<tr class="even">
<td>ExampleXxx_Yyy_one</td>
<td>当你想给 Xxx 结构体的 Yyy
方法写多个示例的时候。当需要写多个示例的时候，前面几个也可以加
<code>_one</code> 这样的后缀</td>
</tr>
</tbody>
</table>
<blockquote>
<p>也就是说，不同的命名规范意味着是写给不同对象的示例。</p>
</blockquote>
<h2 id="无序输出的-example-测试">无序输出的 Example 测试</h2>
<p>如果我们的函数或方法的输出是无序的，那么我们可以使用
<code>// Unordered</code> 注释来标记。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExamplePerm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> rand.Perm(<span class="number">5</span>) &#123;</span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Unordered output: 4</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2024/05/09/golang/Go%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/09/golang/Go%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">Go 单元测试完全指南（二）- 性能测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-05-09 20:08:30" itemprop="dateCreated datePublished" datetime="2024-05-09T20:08:30+08:00">2024-05-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一个基本的性能测试">一个基本的性能测试</h2>
<p>我们以斐波那契数列为例，来看一个基本的性能测试。</p>
<p>需要测试的文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fib(n<span class="number">-2</span>) + fib(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib_test.go</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		fib(<span class="number">20</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过执行下面的命令来运行性能测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench .</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-test</span><br><span class="line">cpu: 12th Gen Intel(R) Core(TM) i7-12700F</span><br><span class="line">BenchmarkFib-20            47515             25053 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      go-test 1.451s</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>输出字段说明：
<ul>
<li><code>goos</code>：操作系统。</li>
<li><code>goarch</code>：CPU 架构。</li>
<li><code>pkg</code>：包名。</li>
<li><code>cpu</code>：CPU 信息。</li>
<li><code>BenchmarkFib-20</code>：测试函数的名字。<code>20</code> 表示
<code>GOMAXPROCS</code>（线程数）的值为 20。</li>
<li><code>47515</code>：测试函数运行的次数。</li>
<li><code>25053 ns/op</code>：每次运行的平均耗时，也就是每次操作耗时
25053 纳秒。</li>
</ul></li>
<li>基准测试函数的名字必须以 <code>Benchmark</code>
开头，后面跟被测试的函数名，函数名的第一个字母必须大写。如上面的
<code>BenchmarkFib</code>。</li>
<li>基准测试函数的参数是 <code>*testing.B</code>。</li>
<li>运行基准测试的命令是 <code>go test -bench .</code>，其中
<code>.</code> 表示当前目录。</li>
<li><code>b.N</code>
是基准测试框架提供的一个参数，表示基准测试函数运行的次数。</li>
</ul>
<p>如果我们想知道每次操作中内存的分配情况，可以使用
<code>-benchmem</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -benchmem</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在输出中就会显示每次操作分配的内存情况。</p>
</blockquote>
<h2 id="cpu-性能测试及分析">CPU 性能测试及分析</h2>
<p>上面的基准测试，我们是直接输出了测试结果，如果我们想要更详细的分析，可以使用
<code>pprof</code> 工具。</p>
<p>我们可以使用下面的测试命令来生成 CPU 性能分析的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -cpuprofile=cpu.out</span><br></pre></td></tr></table></figure>
<p>接着，我们可以使用 <code>go tool pprof</code> 来查看分析结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof cpu.out</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File: go-test.test</span><br><span class="line">Type: cpu</span><br><span class="line">Time: May 10, 2024 at 3:21pm (CST)</span><br><span class="line">Duration: 1.61s, Total samples = 1.24s (76.86%)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>top</code> 命令来查看 CPU 占用最高的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 1.24s, 100% of 1.24s total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     1.24s   100%   100%      1.24s   100%  go-test.fib</span><br><span class="line">         0     0%   100%      1.24s   100%  go-test.BenchmarkFib</span><br><span class="line">         0     0%   100%      1.24s   100%  testing.(*B).launch</span><br><span class="line">         0     0%   100%      1.24s   100%  testing.(*B).runN</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们也可以在 <code>top</code>
命令后面加上一个数字，表示显示前几个占用 CPU 时间最多的函数。比如
<code>top3</code> 表示显示前 3 个。</p>
</blockquote>
<p><strong>也就是说，我们可以通过 <code>pprof</code>
工具来查看哪些地方占用了比较多的 CPU
时间，从而进行性能优化。</strong></p>
<h2 id="内存性能测试及分析">内存性能测试及分析</h2>
<p>上一个例子中，我们并没有在函数中分配内存，我们使用下面这个例子来演示内存性能测试及分析。</p>
<p>需要测试的文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	nums := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		nums = <span class="built_in">append</span>(nums, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkItoa</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		test(<span class="number">1000</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行下面的命令来运行内存性能测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -benchmem -memprofile mem.out</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-test</span><br><span class="line">cpu: 12th Gen Intel(R) Core(TM) i7-12700F</span><br><span class="line">BenchmarkItoa-20          143871              8169 ns/op            8192 B/op          1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      go-test 1.266s</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在 <code>BenchmarkItoa</code> 这一行中，多了两列，其中
<code>8192 B/op</code> 表示每次操作（每次调用 <code>test</code>
函数）分配了 8192 字节的内存，<code>1 allocs/op</code>
表示每次操作分配了 1 次内存。</p>
<blockquote>
<p>这个输出对我们的意义是，尽量减少内存的分配，很多时候可以提高程序的性能。</p>
</blockquote>
<p>同样的，我们可以使用 <code>go tool pprof</code>
来查看内存分析结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof mem.out</span><br></pre></td></tr></table></figure>
<p>我们在交互模式下，可以使用 <code>top</code>
命令来查看内存分配最高的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 1.20GB, 100% of 1.20GB total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    1.20GB   100%   100%     1.20GB   100%  go-test.test</span><br><span class="line">         0     0%   100%     1.20GB   100%  go-test.BenchmarkItoa</span><br><span class="line">         0     0%   100%     1.20GB   100%  testing.(*B).launch</span><br><span class="line">         0     0%   100%     1.20GB   100%  testing.(*B).runN</span><br></pre></td></tr></table></figure>
<h2 id="通过-http-页面的方式展示性能测试结果">通过 http
页面的方式展示性能测试结果</h2>
<p>我们上面这两个例子还是过于简单了，在实际的项目中，函数调用可能会非常复杂，我们可以通过
<code>web</code> 界面来展示性能测试结果。同时，交互上也会更加友好。</p>
<p>比如，针对上面的
<code>mem.out</code>，我们可以使用下面的命令来启动一个 http 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof -http=:8081 mem.out</span><br></pre></td></tr></table></figure>
<p>接着，我们可以在浏览器中输入 <code>http://localhost:8081</code>
来查看性能测试结果：</p>
<p><img src="/images/go/unittest/pprof_web.png" /></p>
<p>除了直接看到的结果，还可以操作上面的菜单来实现不同的展示方式，比如选择
<code>VIEW-&gt;Top</code>，展示出来的是一个列表：</p>
<p><img src="/images/go/unittest/pprof_web_top.png" /></p>
<h2 id="pprof-的其他功能">pprof 的其他功能</h2>
<p>在我们使用 <code>go tool pprof</code>
的时候，还有很多其他的功能，比如：</p>
<ul>
<li><code>top</code>：查看 CPU 或内存占用最高的函数。上面有介绍。</li>
<li><code>list</code>：<code>list</code>
命令后跟函数名称以显示该函数的源代码，突出显示哪些代码占用了最多的 CPU
或内存，如下所示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list go-test.test</span><br><span class="line">Total: 1.20GB</span><br><span class="line">ROUTINE ======================== go-test.test in /Users/ruby/GolandProjects/go-test/fib_test.go</span><br><span class="line">    1.20GB     1.20GB (flat, cum)   100% of Total</span><br><span class="line">         .          .      9:func test(n int) []int &#123;</span><br><span class="line">         .          .     10:   rand.Seed(time.Now().UnixNano())</span><br><span class="line">    1.20GB     1.20GB     11:   nums := make([]int, 0, n)</span><br><span class="line">         .          .     12:   for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">         .          .     13:           nums = append(nums, i)</span><br><span class="line">         .          .     14:   &#125;</span><br><span class="line">         .          .     15:   return nums</span><br><span class="line">         .          .     16:&#125;</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure>
<ul>
<li><code>web</code>：<code>web</code>
命令可以在浏览器中打开一个页面，以图形的形式展示性能测试结果，如下</li>
</ul>
<p><img src="/images/go/unittest/pprof_web_web.png" /></p>
<ul>
<li><code>weblist</code>：<code>weblist</code>
命令可以在浏览器中打开一个页面，显示函数的源代码，突出显示哪些代码占用了最多的
CPU 或内存，如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// ... 其他内容</span><br><span class="line">/Users/ruby/GolandProjects/go-test/fib_test.go</span><br><span class="line"></span><br><span class="line">  Total:      1.20GB     1.20GB (flat, cum)   100%</span><br><span class="line">      6            .          .           	&quot;time&quot; </span><br><span class="line">      7            .          .           ) </span><br><span class="line">      8            .          .            </span><br><span class="line">      9            .          .           func test(n int) []int &#123; </span><br><span class="line">     10            .          .           	rand.Seed(time.Now().UnixNano()) </span><br><span class="line">     11       1.20GB     1.20GB           	nums := make([]int, 0, n) </span><br><span class="line">     12            .          .           	for i := 0; i &lt; n; i++ &#123; </span><br><span class="line">     13            .          .           		nums = append(nums, i) </span><br><span class="line">     14            .          .           	&#125; </span><br><span class="line">     15            .          .           	return nums </span><br><span class="line">// ... 其他内容</span><br></pre></td></tr></table></figure>
<ul>
<li><code>peek</code>：显示某一个函数的调用详情，如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(pprof) peek go-test.test</span><br><span class="line">Active filters:</span><br><span class="line">   show=go-test.test</span><br><span class="line">Showing nodes accounting for 1.20GB, 100% of 1.20GB total</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context              </span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            1.20GB   100% |   go-test.BenchmarkItoa</span><br><span class="line">    1.20GB   100%   100%     1.20GB   100%                | go-test.test</span><br><span class="line">----------------------------------------------------------+-------------</span><br></pre></td></tr></table></figure>
<ul>
<li><code>text</code>：以文本的形式展示性能分析结果，如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(pprof) text</span><br><span class="line">Active filters:</span><br><span class="line">   show=go-test.test</span><br><span class="line">Showing nodes accounting for 1.20GB, 100% of 1.20GB total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    1.20GB   100%   100%     1.20GB   100%  go-test.test</span><br><span class="line">         0     0%   100%     1.20GB   100%  go-test.BenchmarkItoa</span><br><span class="line">         0     0%   100%     1.20GB   100%  testing.(*B).launch</span><br><span class="line">         0     0%   100%     1.20GB   100%  testing.(*B).runN</span><br></pre></td></tr></table></figure>
<ul>
<li>各种形式的输出：<code>pprof</code> 还支持其他的输出形式，比如
<code>pdf</code>、<code>png</code>、<code>svg</code> 等，具体可以查看
<code>help</code> 命令。</li>
</ul>
<h2 id="testing.b-的其他方法">testing.B 的其他方法</h2>
<p>最后，再简单介绍一下 <code>testing.B</code> 的其他方法：</p>
<ul>
<li><code>b.ResetTimer()</code>：重置计时器，可以在测试函数中的循环体中使用，以避免循环体的初始化时间影响测试结果。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 模拟初始化时间，这一行代码不会计入测试时间</span></span><br><span class="line">  time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">  b.ResetTimer()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">    fib(<span class="number">20</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>b.StartTimer()</code>：负责启动计时并初始化内存相关计数，测试执行时会自动调用，一般不需要用户启动。</li>
<li><code>b.StopTimer()</code>：负责停止计时，并累加相应的统计值。</li>
<li><code>b.ReportAllocs()</code>：用于设置是否打印内存统计信息，与命令行参数
<code>-benchmem</code> 一致，但本方法只作用于单个测试函数。</li>
<li><code>b.SetParallelism(p int)</code>：设置并行测试的线程数，设置为
<code>p*GOMAXPROCS</code>。影响 <code>b.RunParallel</code>
的并行度。</li>
<li><code>b.RunParallel(body func(*PB))</code>：用于并行测试，<code>body</code>
函数会被并行执行，<code>b.N</code> 会被分配到各个并行体中。通常跟
<code>-cpu</code> 参数一起使用。</li>
</ul>
<blockquote>
<p>其他方法跟 <code>testing.T</code>
有很多重复的，这里不赘述了，可以看上一篇。</p>
</blockquote>
<h2 id="高阶用法">高阶用法</h2>
<h3 id="指定性能测试时间">指定性能测试时间</h3>
<p>可以通过 <code>-benchtime</code> 参数来指定性能测试的时间，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -benchtime=3s</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-test</span><br><span class="line">cpu: 12th Gen Intel(R) Core(TM) i7-12700F</span><br><span class="line">BenchmarkItoa-20          499718              7051 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      go-test 3.602s</span><br></pre></td></tr></table></figure>
<h3 id="指定性能测试执行次数也就是-b.n">指定性能测试执行次数，也就是
<code>b.N</code></h3>
<p>也是通过 <code>-benchtime</code> 参数来指定，但是单位是
<code>x</code>，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -benchtime=3x</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-test</span><br><span class="line">cpu: 12th Gen Intel(R) Core(TM) i7-12700F</span><br><span class="line">BenchmarkItoa-20               3             14378 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      go-test 0.005s</span><br></pre></td></tr></table></figure>
<h3 id="执行多次性能测试">执行多次性能测试</h3>
<p>可以通过 <code>-count</code> 参数来指定执行多少次性能测试，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -count=3</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-test</span><br><span class="line">cpu: 12th Gen Intel(R) Core(TM) i7-12700F</span><br><span class="line">BenchmarkItoa-20          166116              7187 ns/op</span><br><span class="line">BenchmarkItoa-20          165289              7168 ns/op</span><br><span class="line">BenchmarkItoa-20          161872              7146 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      go-test 3.765s</span><br></pre></td></tr></table></figure>
<h3 id="指定性能测试的-cpu-数">指定性能测试的 CPU 数</h3>
<p>可以通过 <code>-cpu</code> 参数来指定性能测试的 CPU 数，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -cpu=1,2,4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个命令会执行多次性能测试，分别使用 1、2、4 个 CPU（也就是
<code>GOMAXPROCS</code> 的值分别为 1、2、4）。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-test</span><br><span class="line">cpu: 12th Gen Intel(R) Core(TM) i7-12700F</span><br><span class="line">BenchmarkItoa             166363              7153 ns/op</span><br><span class="line">BenchmarkItoa-2           170436              7114 ns/op</span><br><span class="line">BenchmarkItoa-4           171088              6976 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      go-test 3.819s</span><br></pre></td></tr></table></figure>
<h3 id="输出内存分配信息">输出内存分配信息</h3>
<p>可以通过 <code>-benchmem</code> 参数来输出内存分配信息，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -benchmem</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-test</span><br><span class="line">cpu: 12th Gen Intel(R) Core(TM) i7-12700F</span><br><span class="line">BenchmarkItoa-20          163878              7081 ns/op             896 B/op          1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      go-test 1.240s</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2024/05/07/golang/Go%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/07/golang/Go%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Go 单元测试完全指南（一）- 基本测试流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-05-07 20:08:30" itemprop="dateCreated datePublished" datetime="2024-05-07T20:08:30+08:00">2024-05-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么写单元测试">为什么写单元测试？</h2>
<p>关于测试，有一张很经典的图，如下：</p>
<p><img src="/images/go/unittest/pyramid.webp" /></p>
<p>说明：</p>
<table>
<thead>
<tr class="header">
<th>测试类型</th>
<th>成本</th>
<th>速度</th>
<th>频率</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>E2E 测试</td>
<td>高</td>
<td>慢</td>
<td>低</td>
</tr>
<tr class="even">
<td>集成测试</td>
<td>中</td>
<td>中</td>
<td>中</td>
</tr>
<tr class="odd">
<td>单元测试</td>
<td>低</td>
<td>快</td>
<td>高</td>
</tr>
</tbody>
</table>
<p>也就是说，单元测试是最快、最便宜的测试方式。这不难理解，单元测试往往用来验证代码的最小单元，比如一个函数、一个方法，这样的测试我们一个命令就能跑完整个项目的单元测试，而且速度还很快，所以单元测试是我们最常用的测试方式。
而 E2E
测试和集成测试，往往需要启动整个项目，然后需要真实用户进行手动操作，这样的测试成本高，速度慢，所以我们往往不会频繁地运行这样的测试。只有在项目的最后阶段，我们才会运行这样的测试。而单元测试，我们可以在开发的过程中，随时随地地运行，这样我们就能及时发现问题，及时解决问题。</p>
<h2 id="一个基本的-go-单元测试">一个基本的 Go 单元测试</h2>
<p>Go 从一开始就支持单元测试，Go
的测试代码和普通代码一般是放在同一个包下的，只是测试代码的文件名是
<code>_test.go</code> 结尾的。比如我们有一个 <code>add.go</code>
文件，那么我们的测试文件就是 <code>add_test.go</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> Add(<span class="number">1</span>, <span class="number">2</span>) != <span class="number">3</span> &#123;</span><br><span class="line">		t.Error(<span class="string">&quot;1 + 2 did not equal 3&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过 <code>go test</code> 命令来运行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PASS</span><br><span class="line">ok      go-test 0.004s</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol type="1">
<li>测试函数的命名必须以 <code>Test</code>
开头，后面的名字必须以大写字母开头，比如 <code>TestAdd</code>。</li>
<li>测试函数的参数是 <code>*testing.T</code> 类型。</li>
<li><code>go test</code> 加上 <code>-v</code>
参数可以输出详细的测试信息，加上 <code>-cover</code>
参数可以输出测试覆盖率。</li>
</ol>
<h2 id="go-test-命令的参数详解">go test 命令的参数详解</h2>
<h3 id="基本参数">基本参数</h3>
<ul>
<li><code>-v</code>：输出详细的测试信息。比如输出每个测试用例的名称。</li>
<li><code>-run regexp</code>：只运行匹配正则表达式的测试用例。如
<code>-run TestAdd</code>。</li>
<li><code>-bench regexp</code>：运行匹配正则表达式的基准测试用例。</li>
<li><code>-benchtime t</code>：设置基准测试的时间，默认是
1s，也就是让基准测试运行
1s。<strong>也可以指定基准测试的执行次数，格式如
<code>-benchtime 100x</code>，表示基准测试执行 100 次。</strong></li>
<li><code>-count n</code>：运行每个测试函数的次数，默认是 1
次。如果指定了 <code>-cpu</code> 参数，那么每个测试函数会运行
<code>n * GOMAXPROCS</code>
次。但是示例测试只会运行一次，该参数对模糊测试无效。</li>
<li><code>-cover</code>：输出测试覆盖率。</li>
<li><code>-covermode set,count,atomic</code>：设置测试覆盖率的模式。默认是
<code>set</code>，也就是记录哪些语句被执行过。</li>
<li><code>-coverpkg pkg1,pkg2,pkg3</code>：用于指定哪些包应该生成覆盖率信息。这个参数允许你指定一个或多个包的模式，以便在运行测试时生成这些包的覆盖率信息。</li>
<li><code>-cpu 1,2,4</code>：设置并行测试的 CPU 数量。默认是
GOMAXPROCS。这个参数对模糊测试无效。</li>
<li><code>-failfast</code>：一旦某个测试函数失败，就停止运行其他的测试函数了。默认情况下，一个测试函数失败了，其他的测试函数还会继续运行。</li>
<li><code>-fullpath</code>：测试失败的时候，输出完整的文件路径。</li>
<li><code>-fuzz regexp</code>：运行模糊测试。</li>
<li><code>-fuzztime t</code>：设置模糊测试的时间，默认是
1s。又或者我们可以指定模糊测试的执行次数，格式如
<code>-fuzztime 100x</code>，表示模糊测试执行 100 次。</li>
<li><code>-fuzzminimizetime t</code>：设置模糊测试的最小化时间，默认是
1s。又或者我们可以指定模糊测试的最小化执行次数，格式如
<code>-fuzzminimizetime 100x</code>，表示模糊测试最小化执行 100
次。<strong>在模糊测试中，当发现一个失败的案例后，系统会尝试最小化这个失败案例，以找到导致失败的最小输入。</strong></li>
<li><code>-json</code>：以 json 格式输出</li>
<li><code>-list regexp</code>：列出所有匹配正则表达式的测试用例名称。</li>
<li><code>-parallel n</code>：设置并行测试的数量。默认是
GOMAXPROCS。</li>
<li><code>-run regexp</code>：只运行匹配正则表达式的测试用例。</li>
<li><code>-short</code>：缩短长时间运行的测试的测试时间。默认关闭。</li>
<li><code>-shuffle off,on,N</code>：打乱测试用例的执行顺序。默认是
<code>off</code>，也就是不打乱，这会由上到下执行测试函数。</li>
<li><code>-skip regexp</code>：跳过匹配正则表达式的测试用例。</li>
<li><code>-timeout t</code>：设置测试的超时时间，默认是 10m，也就是 10
分钟。<strong>如果测试函数在超时时间内没有执行完，那么测试会
<code>panic</code>。</strong></li>
<li><code>-vet list</code>：设置 <code>go vet</code> 的检查列表。默认是
<code>all</code>，也就是检查所有的。</li>
</ul>
<h3 id="性能相关">性能相关</h3>
<ul>
<li><code>-benchmem</code>：输出基准测试的内存分配情况（也就是
<code>go test -bench .</code>
的时候可以显示每次基准测试分配的内存）。</li>
<li><code>-blockprofile block.out</code>：输出阻塞事件的分析数据。</li>
<li><code>-blockprofilerate n</code>：设置阻塞事件的采样频率。默认是
1（单位纳秒）。如果没有设置采样频率，那么就会记录所有的阻塞事件。</li>
<li><code>-coverprofile coverage.out</code>：输出测试覆盖率到文件
<code>coverage.out</code>。</li>
<li><code>-cpuprofile cpu.out</code>：输出 CPU 性能分析信息到文件
<code>cpu.out</code>。</li>
<li><code>-memprofile mem.out</code>：输出内存分析信息到文件
<code>mem.out</code>。</li>
<li><code>-memprofilerate n</code>：设置内存分析的采样频率。</li>
<li><code>-mutexprofile mutex.out</code>：输出互斥锁事件的分析数据。</li>
<li><code>-mutexprofilefraction n</code>：设置互斥锁事件的采样频率。</li>
<li><code>-outputdir directory</code>：设置输出文件的目录。</li>
<li><code>-trace trace.out</code>：输出跟踪信息到文件
<code>trace.out</code>。</li>
</ul>
<h2 id="子测试">子测试</h2>
<p>使用场景：当我们有多个测试用例的时候，我们可以使用子测试来组织测试代码，使得测试代码更具组织性和可读性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		name      <span class="type">string</span></span><br><span class="line">		a, b, sum <span class="type">int</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;<span class="string">&quot;case1&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;case2&quot;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;case3&quot;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		t.Run(c.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">			sum := Add(c.a, c.b)</span><br><span class="line">			<span class="keyword">if</span> sum != c.sum &#123;</span><br><span class="line">				t.Errorf(<span class="string">&quot;Sum was incorrect, got: %d, want: %d.&quot;</span>, sum, c.sum)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  go-test go test   </span><br><span class="line">--- FAIL: TestAdd2 (0.00s)</span><br><span class="line">    --- FAIL: TestAdd2/case1 (0.00s)</span><br><span class="line">        add_test.go:21: Sum was incorrect, got: 4, want: 3.</span><br><span class="line">    --- FAIL: TestAdd2/case2 (0.00s)</span><br><span class="line">        add_test.go:21: Sum was incorrect, got: 6, want: 5.</span><br><span class="line">    --- FAIL: TestAdd2/case3 (0.00s)</span><br><span class="line">        add_test.go:21: Sum was incorrect, got: 8, want: 7.</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    go-test 0.004s</span><br></pre></td></tr></table></figure>
<p>我们可以看到，上面的输出中，失败的单元测试带有每个子测试的名称，这样我们就能很方便地知道是哪个测试用例失败了。</p>
<h2 id="setup-和-teardown">setup 和 teardown</h2>
<p>在一般的单元测试框架中，都会提供 <code>setup</code> 和
<code>teardown</code> 的功能，<code>setup</code>
用来初始化测试环境，<code>teardown</code> 用来清理测试环境。</p>
<h3 id="方法一通过-go-的-testmain-方法">方法一：通过 Go 的 TestMain
方法</h3>
<p>很遗憾的是，Go 的测试框架并没有直接提供这样的功能，但是我们可以通过
Go 的特性来实现这样的功能。</p>
<p><strong>在 Go 的测试文件中，如果有 <code>TestMain</code>
函数，那么执行 <code>go test</code>
的时候会执行这个函数，而不会执行其他测试函数了，其他的测试函数需要通过
<code>m.Run</code> 来执行</strong>，如下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;setup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;teardown&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> Add(<span class="number">1</span>, <span class="number">2</span>) != <span class="number">3</span> &#123;</span><br><span class="line">		t.Error(<span class="string">&quot;1 + 2 != 3&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">	setup()</span><br><span class="line">	code := m.Run()</span><br><span class="line">	teardown()</span><br><span class="line">	os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们在 <code>TestMain</code> 函数中调用了
<code>setup</code> 和 <code>teardown</code> 函数，这样我们就实现了
<code>setup</code> 和 <code>teardown</code> 的功能。</p>
<h3 id="方法二使用-testify-框架">方法二：使用 <code>testify</code>
框架</h3>
<p>我们也可以使用 Go 中的第三方测试框架 <code>testify</code> 来实现
<code>setup</code> 和 <code>teardown</code> 的功能（使用
<code>testify</code> 中的 <code>suite</code> 功能）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/stretchr/testify/suite&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddSuite <span class="keyword">struct</span> &#123;</span><br><span class="line">	suite.Suite</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(suite *AddSuite)</span></span> SetupTest() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Before test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(suite *AddSuite)</span></span> TearDownTest() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;After test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(suite *AddSuite)</span></span> TestAdd() &#123;</span><br><span class="line">	suite.Equal(Add(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAddSuite</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	suite.Run(t, <span class="built_in">new</span>(AddSuite))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>go test</code> 输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  go-test go test</span><br><span class="line">Before test</span><br><span class="line">After test</span><br><span class="line">--- FAIL: TestAddSuite (0.00s)</span><br><span class="line">    --- FAIL: TestAddSuite/TestAdd (0.00s)</span><br><span class="line">        add_test.go:22: </span><br><span class="line">                Error Trace:    /Users/ruby/GolandProjects/go-test/add_test.go:22</span><br><span class="line">                Error:          Not equal: </span><br><span class="line">                                expected: 4</span><br><span class="line">                                actual  : 3</span><br><span class="line">                Test:           TestAddSuite/TestAdd</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    go-test 0.006s</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这里也同样执行了 <code>SetupTest</code> 和
<code>TearDownTest</code> 函数。</p>
<h2 id="testing.t-可用的方法">testing.T 可用的方法</h2>
<p>最后，我们可以直接从 <code>testing.T</code> 提供的 API
来学习如何编写测试代码。</p>
<h3 id="基本日志输出">基本日志输出</h3>
<ul>
<li><code>t.Log(args ...any)</code>：打印信息，不会标记测试函数为失败。</li>
<li><code>t.Logf(format string, args ...any)</code>：打印格式化的信息，不会标记测试函数为失败。</li>
</ul>
<p>可能有读者会有疑问，输出不用 <code>fmt</code> 而用
<code>t.Log</code>，这是因为：</p>
<ul>
<li><code>t.Log</code> 和 <code>t.Logf</code>
打印的信息默认不会显示，只有在测试函数失败的时候才会显示。又或者我们使用
<code>-v</code>
参数的时候才显示，这让我们的测试输出更加清晰，只有必要的时候日志才会显示。</li>
<li><code>t.Log</code> 和 <code>t.Logf</code>
打印的时候，还会显示是哪一行代码打印的信息，这样我们就能很方便地定位问题。</li>
<li><code>fmt.Println</code>
打印的信息一定会显示在控制台上，就算我们的测试函数通过了，也会显示，这样会让控制台的输出很乱。</li>
</ul>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Log(<span class="string">&quot;TestAdd is running&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> Add(<span class="number">1</span>, <span class="number">2</span>) != <span class="number">3</span> &#123;</span><br><span class="line">		t.Error(<span class="string">&quot;Expected 3&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  go-test go test</span><br><span class="line">PASS</span><br><span class="line">ok      go-test 0.004s</span><br></pre></td></tr></table></figure>
<p>我们修改一下 <code>Add</code>
函数，让测试失败，再次运行，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  go-test go test</span><br><span class="line">--- FAIL: TestAdd (0.00s)</span><br><span class="line">    add_test.go:8: TestAdd is running</span><br><span class="line">    add_test.go:10: Expected 3</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    go-test 0.004s</span><br></pre></td></tr></table></figure>
<p>我们可以发现，在测试成功的时候，<code>t.Log</code>
打印的日志并没有显示，只有在测试失败的时候才会显示。</p>
<p>如果我们想要在测试成功的时候也显示日志，可以使用 <code>-v</code>
参数：<code>go test -v</code>。</p>
<h3 id="标记测试函数为失败">标记测试函数为失败</h3>
<ul>
<li><code>t.Fail()</code>：标记测试函数为失败，但是测试函数后续代码会继续执行。（让你在测试函数中标记失败情况，并收集所有失败的情况，而不是在遇到第一个失败时就立即停止测试函数的执行。）</li>
<li><code>t.FailNow()</code>：标记测试函数为失败，并立即返回，后续代码不会执行（通过调用
<code>runtime.Goexit</code>，但是 <code>defer</code>
语句还是会被执行）。</li>
<li><code>t.Failed()</code>：返回测试函数是否失败。</li>
<li><code>t.Fatal(args ...any)</code>：标记测试函数为失败，并输出信息，然后立即返回。等价于
<code>t.Log</code> + <code>t.FailNow</code>。</li>
<li><code>t.Fatalf(format string, args ...any)</code>：标记测试函数为失败，并输出格式化的信息，然后立即返回。等价于
<code>t.Logf</code> + <code>t.FailNow</code>。</li>
</ul>
<p>如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> Add(<span class="number">1</span>, <span class="number">2</span>) != <span class="number">3</span> &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;Expected 3&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> Add(<span class="number">2</span>, <span class="number">3</span>) != <span class="number">5</span> &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;Expected 4&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只会输出第一个失败的测试用例，因为 <code>t.Fatal</code>
会立即返回。</p>
<h3 id="标记测试函数为失败并输出信息">标记测试函数为失败并输出信息</h3>
<ul>
<li><code>t.Error(args ...any)</code>：标记测试函数为失败，并打印错误信息。等价于
<code>t.Log</code> + <code>t.Fail</code>。</li>
<li><code>t.Errorf(format string, args ...any)</code>：标记测试函数为失败，并打印格式化的错误信息。等价于
<code>t.Logf</code> + <code>t.Fail</code>。</li>
</ul>
<p>这两个方法会让测试函数立即返回，不会继续执行后面的代码。</p>
<h3 id="测试超时控制">测试超时控制</h3>
<ul>
<li><code>t.Deadline()</code>：返回测试函数的截止时间（这是通过
<code>go test -timeout 60s</code> 这种形式指定的超时时间）。</li>
</ul>
<blockquote>
<p>注意：如果我们通过 <code>-timeout</code>
指定了超时时间，当测试函数超时的时候，测试会 <code>panic</code>。</p>
</blockquote>
<h3 id="跳过测试函数中后续代码">跳过测试函数中后续代码</h3>
<p>作用：可以帮助测试代码在特定条件下灵活地跳过测试，避免不必要的测试执行，同时提供清晰的信息说明为什么跳过测试。</p>
<ul>
<li><code>t.Skip(args ...any)</code>：跳过测试函数中后续代码，标记测试函数为跳过。等同于
<code>t.Log</code> + <code>t.SkipNow</code>。</li>
<li><code>t.Skipf(format string, args ...any)</code>：跳过测试函数中后续代码，并打印格式化的跳过信息。等同于
<code>t.Logf</code> + <code>t.SkipNow</code>。</li>
<li><code>t.SkipNow()</code>：跳过测试函数中后续代码，标记测试函数为跳过。<strong>这个方法不会输出内容，前面两个会输出一些信息</strong></li>
<li><code>t.Skipped()</code>：返回测试函数是否被跳过。</li>
</ul>
<h3 id="测试清理函数">测试清理函数</h3>
<ul>
<li><code>t.Cleanup(f func())</code>：注册一个函数，这个函数会在测试函数结束后执行。这个函数会在测试函数结束后执行，不管测试函数是否失败，都会执行。（可以注册多个，执行顺序类似
<code>defer</code>，后注册的先执行）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Cleanup(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;cleanup 0&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	t.Cleanup(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;cleanup 1&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  go-test go test</span><br><span class="line">cleanup 1</span><br><span class="line">cleanup 0</span><br><span class="line">PASS</span><br><span class="line">ok      go-test 0.004s</span><br></pre></td></tr></table></figure>
<h3 id="使用临时文件夹">使用临时文件夹</h3>
<ul>
<li><code>t.TempDir()</code>：返回一个临时文件夹，这个文件夹会在测试函数结束后被删除。可以调用多次，每次都是不同的文件夹。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(t.TempDir())</span><br><span class="line">	fmt.Println(t.TempDir())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  go-test go test</span><br><span class="line">/var/folders/dm/r_hly4w5557b000jh31_43gh0000gp/T/TestAdd4259799402/001</span><br><span class="line">/var/folders/dm/r_hly4w5557b000jh31_43gh0000gp/T/TestAdd4259799402/002</span><br><span class="line">PASS</span><br><span class="line">ok      go-test 0.004s</span><br></pre></td></tr></table></figure>
<h3 id="临时的环境变量">临时的环境变量</h3>
<ul>
<li><code>t.Setenv(key, value string)</code>：设置一个临时的环境变量，这个环境变量会在测试函数结束后被还原。</li>
</ul>
<p>在单元测试中，使用 <code>Setenv</code>
函数可以模拟不同的环境变量设置，从而测试代码在不同环境下的行为。例如，你可以在测试中设置特定的环境变量值，然后运行被测试的代码，以验证代码在这些环境变量设置下的正确性。</p>
<h3 id="子测试-1">子测试</h3>
<p>可以将一个大的测试函数拆分成多个子测试，使得测试代码更具组织性和可读性。</p>
<ul>
<li><code>t.Run(name string, f func(t *testing.T))</code>：创建一个子测试，这个子测试会在父测试中执行。子测试可以有自己的测试函数，也可以有自己的子测试。</li>
</ul>
<h3 id="获取当前测试的名称">获取当前测试的名称</h3>
<ul>
<li><code>t.Name()</code>：返回当前测试的名称（也就是测试函数名）。</li>
</ul>
<h3 id="t.helper">t.Helper()</h3>
<ul>
<li><code>t.Helper()</code>：标记当前测试函数是一个辅助函数，这样会让测试输出更加清晰，只有真正的测试函数会被标记为失败。</li>
</ul>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a, b, sum <span class="type">int</span>, t *testing.T)</span></span> &#123;</span><br><span class="line">	result := Add(a, b)</span><br><span class="line">	<span class="keyword">if</span> result != sum &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;Add(%d, %d) = %d; want %d&quot;</span>, a, b, result, sum)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, t)</span><br><span class="line">	test(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  go-test go test -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">    add_test.go:10: Add(1, 2) = 4; want 3</span><br><span class="line">    add_test.go:10: Add(2, 3) = 6; want 5</span><br><span class="line">--- FAIL: TestAdd (0.00s)</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    go-test 0.004s</span><br></pre></td></tr></table></figure>
<p>我们可以看到，两个测试失败输出的报错行都是 <code>test</code>
函数里面的 <code>t.Errorf</code>，而不是 <code>test</code> 函数的调用者
<code>TestAdd</code>，也就是说，在这种情况下我们不好知道是
<code>test(1, 2, 3, t)</code> 还是 <code>test(2, 3, 5, t)</code>
失败了（当然我们这里还是挺明显的，只是举个例子），这时我们可以使用
<code>t.Helper()</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a, b, sum <span class="type">int</span>, t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Helper() <span class="comment">// 在助手函数中加上这一行</span></span><br><span class="line">	result := Add(a, b)</span><br><span class="line">	<span class="keyword">if</span> result != sum &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;Add(%d, %d) = %d; want %d&quot;</span>, a, b, result, sum)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  go-test go test -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">    add_test.go:16: Add(1, 2) = 4; want 3</span><br><span class="line">    add_test.go:17: Add(2, 3) = 6; want 5</span><br><span class="line">--- FAIL: TestAdd (0.00s)</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    go-test 0.004s</span><br></pre></td></tr></table></figure>
<p>这个时候，我们就很容易知道是哪一个测试用例失败了，这对于我们需要封装
helper 函数的时候很有用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2024/05/05/JavaScript/pm2%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/05/JavaScript/pm2%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">pm2 配置文件说明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-05-05 20:01:00" itemprop="dateCreated datePublished" datetime="2024-05-05T20:01:00+08:00">2024-05-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如果我们想使用 pm2 来管理多个应用，可以通过配置文件来实现。</p>
<h2 id="初始化配置文件">初始化配置文件</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 init simple</span><br></pre></td></tr></table></figure>
<p>这个命令会在当前目录下生成一个 <code>ecosystem.config.js</code>
文件，这个文件就是 pm2 的配置文件。</p>
<p>文件内容大概如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  apps : [&#123;</span><br><span class="line">    name   : <span class="string">&quot;app1&quot;</span>,</span><br><span class="line">    script : <span class="string">&quot;./app.js&quot;</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据配置文件来管理应用">根据配置文件来管理应用</h2>
<ul>
<li>pm2 reload
重新加载应用程序，但不会停止正在运行的应用程序实例。它会重新启动应用程序，但在新实例准备就绪之前，旧实例将继续提供服务。这意味着在应用程序重新加载期间，可能会有短暂的服务中断。</li>
<li>pm2 restart
停止当前运行的应用程序实例，并启动一个新的实例来替代它。这意味着在重启过程中会有一个短暂的服务中断，因为在新实例启动之前，旧实例将停止提供服务。</li>
</ul>
<h3 id="启动所有应用">启动所有应用</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ecosystem.config.js</span><br></pre></td></tr></table></figure>
<h3 id="停止所有应用">停止所有应用</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 stop ecosystem.config.js</span><br></pre></td></tr></table></figure>
<h3 id="重启所有应用">重启所有应用</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 restart ecosystem.config.js</span><br></pre></td></tr></table></figure>
<h3 id="重载所有应用">重载所有应用</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 reload ecosystem.config.js</span><br></pre></td></tr></table></figure>
<h3 id="删除所有应用">删除所有应用</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 delete ecosystem.config.js</span><br></pre></td></tr></table></figure>
<h2 id="启动特定应用">启动特定应用</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ecosystem.config.js --only app1</span><br></pre></td></tr></table></figure>
<p>指定多个：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ecosystem.config.js --only app1,app2</span><br></pre></td></tr></table></figure>
<h2 id="不同的环境env">不同的环境（env）</h2>
<p>你可以通过 <code>env_*</code> 来指定不同的环境，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  apps : [&#123;</span><br><span class="line">    name   : <span class="string">&quot;app1&quot;</span>,</span><br><span class="line">    script : <span class="string">&quot;./app.js&quot;</span>,</span><br><span class="line">    <span class="attr">env_production</span>: &#123;</span><br><span class="line">       <span class="attr">NODE_ENV</span>: <span class="string">&quot;production&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">env_development</span>: &#123;</span><br><span class="line">       <span class="attr">NODE_ENV</span>: <span class="string">&quot;development&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后启动时指定环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ecosystem.config.js --env production</span><br><span class="line">pm2 start ecosystem.config.js --env development</span><br></pre></td></tr></table></figure>
<h2 id="配置项详解">配置项详解</h2>
<table>
<thead>
<tr class="header">
<th>配置项</th>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>string</td>
<td>"app1"</td>
<td>应用名称</td>
</tr>
<tr class="even">
<td>script</td>
<td>string</td>
<td>"./app.js"</td>
<td>启动脚本</td>
</tr>
<tr class="odd">
<td>cwd</td>
<td>string</td>
<td>"/path/to/app"</td>
<td>启动应用程序的目录</td>
</tr>
<tr class="even">
<td>args</td>
<td>string</td>
<td>"-a 13 -b 12"</td>
<td>传递给脚本的参数</td>
</tr>
<tr class="odd">
<td>interpreter</td>
<td>string</td>
<td>"/usr/bin/python"</td>
<td>解释器</td>
</tr>
<tr class="even">
<td>interpreter_args</td>
<td>string</td>
<td>"-u"</td>
<td>传递给解释器的参数</td>
</tr>
</tbody>
</table>
<h3 id="高级配置项">高级配置项</h3>
<ul>
<li>exec_mode 说明：
<ul>
<li>在 fork
模式下，每个应用程序实例都在单独的进程中运行。这意味着每个应用程序实例都有自己的内存空间和资源。</li>
<li>在 cluster 模式下，应用程序会以集群的方式运行，使用 Node.js 的
cluster
模块来创建多个子进程。这些子进程共享同一个端口，可以充分利用多核处理器的优势。</li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>配置项</th>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>instances</td>
<td>number</td>
<td>4</td>
<td>启动多少个实例</td>
</tr>
<tr class="even">
<td>exec_mode</td>
<td>string</td>
<td>"cluster"</td>
<td>执行模式，默认 fork</td>
</tr>
<tr class="odd">
<td>watch</td>
<td>boolean</td>
<td>true</td>
<td>是否监视文件变化，文件变动的时候重启进程</td>
</tr>
<tr class="even">
<td>ignore_watch</td>
<td>array</td>
<td>["node_modules", "logs"]</td>
<td>忽略监视的文件或目录</td>
</tr>
<tr class="odd">
<td>max_memory_restart</td>
<td>string</td>
<td>"1G"</td>
<td>当内存使用超过多少时重启进程</td>
</tr>
<tr class="even">
<td>env</td>
<td>object</td>
<td>{ NODE_ENV: "development" }</td>
<td>环境变量</td>
</tr>
<tr class="odd">
<td>env_production</td>
<td>object</td>
<td>{ NODE_ENV: "production" }</td>
<td>生产环境的环境变量，当指定 --env 参数的时候生效</td>
</tr>
<tr class="even">
<td>appendEnvToName</td>
<td>boolean</td>
<td>true</td>
<td>是否将环境变量追加到应用名称后面</td>
</tr>
</tbody>
</table>
<h3 id="日志配置">日志配置</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>配置项</th>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>log_date_format</td>
<td>string</td>
<td>"YYYY-MM-DD HH:mm Z"</td>
<td>日志日期格式</td>
</tr>
<tr class="even">
<td>error_file</td>
<td>string</td>
<td>"/path/to/error.log"</td>
<td>错误日志文件，默认
<code>$HOME/.pm2/logs/&lt;app name&gt;-error-&lt;pid&gt;.log</code></td>
</tr>
<tr class="odd">
<td>out_file</td>
<td>string</td>
<td>"/path/to/out.log"</td>
<td>标准输出日志文件，默认
<code>$HOME/.pm2/logs/&lt;app name&gt;-out-&lt;pid&gt;.log</code></td>
</tr>
<tr class="even">
<td>log_file</td>
<td>string</td>
<td>"/path/to/combined.log"</td>
<td>组合日志文件（标准输出+错误输出）</td>
</tr>
<tr class="odd">
<td>pid_file</td>
<td>string</td>
<td>"/path/to/pid"</td>
<td>pid 文件，默认
<code>$HOME/.pm2/pids/&lt;app name&gt;-&lt;pid&gt;.pid</code></td>
</tr>
<tr class="even">
<td>combine_logs</td>
<td>boolean</td>
<td>true</td>
<td>日志文件名不添加 pid 后缀</td>
</tr>
<tr class="odd">
<td>time</td>
<td>boolean</td>
<td>true</td>
<td>在日志中添加时间戳</td>
</tr>
</tbody>
</table>
<h3 id="控制流程">控制流程</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>配置项</th>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>min_uptime</td>
<td>number</td>
<td>1000</td>
<td>应用程序在多少毫秒内被认为是启动成功的</td>
</tr>
<tr class="even">
<td>listen_timeout</td>
<td>number</td>
<td>8000</td>
<td>应用程序启动后多少毫秒没有监听端口就认为启动失败</td>
</tr>
<tr class="odd">
<td>kill_timeout</td>
<td>number</td>
<td>1600</td>
<td>pm2 发送 kill 信号给应用程序后多少毫秒后强制杀死进程</td>
</tr>
<tr class="even">
<td>shutdown_with_message</td>
<td>boolean</td>
<td>false</td>
<td>是否在关闭进程时发送消息给进程</td>
</tr>
<tr class="odd">
<td>wait_ready</td>
<td>boolean</td>
<td>false</td>
<td></td>
</tr>
<tr class="even">
<td>max_restarts</td>
<td>number</td>
<td>10</td>
<td>启动失败之后，最大重试次数</td>
</tr>
<tr class="odd">
<td>autorestart</td>
<td>boolean</td>
<td>true</td>
<td>是否自动重启</td>
</tr>
<tr class="even">
<td>cron_restart</td>
<td>string</td>
<td>"0 0 * * *"</td>
<td>定时重启，参考 <a target="_blank" rel="noopener" href="https://crontab.guru/">cron</a></td>
</tr>
<tr class="odd">
<td>vizion</td>
<td>boolean</td>
<td>false</td>
<td>是否启用版本控制</td>
</tr>
<tr class="even">
<td>post_update</td>
<td>list</td>
<td>["npm install"]</td>
<td>更新后执行的命令</td>
</tr>
<tr class="odd">
<td>force</td>
<td>boolean</td>
<td>false</td>
<td>强制启动应用程序</td>
</tr>
</tbody>
</table>
<h3 id="部署">部署</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>配置项</th>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>key</td>
<td>string</td>
<td>"/path/to/key"</td>
<td>ssh 私钥</td>
</tr>
<tr class="even">
<td>user</td>
<td>string</td>
<td></td>
<td>ssh 用户名</td>
</tr>
<tr class="odd">
<td>host</td>
<td>string</td>
<td></td>
<td>ssh 主机</td>
</tr>
<tr class="even">
<td>ssh_options</td>
<td>object</td>
<td>{ "StrictHostKeyChecking": "no" }</td>
<td>ssh 选项</td>
</tr>
<tr class="odd">
<td>ref</td>
<td>string</td>
<td>"origin/master"</td>
<td>git 分支</td>
</tr>
<tr class="even">
<td>repo</td>
<td>string</td>
<td></td>
<td>git 仓库</td>
</tr>
<tr class="odd">
<td>path</td>
<td>string</td>
<td>"/path/to/deploy"</td>
<td>部署路径</td>
</tr>
<tr class="even">
<td>pre-setup</td>
<td>string</td>
<td>"echo 'commands or script to run before setup on target host'"</td>
<td>部署前执行的命令</td>
</tr>
<tr class="odd">
<td>post-setup</td>
<td>string</td>
<td>"echo 'commands or script to run after setup on target host'"</td>
<td>部署后执行的命令</td>
</tr>
<tr class="even">
<td>pre-deploy-local</td>
<td>string</td>
<td>"echo 'commands or script to run on local machine before the setup
process starts'"</td>
<td>本地部署前执行的命令</td>
</tr>
<tr class="odd">
<td>post-deploy</td>
<td>string</td>
<td>"echo 'commands or script to run on target host after the deploy
process finishes'"</td>
<td>部署后执行的命令</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/70/">70</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">eleven26</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eleven26" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
