<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eleven26.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文基于 Go 1.19  Pool 是一组可以安全在多个 goroutine 间共享的临时对象的集合。 存储在 Pool 中的任何项目都可能在任何时候被移除，因此 Pool 不适合保存那些有状态的对象，如数据库连接、TCP 连接等。 Pool 的目的是缓存已分配但未使用的项以供以后使用，从而减少垃圾收集器的压力。 也就是说，它可以轻松构建高效、线程安全的空闲列表，但是，它并不适用于所有空闲列表">
<meta property="og:type" content="article">
<meta property="og:title" content="go sync.Pool 设计与实现">
<meta property="og:url" content="https://eleven26.github.io/2023/03/22/golang/go%20sync.Pool%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="eleven26">
<meta property="og:description" content="本文基于 Go 1.19  Pool 是一组可以安全在多个 goroutine 间共享的临时对象的集合。 存储在 Pool 中的任何项目都可能在任何时候被移除，因此 Pool 不适合保存那些有状态的对象，如数据库连接、TCP 连接等。 Pool 的目的是缓存已分配但未使用的项以供以后使用，从而减少垃圾收集器的压力。 也就是说，它可以轻松构建高效、线程安全的空闲列表，但是，它并不适用于所有空闲列表">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_1.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_2.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_3.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_4.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_5.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_6.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_7.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_8.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_9.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_10.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_11.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_12.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_dequeue.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_10.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_13.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_14.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_15.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_16.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_17.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/sync_pool/pool_18.png">
<meta property="article:published_time" content="2023-03-22T12:28:30.000Z">
<meta property="article:modified_time" content="2023-03-22T09:04:21.000Z">
<meta property="article:author" content="eleven26">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eleven26.github.io/images/go/sync_pool/pool_1.png">


<link rel="canonical" href="https://eleven26.github.io/2023/03/22/golang/go%20sync.Pool%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://eleven26.github.io/2023/03/22/golang/go%20sync.Pool%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/","path":"2023/03/22/golang/go sync.Pool 设计与实现/","title":"go sync.Pool 设计与实现"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go sync.Pool 设计与实现 | eleven26</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">eleven26</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">100</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">346</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.</span> <span class="nav-text">使用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gin-%E9%87%8C%E9%9D%A2-context-%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8-pool-%E4%BF%9D%E5%AD%98"><span class="nav-number">1.1.</span> <span class="nav-text">gin 里面 Context 对象使用
Pool 保存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fmt-%E9%87%8C%E9%9D%A2%E7%9A%84-pp-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.2.</span> <span class="nav-text">fmt 里面的 pp 结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pool-%E6%95%B4%E4%BD%93%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">Pool 整体模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pool-%E7%9A%84%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E6%98%AF%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E8%BF%98%E6%98%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">Pool
的双端队列是使用数组还是链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pool-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8"><span class="nav-number">2.2.</span> <span class="nav-text">Pool 为什么要用数组 + 链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">2.3.</span> <span class="nav-text">数组如何实现队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poolchain-%E7%9A%84%E6%9C%80%E7%BB%88%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.4.</span> <span class="nav-text">poolChain 的最终模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA-p-%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84-poolchain"><span class="nav-number">2.5.</span> <span class="nav-text">多个 P 的情况下的 poolChain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84-pool"><span class="nav-number">2.6.</span> <span class="nav-text">最终实现中的 Pool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pool-%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="nav-number">2.7.</span> <span class="nav-text">Pool 模型总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pool-%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">3.</span> <span class="nav-text">Pool 中的结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sync.pool-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">3.1.</span> <span class="nav-text">sync.Pool 结构体：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pool-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.1.</span> <span class="nav-text">Pool 获取对象的流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poollocal-%E5%92%8C-poollocalinternal-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">3.2.</span> <span class="nav-text">poolLocal 和
poolLocalInternal 结构体：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poolchainpoolchainelt-%E5%92%8C-pooldequeue-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">3.3.</span> <span class="nav-text">poolChain、poolChainElt
和 poolDequeue 结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pool-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">Pool 源码剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#get"><span class="nav-number">4.1.</span> <span class="nav-text">Get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getslow-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">4.2.</span> <span class="nav-text">getSlow 源码剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pin-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">4.3.</span> <span class="nav-text">pin 源码剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#indexlocal-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">4.3.1.</span> <span class="nav-text">indexLocal 源码剖析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#allpools-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.4.</span> <span class="nav-text">allPools 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put"><span class="nav-number">4.5.</span> <span class="nav-text">Put</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new"><span class="nav-number">4.6.</span> <span class="nav-text">New</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#poolchain-%E5%92%8C-pooldequeue-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">5.</span> <span class="nav-text">poolChain 和 poolDequeue
源码剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pushhead"><span class="nav-number">5.1.</span> <span class="nav-text">pushHead</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pophead"><span class="nav-number">5.2.</span> <span class="nav-text">popHead</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poptail"><span class="nav-number">5.3.</span> <span class="nav-text">popTail</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sync.pool-%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%82%B9"><span class="nav-number">6.</span> <span class="nav-text">sync.Pool 设计要点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eleven26</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eleven26" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eleven26" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2023/03/22/golang/go%20sync.Pool%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="go sync.Pool 设计与实现 | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go sync.Pool 设计与实现
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-22 20:28:30" itemprop="dateCreated datePublished" datetime="2023-03-22T20:28:30+08:00">2023-03-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>本文基于 Go 1.19</p>
</blockquote>
<p><code>Pool</code> 是一组可以安全在多个 <code>goroutine</code>
间共享的临时对象的集合。 存储在 <code>Pool</code>
中的任何项目都可能在任何时候被移除，因此 <code>Pool</code>
不适合保存那些有状态的对象，如数据库连接、TCP 连接等。 <code>Pool</code>
的目的是缓存已分配但未使用的项以供以后使用，从而减少垃圾收集器的压力。
也就是说，它可以轻松构建高效、线程安全的空闲列表，但是，它并不适用于所有空闲列表。</p>
<h2 id="使用实例">使用实例</h2>
<p>下面以几个实际的例子来说明 <code>Pool</code> 的一些使用场景。
下面是两个非常典型的使用场景，但是在实际使用中，对于那些需要频繁创建和销毁的对象的场景，我们都可以考虑使用
<code>Pool</code>。</p>
<h3 id="gin-里面-context-对象使用-pool-保存">gin 里面 Context 对象使用
Pool 保存</h3>
<p>在 <code>gin</code> 的 <code>Engine</code> 结构体中的
<code>ServeHTTP</code> 方法中，可以看到 <code>Context</code> 对象是从
<code>Pool</code> 中获取的。 然后在处理完请求之后，将
<code>Context</code> 对象放回 <code>Pool</code> 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	<span class="comment">// 从 Pool 中获取 Context</span></span><br><span class="line">	c := engine.pool.Get().(*Context)</span><br><span class="line">	<span class="comment">// 重置 writermem</span></span><br><span class="line">	c.writermem.reset(w)</span><br><span class="line">	<span class="comment">// 重置 Request</span></span><br><span class="line">	c.Request = req</span><br><span class="line">	<span class="comment">// 重置其他字段</span></span><br><span class="line">	c.reset()</span><br><span class="line"></span><br><span class="line">	engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 Context 对象放回 Pool</span></span><br><span class="line">	engine.pool.Put(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以去看看 <code>gin</code> 中 <code>Context</code>
对象的定义，我们会发现，它其中有很多字段。
设想一下，如果每一个请求都创建一个 <code>Context</code>
对象，那么每一个请求都要对 <code>Context</code> 进行内存分配，
分配了之后，如果请求结束了，这些申请的内存在后续就要被回收掉（当然，不是马上就回收）。</p>
<p>这样一来，如果待回收的 <code>Context</code>
对象很多，那么垃圾回收器就会被压力很大。</p>
<blockquote>
<p>同样的做法在 <code>echo</code> 这个框架中也有出现。</p>
</blockquote>
<h3 id="fmt-里面的-pp-结构体">fmt 里面的 pp 结构体</h3>
<p>在我们使用 <code>fmt</code> 包来打印的时候（比如，调用
<code>fmt.Fprintf</code>），其实底层是要使用一个名为 <code>pp</code>
的结构体来进行打印的。 如果我们的系统中需要大量地使用 <code>fmt</code>
库来做格式化字符串的操作，如果每次进行格式化操作的时候都
<code>new</code> 一个 <code>pp</code> 对象，
那么也会在某个时刻导致垃圾回收器的压力很大。</p>
<p>所以，<code>fmt</code> 包中使用 <code>pp</code> 的时候，都是从
<code>Pool</code> 中获取的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newPrinter allocates a new pp struct or grabs a cached one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPrinter</span><span class="params">()</span></span> *pp &#123;</span><br><span class="line">	<span class="comment">// 从 Pool 中获取 pp 对象</span></span><br><span class="line">	p := ppFree.Get().(*pp)</span><br><span class="line">	p.panicking = <span class="literal">false</span></span><br><span class="line">	p.erroring = <span class="literal">false</span></span><br><span class="line">	p.wrapErrs = <span class="literal">false</span></span><br><span class="line">	p.fmt.init(&amp;p.buf)</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法是获取 <code>pp</code> 对象的方法。我们在这里没有看到重置
<code>pp</code> 字段的代码，因为这些操作在 <code>pp</code> 的
<code>free</code> 方法中了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free saves used pp structs in ppFree; avoids an allocation per invocation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span></span> free() &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span>(p.buf) &gt; <span class="number">64</span>&lt;&lt;<span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置 p.buf</span></span><br><span class="line">	p.buf = p.buf[:<span class="number">0</span>]</span><br><span class="line">	p.arg = <span class="literal">nil</span></span><br><span class="line">	p.value = reflect.Value&#123;&#125;</span><br><span class="line">	p.wrappedErr = <span class="literal">nil</span></span><br><span class="line">	<span class="comment">// 将 pp 放回 Pool 中</span></span><br><span class="line">	ppFree.Put(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们不能对 <code>sync.Pool</code> 有任何假设，比如，不要想着 Put
进去的对象带了一个状态，然后 Get 出来的时候就能拿到这个状态。
因为这个对象可能在任何时候被清除掉。</p>
</blockquote>
<p>从上面这个例子中，我们可以看到 <code>p.buf = p.buf[:0]</code>
这一行对 <code>buf</code> 进行了重置， 这给我我们的启示是，我们在使用
<code>sync.Pool</code>
的时候，如果我们存取的对象会带有一些不同的字段值，
<strong>那么我们可能需要对这些字段进行重置后再使用</strong>，这样就可以避免
<code>Get</code> 到的对象带有之前的一些状态，
不过重置这些字段的开销相比分配新的内存以及后续
GC，其实开销可以忽略不计。</p>
<h2 id="pool-整体模型">Pool 整体模型</h2>
<p><code>Pool</code> 本质上是一个双端队列，这个队列支持以下操作：</p>
<ul>
<li><code>pushHead</code>：将一个对象放到队列的头部，这也是唯一的入队操作。</li>
<li><code>popHead</code>：从队列的头部取出一个对象。如果取不到则使用
<code>New</code> 方法创建一个新的对象。</li>
<li><code>popTail</code>：从队列的尾部取出一个对象。如果取不到则使用
<code>New</code> 方法创建一个新的对象。</li>
</ul>
<p>可以简单地用下图表示：</p>
<figure>
<img src="/images/go/sync_pool/pool_1.png" alt="pool_1" />
<figcaption aria-hidden="true">pool_1</figcaption>
</figure>
<blockquote>
<p>在阅读本文过程中，想不清楚的时候，回想一下这个模型，可能会有所帮助。</p>
</blockquote>
<p>当然，在实际的实现中，比这个复杂多了，但是这个模型已经足够我们理解
<code>Pool</code> 的工作原理了。</p>
<h3 id="pool-的双端队列是使用数组还是链表">Pool
的双端队列是使用数组还是链表</h3>
<p>我们知道，队列的存储通常有两种方式，一种是数组，一种是链表，两者的优缺点如下：</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 36%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数组</td>
<td>存储空间连续，可以根据下标快速访问</td>
<td>大小固定，扩容成本高</td>
</tr>
<tr class="even">
<td>链表</td>
<td>大小不固定，可以很容易增加新的元素</td>
<td>访问效率不如数组。需要额外的空间来存储前后元素的指针</td>
</tr>
</tbody>
</table>
<p>那么 <code>Pool</code> 里面用的是数组还是链表呢？答案是：<strong>数组
+ 链表</strong>。</p>
<h3 id="pool-为什么要用数组-链表">Pool 为什么要用数组 + 链表</h3>
<p>为了快速访问队列中的元素，使用数组是最好的选择，但是数组的大小是固定的，如果队列中的元素很多，那么数组就会很快被填满。
如果我们还想继续往队列中添加元素，那么就需要对数组进行扩容，这个成本是很高的（因为本来就是需要频繁分配/销毁对象的场景才会使用
<code>Pool</code>）。 同时，我们知道 <code>Pool</code>
设计的目的就是为了减少频繁内存分配带来的性能问题，如果在使用
<code>Pool</code> 的过程中频繁对其进行扩容，那么就违背了
<code>Pool</code> 设计的初衷了。</p>
<p>为了解决数组扩容的问题，我们可以考虑一下使用链表。在我们
<code>Put</code> 的时候往链表的头部添加一个元素，然后 <code>Get</code>
的时候从链表的尾部取出一个元素（还需要移除）。
但是这样我们就需要一个结构体来表示我们的节点了，那么问题来了，我们又需要频繁地分配/销毁这个结构体，这样就又回到了最开始的问题了（频繁创建/销毁对象）。
所以，只使用链表也不是一个好的选择。</p>
<p>所以，<code>Pool</code> 采用了 <strong>数组 + 链表</strong>
的方式来实现双端队列，它们的关系如下：</p>
<ul>
<li>数组：存储队列中的元素，数组的大小是固定的。</li>
<li>链表：当一个数组存储满了之后，就会新建一个数组，然后通过链表将这两个数组串联起来。</li>
</ul>
<p>最终，<code>Pool</code> 的双端队列的结构如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_2.png" alt="pool_2" />
<figcaption aria-hidden="true">pool_2</figcaption>
</figure>
<h3 id="数组如何实现队列">数组如何实现队列</h3>
<p>我们知道，数组的存储空间是固定的一块连续的内存，所以我们可以通过下标来访问数组中的元素。
我们 <code>push</code> 的时候，将 <code>head</code> 下标
<code>+1</code>，然后 <code>pop</code> 的时候，也要修改对应的下标，
但是这样会导致一个问题是，早晚 <code>head</code>
会超出数组的下标范围，但这个时候数组可能还有很多空间， 因为在我们
<code>push</code> 的时候，可能也同时在
<code>pop</code>，所以数组中的空间可能还有很多。</p>
<p>所以，就可以在 <code>head</code> 超出数组下标范围的时候，将
<code>head</code> 对数组长度取模，这样就可以循环使用数组了：</p>
<figure>
<img src="/images/go/sync_pool/pool_3.png" alt="pool_3" />
<figcaption aria-hidden="true">pool_3</figcaption>
</figure>
<p>不过对于这种情况，使用下面的图更加直观：</p>
<figure>
<img src="/images/go/sync_pool/pool_4.png" alt="pool_4" />
<figcaption aria-hidden="true">pool_4</figcaption>
</figure>
<blockquote>
<p><code>Pool</code> 里面是使用 <code>poolDequeue</code>
这个结构体来表示上图这个队列的，本身是一个数组，但是是当作环形队列使用的。</p>
</blockquote>
<h3 id="poolchain-的最终模型">poolChain 的最终模型</h3>
<p><code>poolChain</code> 就是上面说的 <strong>数组 + 链表</strong>
的组合，它的最终模型如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_5.png" alt="pool_5" />
<figcaption aria-hidden="true">pool_5</figcaption>
</figure>
<p>说明：</p>
<ul>
<li><code>poolChain</code> 本身是一个双向链表，每个节点都是一个
<code>poolDequeue</code>，每个节点都有 <code>prev</code> 和
<code>next</code> 指针指向前后节点。上图的 <code>head</code>
是头节点，<code>tail</code> 是尾节点。</li>
<li><code>poolDequeue</code>
是一个数组，它的大小是固定的，但是它是当作环形队列使用的。</li>
<li><code>tail</code> 初始化的时候长度为 8，具体可参考
<code>poolChain</code> 的 <code>pushHead</code> 方法，后面会说到。</li>
<li><code>pushHead</code> 的时候，如果 <code>head</code>
中的环形队列已经满了，那么就会新建一个
<code>poolDequeue</code>，然后将它插入到 <code>head</code>
的前面。（新的 <code>head</code> 节点的大小为前一个 <code>head</code>
节点的两倍）</li>
<li><code>popTail</code>、<code>popHead</code> 的时候，如果
<code>tail</code> 或者 <code>head</code>
中的环形队列（<code>poolDequeue</code>）已经空了，那么就会将它从链表中移除。</li>
</ul>
<h3 id="多个-p-的情况下的-poolchain">多个 P 的情况下的 poolChain</h3>
<blockquote>
<p>这里假设 P 跟我们机器的逻辑处理器的数量一致。（这里涉及到了 goroutine
的调度机制，不了解可以先了解一下再回来看。）</p>
</blockquote>
<p>我们知道，在 go 中，每一个 goroutine 都会绑定一个
P，这样才可以充分利用多核的优势。 设想一下，如果我们有多个 goroutine
同时存储一个 <code>Pool</code>，会出现什么情况呢？
会导致很激烈的数据竞争，虽然没有使用 <code>Mutex</code>
这种相对低效的互斥锁来解决竞争问题，使用的是原子操作，但是也会导致性能下降。</p>
<p>所以，在 <code>Pool</code> 的实现中，会为每一个 P 都创建一个
<code>poolChain</code>，每次存取，先操作本地 P 绑定的
<code>poolChain</code>，这样就可以减少多个 goroutine 同时操作一个
<code>Pool</code> 的竞争问题了。</p>
<p>所以，最终的 <code>Pool</code> 的模型会长成下面这个样子，每个 G
关联了一个 <code>poolChain</code>：</p>
<figure>
<img src="/images/go/sync_pool/pool_6.png" alt="pool_6" />
<figcaption aria-hidden="true">pool_6</figcaption>
</figure>
<blockquote>
<p>注意：这里不是 <code>Pool</code> 实际的样子，只是为了说明
<code>Pool</code> 的实现原理。</p>
</blockquote>
<h3 id="最终实现中的-pool">最终实现中的 <code>Pool</code></h3>
<p>在实际的实现中，其实会跟上一个图有一些差异，可以说复杂很多：</p>
<figure>
<img src="/images/go/sync_pool/pool_7.png" alt="pool_7" />
<figcaption aria-hidden="true">pool_7</figcaption>
</figure>
<p>从上图可以看出，其实每个 P 关联的并不是 <code>poolChain</code>，而是
<code>poolLocal</code>，<code>poolLocal</code> 里面包含了一个
<code>poolLocalInternal</code> 和一个 <code>pad</code>，<code>pad</code>
是为了避免伪共享而添加的。而 <code>poolLocalInternal</code> 就是实际上
<code>Pool</code> 中存储数据的一个结构体。<code>poolLocalInternal</code>
中包含了两个字段，<code>private</code> 和
<code>shared</code>，<code>shared</code> 就是我们上面说的
<code>poolChain</code>，而 <code>private</code> 是一个 <code>any</code>
类型的字段，在我们调用 <code>Pool</code> 的 <code>Put</code>
方法的时候，会先尝试将数据存储到 <code>private</code> 中，如果
<code>private</code> 中已经有数据了，那么就会将数据存储到
<code>shared</code> 中。同样的，在 <code>Get</code> 的时候，也会先从
<code>private</code> 中获取数据，如果 <code>private</code>
中没有数据，那么就会从 <code>shared</code> 中获取数据。</p>
<p>而相应的，<code>Pool</code> 存取数据会变成：</p>
<ul>
<li><code>pushHead</code>：我们调用 <code>Pool</code> 的
<code>Put</code> 方法的时候，只会写入到本地 P 关联的那个
<code>poolLocal</code> 中。</li>
<li><code>popHead</code>：这个方法也只能从本地 P 关联的
<code>poolLocal</code> 中取数据。</li>
<li><code>popTail</code>：这个方法会从本地 P 关联的
<code>poolLocal</code> 中取数据，如果取不到，那么就会从其他 P 关联的
<code>poolLocal</code> 中取数据。</li>
</ul>
<blockquote>
<p>这样就可以减少多个 goroutine 同时操作一个 <code>Pool</code>
的竞争问题了（但是无法避免）。</p>
</blockquote>
<h3 id="pool-模型总结">Pool 模型总结</h3>
<p>最后，我们将这一节的内容总结一下，可以得到下面这个图：</p>
<figure>
<img src="/images/go/sync_pool/pool_8.png" alt="pool_8" />
<figcaption aria-hidden="true">pool_8</figcaption>
</figure>
<p>说明：</p>
<ul>
<li>go 进程内会有多个 P，每个 P 都会关联一个
<code>poolLocal</code>。</li>
<li><code>poolLocal</code> 中包含了一个 <code>poolLocalInternal</code>
和一个 <code>pad</code>，<code>poolLocalInternal</code>
中包含了两个字段，<code>private</code> 和 <code>shared</code>。</li>
<li><code>private</code> 是一个 <code>any</code>
类型的字段，用来存储我们调用 <code>Pool</code> 的 <code>Put</code>
方法的时候传入的数据，<code>Get</code> 的时候如果 <code>private</code>
中有数据，那么就会直接返回 <code>private</code> 中的数据。</li>
<li><code>shared</code> 是一个 <code>poolChain</code>，用来存储我们调用
<code>Pool</code> 的 <code>Put</code>
方法的时候传入的数据，<code>Get</code> 的时候如果当前 P 绑定的
<code>poolLocal</code> 内是空的，那么可以从其他 <code>P</code> 绑定的
<code>shared</code> 的尾部获取。</li>
<li><code>poolChain</code> 是一个双向链表，每个节点都是一个
<code>poolDequeue</code>，每个节点都有 <code>prev</code> 和
<code>next</code> 指针指向前后节点。上图的 <code>head</code>
是头节点，<code>tail</code> 是尾节点。</li>
<li><code>poolDequeue</code>
是一个数组，它的大小是固定的，但是它是当作环形队列使用的。</li>
<li><code>pushHead</code> 的时候，如果 <code>poolChain</code>
的节点满了，那么会新建一个节点，其容量为前一个节点的两倍。</li>
<li><code>poolChain</code>
支持三种操作：<code>pushHead</code>、<code>popHead</code>、<code>popTail</code>。</li>
<li><code>pushHead</code> 会将数据存储到当前 P 关联的
<code>poolChain</code> 的头部。</li>
</ul>
<h2 id="pool-中的结构体">Pool 中的结构体</h2>
<p>在开始分析源码之前，我们先来看一下 <code>Pool</code> 的 UML 图：</p>
<figure>
<img src="/images/go/sync_pool/pool_9.png" alt="pool_9" />
<figcaption aria-hidden="true">pool_9</figcaption>
</figure>
<p>上图中已经包含 <code>Pool</code>
实现的所有关键结构体了，下面我们来分析一下这些结构体的作用。</p>
<h3 id="sync.pool-结构体">sync.Pool 结构体：</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// noCopy 用于防止 Pool 被复制（可以使用 go vet 检测）</span></span><br><span class="line">	noCopy noCopy</span><br><span class="line"></span><br><span class="line">	<span class="comment">// local 的主要作用是，多个 goroutine 同时访问 Pool 时，可以减少竞争，提升性能。</span></span><br><span class="line">	<span class="comment">// 实际类型是 [P]poolLocal。长度是 localSize。</span></span><br><span class="line">	local unsafe.Pointer</span><br><span class="line">	<span class="comment">// []poolLocal 的长度。也就是 local 切片的长度</span></span><br><span class="line">	localSize <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存放的是上一轮 GC 时的 local 字段的值。</span></span><br><span class="line">	victim unsafe.Pointer</span><br><span class="line">	<span class="comment">// victim 数组的长度</span></span><br><span class="line">	victimSize <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新建对象的方法。</span></span><br><span class="line">	<span class="comment">// Get 的时候如果 Pool 中没有对象可用，会调用这个方法来新建一个对象。</span></span><br><span class="line">	New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字段说明：</p>
<ul>
<li><code>local</code>：就是我们上文说到的 <code>poolLocal</code>
类型的切片，长度是 <code>runtime.GOMAXPROCS(0)</code>，也就是当前 P
的数量。之所以使用切片类型是因为我们可以在运行的过程中调整 P
的数量，所以它的长度并不是固定的，如果 P
的数量变了，<code>poolLocal</code> 也会跟着改变。</li>
<li><code>localSize</code>：<code>local</code> 的长度。</li>
<li><code>victim</code>：上一轮 GC 时的 <code>local</code>
字段的值。</li>
<li><code>victimSize</code>：<code>victim</code> 的长度。</li>
<li><code>New</code>：新建对象的方法。</li>
</ul>
<p><code>victim</code> 的作用是在 GC 的时候，将 <code>local</code>
的值赋值给 <code>victim</code>，然后将 <code>local</code> 置为
<code>nil</code>，这样就可以避免在 GC 的时候，<code>local</code>
中的对象被回收掉。 当然，并不是完全不会回收，再经历一次 GC
之后，<code>victim</code>
中的对象就会被回收掉。这样做的好处是，<strong>可以避免 GC 的时候清除
Pool 中的所有对象， 这样在 GC 之后如果需要大量地从 <code>Pool</code>
中获取对象也不至于产生瞬时的性能抖动</strong>。</p>
<p><code>victim cache</code>
是计算机科学中的一个术语，<code>victim cache</code> 是位于 cpu cache
和主存之间的又一级 cache，用于存放由于失效而被丢弃（替换）的那些块。
每当失效发生时，在访问主存之前，victim cache
都会被检查，如果命中，就不会访问主存。</p>
<h4 id="pool-获取对象的流程">Pool 获取对象的流程</h4>
<p>最终，当我们调用 <code>Pool</code> 的 <code>Get</code>
方法的时候，会按下图的流程来获取对象：</p>
<figure>
<img src="/images/go/sync_pool/pool_10.png" alt="pool_10" />
<figcaption aria-hidden="true">pool_10</figcaption>
</figure>
<p>说明：</p>
<ol type="1">
<li>首先会从当前 P 关联的 <code>poolLocal</code> 中的
<code>private</code> 字段中获取对象，如果获取到了，那么直接返回。</li>
<li>如果 <code>private</code> 字段中没有对象，那么会从当前 P 关联的
<code>poolLocal</code> 中的 <code>shared</code>
字段中获取对象，如果获取到了，那么直接返回（这里使用的是
<code>popHead</code> 方法）。</li>
<li>尝试从其他 P 关联的 <code>poolLocal</code> 中的 <code>shared</code>
字段中获取对象，如果获取到了，那么直接返回（这里使用的是
<code>popTail</code> 方法）。</li>
<li>如果其他 P 关联的 <code>poolLocal</code> 中的 <code>shared</code>
字段中也没有对象，那么会从 <code>victim</code>
中获取对象，如果获取到了，那么直接返回。</li>
<li>如果 <code>victim</code> 中也没有对象，那么会调用 <code>New</code>
方法来创建一个新的对象（当然前提是我们创建 <code>Pool</code>
对象的时候设置了 <code>New</code> 字段）。</li>
<li>如果 <code>New</code> 字段也没有设置，那么会返回
<code>nil</code>。</li>
</ol>
<h3 id="poollocal-和-poollocalinternal-结构体">poolLocal 和
poolLocalInternal 结构体：</h3>
<p>在 <code>Pool</code> 中，使用了 <code>poolLocal</code> 和
<code>poolLocalInternal</code> 两个结构体来表示实际存储数据的结构体。
当然我们也可以只使用 <code>poolLocalInternal</code>
这个结构体，但是为了避免伪共享，在 <code>Pool</code> 的实现中， 将
<code>poolLocalInternal</code> 放在了 <code>poolLocal</code>
的第一个字段，然后在 <code>poolLocal</code> 中添加了一个
<code>pad</code> 字段，用来填充 <code>poolLocalInternal</code> 到 cache
line 的大小。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际存储 Pool 的数据的结构体</span></span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// private 用于存储 Pool 的 Put 方法传入的数据。</span></span><br><span class="line">	<span class="comment">// Get 的时候如果 private 不为空，那么直接返回 private 中的数据。</span></span><br><span class="line">	<span class="comment">// 只能被当前 P 使用。</span></span><br><span class="line">	private any</span><br><span class="line">	<span class="comment">// 本地 P 可以pushHead/popHead</span></span><br><span class="line">	<span class="comment">// 任何 P 都可以 popTail。</span></span><br><span class="line">	shared poolChain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pool 中的 local 属性的元素类型。</span></span><br><span class="line"><span class="comment">// Pool 中的 local 是一个元素类型为 poolLocal 的切片，长度为 runtime.GOMAXPROCS(0)。</span></span><br><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">	poolLocalInternal</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pad 用于填充 poolLocalInternal 到 cache line 的大小。</span></span><br><span class="line">	<span class="comment">// 为了避免伪共享，将 poolLocalInternal 放在第一个字段。</span></span><br><span class="line">	pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这里比较关键的地方是 <code>pad</code> 字段的作用，我们知道，CPU
会将内存分成多个 cache line，CPU 从内存中读取数据的时候，
并不是一个字节一个字节地读取，而是一次性读取一个 cache line
的数据。但是如果我们的数据结构中的字段不是按照 cache line
的大小来排列的， 比如跨了两个 cache
line，那么在读取的时候就会产生伪共享，这样就会降低性能。</p>
<figure>
<img src="/images/go/sync_pool/pool_11.png" alt="pool_11" />
<figcaption aria-hidden="true">pool_11</figcaption>
</figure>
<p>伪共享的原因是，数据跨了两个 cache line，那么在读取的时候，就会将两个
cache line 都读取到 CPU 的 cache 中， 这样有可能会导致不同 CPU
在发生数据竞争的时候，会使一些不相关的数据也会失效，从而导致性能下降。
如果对齐到 cache
line，那么从内存读取数据的时候，就不会将一些不相关的数据也读取到 CPU 的
cache 中，从而避免了伪共享。</p>
<h3
id="poolchainpoolchainelt-和-pooldequeue-结构体">poolChain、poolChainElt
和 poolDequeue 结构体</h3>
<p>为什么要把这三个放一起讲呢？因为这三个结构体就是 <code>Pool</code>
中做实际存取数据的结构体，三者作用如下：</p>
<ul>
<li><code>poolChain</code>：<code>poolChain</code>
是一个链表，每个节点都是 <code>poolChainElt</code>。</li>
<li><code>poolChainElt</code>：每个 <code>poolChainElt</code>
中包含了一个
<code>poolDequeue</code>，同时包含了指向前一个节点和后一个节点的指针。</li>
<li><code>poolDequeue</code>：<code>poolDequeue</code>
是一个双端队列（环形队列，使用数组存储），用来存储 <code>Pool</code>
中的数据。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poolChain 是 poolDequeue 的动态大小版本。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这是作为 poolDequeues 的双向链表队列实现的，其中每个 dequeue 都是前一个 dequeue 大小的两倍。</span></span><br><span class="line"><span class="comment">// 一旦 dequeue 填满，就会分配一个新的 dequeue，并且 pushHead 只会 push 到最新的 dequeue。</span></span><br><span class="line"><span class="comment">// pop 可以从头部或者尾部进行，一旦 dequeue 空了，它就会从 poolChain 中删除。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// poolChain 的实现是一个双向链表，每个 poolChainElt 都是一个 poolDequeue。</span></span><br><span class="line"><span class="comment">//（也就是元素是 poolDequeue 的双向链表）</span></span><br><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// head 是要推送到的 poolDequeue。</span></span><br><span class="line">	<span class="comment">// 只能由生产者访问，因此不需要同步。</span></span><br><span class="line">	head *poolChainElt</span><br><span class="line"></span><br><span class="line">	<span class="comment">// tail 是从 poolDequeue 中 pop 的节点。</span></span><br><span class="line">	<span class="comment">// 这是由消费者访问的，因此读取和写入必须是原子的。</span></span><br><span class="line">	tail *poolChainElt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poolChainElt 是 poolChain 中的元素。</span></span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;</span><br><span class="line">	poolDequeue</span><br><span class="line"></span><br><span class="line">	<span class="comment">// next 和 prev 链接到此 poolChain 中相邻的 poolChainElts。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// next 由生产者原子写入，由消费者原子读取。 它只从 nil 过渡到 non-nil。</span></span><br><span class="line">	<span class="comment">// prev 由消费者原子写入，由生产者原子读取。 它只会从 non-nil 过渡到 nil。</span></span><br><span class="line">	next, prev *poolChainElt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poolDequeue 是一个无锁的固定大小的单生产者、多消费者队列。</span></span><br><span class="line"><span class="comment">// 单个生产者既可以从头部 push 也可以从头部 pop，消费者只可以从尾部 pop。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 它有一个附加功能，它会清空不使用的槽，从而避免不必要的对象保留。</span></span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// headTail 将 32 位头索引和 32 位尾索引打包在一起。</span></span><br><span class="line">	<span class="comment">// 两者都是 vals modulo len(vals)-1 的索引。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// tail = 队列尾的索引</span></span><br><span class="line">	<span class="comment">// head = 下一个要填充的插槽的索引</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// [tail, head) 范围内的槽位归消费者所有。</span></span><br><span class="line">	<span class="comment">// 消费者继续拥有此范围之外的槽，直到它清空槽，此时所有权传递给生产者。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 头索引存储在最高有效位中，以便我们可以原子地对它做 add 操作，同时溢出是无害的。</span></span><br><span class="line">	headTail <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// vals 是存储在此 dequeue 中的 interface&#123;&#125; 值的环形缓冲区。它的大小必须是 2 的幂。</span></span><br><span class="line">	<span class="comment">// （队列存储的元素，接口类型）</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 如果插槽为空，则 vals[i].typ 为 nil，否则为非 nil。</span></span><br><span class="line">	<span class="comment">// 一个插槽仍在使用中，直到 *both* 尾部索引超出它并且 typ 已设置为 nil。（both？）</span></span><br><span class="line">	<span class="comment">// 这由消费者原子地设置为 nil，并由生产者原子地读取。</span></span><br><span class="line">	vals []eface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolChain</code> 的结构大概如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_12.png" alt="pool_12" />
<figcaption aria-hidden="true">pool_12</figcaption>
</figure>
<p><code>poolDequeue</code> 的结构大概如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_dequeue.png" alt="pool_dequeue" />
<figcaption aria-hidden="true">pool_dequeue</figcaption>
</figure>
<p>在 <code>poolDequeue</code> 中，<code>headTail</code> 是一个
<code>uint64</code> 类型，它的高 32 位是 <code>head</code>，低 32 位是
<code>tail</code>。 这样一来，这样就可以使用原子操作来保证
<code>head</code> 和 <code>tail</code> 的协程安全了。</p>
<p>在 <code>poolDequeue</code> 中，<code>vals</code>
是一个切片类型，元素类型是 <code>eface</code>，<code>eface</code>
是一个空接口类型，内存布局跟 <code>interface&#123;&#125;</code> 一样，
因此可以看作是一个 <code>interface&#123;&#125;</code>
类型。如果这里看不明白可以看看<a
target="_blank" rel="noopener" href="https://blog.baiguiren.com/2022/12/06/golang/go%20interface%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">《go
interface 设计与实现》</a>。</p>
<p>那为什么不直接使用 <code>interface&#123;&#125;</code> 类型呢？因为如果用了
<code>interface&#123;&#125;</code> 类型， 那么 <code>poolDequeue</code>
就无法区分保存的 <code>val</code> 是 <code>nil</code> 还是一个空的槽。
那有什么解决办法呢？在 <code>push</code> 和 <code>pop</code>
的时候使用互斥锁可以解决这个问题（因为目前的实现是使用原子操作的，所以这才需要判断保存的
<code>val</code> 是 <code>nil</code> 还是空槽），
但是这样就会导致性能下降。</p>
<h2 id="pool-源码剖析">Pool 源码剖析</h2>
<blockquote>
<p>在源码剖析的开始部分，不会深入去讲底层的存取细节，我们将其当作一个抽象的队列来看待即可，这样可能会更加便于理解。不过在讲完
<code>Pool</code> 的实现之后，最后还是会展开讲述这个复杂的 "队列"
的那些实现细节。</p>
</blockquote>
<p>接下来，我们来看看 <code>Pool</code> 的源码实现。 <code>Pool</code>
提供的接口非常简单，只有 <code>Put</code>、<code>Get</code>
两个方法，还有一个 <code>New</code> 字段，用来指定 <code>Pool</code>
中的元素是如何创建的：</p>
<ul>
<li><code>New</code> 属性：<code>New</code> 是一个函数，用来创建
<code>Pool</code> 中的元素。</li>
<li><code>Put</code> 方法：<code>Put</code> 方法用来向 <code>Pool</code>
中放入一个元素。</li>
<li><code>Get</code> 方法：<code>Get</code> 方法用来从 <code>Pool</code>
中获取一个元素。</li>
</ul>
<h3 id="get">Get</h3>
<p><code>Get</code> 方法的实现如下：</p>
<p><code>Get</code> 从 <code>Pool</code> 中选择一个任意项，将其从
<code>Pool</code> 中移除，并将其返回给调用者。 <code>Get</code>
可能会选择忽略池并将其视为空的。 调用方不应假定传递给 <code>Put</code>
的值与 <code>Get</code> 返回的值之间存在任何关系。 (<code>Put</code> 和
<code>Get</code> 之间可能会发生 <code>GC</code>，然后 <code>Pool</code>
里面的元素可能会被 <code>GC</code> 回收掉)</p>
<p>如果 <code>Get</code> 否则返回 <code>nil</code> 并且
<code>p.New</code> 不为 <code>nil</code>，则 <code>Get</code> 返回调用
<code>p.New</code> 的结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get 从 Pool 中获取一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() any &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// pin 将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 的本地缓存（poolLocal）和 P 的 ID。</span></span><br><span class="line">	l, pid := p.pin()</span><br><span class="line">	<span class="comment">// 先看 private 是否为 nil，如果不为 nil，就直接返回 private，并将 private 置为 nil。</span></span><br><span class="line">	x := l.private</span><br><span class="line">	l.private = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 尝试从本地 shared 的头部取。</span></span><br><span class="line">		x, _ = l.shared.popHead()</span><br><span class="line">		<span class="keyword">if</span> x == <span class="literal">nil</span> &#123; <span class="comment">// 如果本地 shared 的头部取不到，就从其他 P 的 shared 的尾部取。</span></span><br><span class="line">			x = p.getSlow(pid)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将当前的 goroutine 和 P 解绑，允许被抢占。</span></span><br><span class="line">	runtime_procUnpin()</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 如果 x 为 nil 并且 p.New 不为 nil，则返回 p.New() 的结果。</span></span><br><span class="line">	<span class="comment">// 没有就 New 一个。</span></span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">		x = p.New()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Pool</code> <code>Get</code> 的流程可以总结如下：</p>
<ol type="1">
<li>将当前的 <code>goroutine</code> 和 <code>P</code>
绑定，禁止被抢占，返回当前 <code>P</code>
的本地缓存（<code>poolLocal</code>）和 <code>P</code> 的
<code>ID</code>。</li>
<li>从本地 <code>private</code> 取，如果取不到，就从本地
<code>shared</code> 的头部取，如果取不到，就从其他 <code>P</code> 的
<code>shared</code> 的尾部取。获取到则返回</li>
<li>如果从其他的 <code>P</code> 的 <code>shared</code>
的尾部也获取不到，则从 <code>victim</code> 获取。获取到则返回</li>
<li>将当前的 <code>goroutine</code> 和 <code>P</code>
解绑，允许被抢占。</li>
<li>如果 <code>p.New</code> 不为 <code>nil</code>，则返回
<code>p.New</code> 的结果。</li>
</ol>
<p>再贴一下上面那个图（当然，下图包含了下面的 <code>getSlow</code>
的流程，并不只是 <code>Get</code>）：</p>
<figure>
<img src="/images/go/sync_pool/pool_10.png" alt="pool_10" />
<figcaption aria-hidden="true">pool_10</figcaption>
</figure>
<p>在 <code>Pool</code> 中一个很关键的操作是
<code>pin</code>，它的作用是将当前的 <code>goroutine</code> 和
<code>P</code> 绑定，禁止被抢占。 这样就可以保证在 <code>Get</code> 和
<code>Put</code> 的时候，都可以获取到当前 <code>P</code>
的本地缓存（<code>poolLocal</code>）， 否则，有可能在 <code>Get</code>
和 <code>Put</code> 的时候，<code>P</code> 会被抢占，导致获取到的
<code>poolLocal</code> 不一致，这样 <code>poolLocal</code>
就会失去意义， 不得不再次陷入跟其他 <code>goroutine</code>
竞争的状态，又不得不考虑在如何在不同 <code>goroutine</code>
之间进行同步了。</p>
<p>而绑定了 <code>P</code> 后，在 <code>Get</code> 和 <code>Put</code>
的时候，就可以使用原子操作来代替其他更大粒度的锁了，
但是我们也不必太担心，因为绑定 <code>P</code> 的时间窗口其实很小。</p>
<h3 id="getslow-源码剖析">getSlow 源码剖析</h3>
<p>在 <code>Get</code> 中，如果从 <code>private</code> 和
<code>shared</code> 中都取不到，就会调用 <code>getSlow</code>
方法。它的作用是：</p>
<ol type="1">
<li>尝试从其他 <code>P</code> 的 <code>shared</code> 的尾部取。</li>
<li>尝试从 <code>victim</code> 获取。</li>
</ol>
<p><code>getSlow</code> 的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从其他 P 的 shared 的尾部取。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> getSlow(pid <span class="type">int</span>) any &#123;</span><br><span class="line">	<span class="comment">// 获取 local 的大小和 local。</span></span><br><span class="line">	size := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">	locals := p.local                            <span class="comment">// load-consume</span></span><br><span class="line">	<span class="comment">// 尝试从其他 P 的 shared 的尾部取。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;</span><br><span class="line">		l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="type">int</span>(size)) <span class="comment">// pid+i+1 的用途从下一个 P 开始取。</span></span><br><span class="line">		<span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123; <span class="comment">// 尝试从每一个 P 的 shared 的尾部取，获取到则返回。</span></span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尝试从 victim cache 取。</span></span><br><span class="line">	<span class="comment">// 我们在尝试从所有主缓存中偷取之后执行此操作，</span></span><br><span class="line">	<span class="comment">// 因为我们希望 victim cache 中的对象尽可能地老化。</span></span><br><span class="line">	size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(pid) &gt;= size &#123; <span class="comment">// 如果 pid 大于 size，会发生越界，直接返回 nil。这意味着 gomaxprocs 相比上一次 poolCleanup 的时候变大了。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	locals = p.victim</span><br><span class="line">	l := indexLocal(locals, pid)</span><br><span class="line">	<span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123; <span class="comment">// victim 实际上也是一个 poolLocal 数组，每个 poolLocal 都有一个 private 字段，这个字段就是 victim cache。</span></span><br><span class="line">		l.private = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;</span><br><span class="line">		l := indexLocal(locals, (pid+i)%<span class="type">int</span>(size))</span><br><span class="line">		<span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 victim cache 标记为空，以便将来的 Get 不会再考虑它。</span></span><br><span class="line">	atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pin-源码剖析">pin 源码剖析</h3>
<p><code>pin</code> 方法的实现如下：</p>
<p><code>pin</code> 将当前 <code>goroutine</code> 固定到 <code>P</code>
上，禁用抢占并返回 <code>poolLocal</code> 池中对应的
<code>poolLocal</code>。 调用方必须在完成取值后调用
<code>runtime_procUnpin()</code> 来取消抢占。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前的 goroutine 和 P 绑定，禁止被抢。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// procPin 函数的目的是为了当前 G 绑定到 P 上。</span></span><br><span class="line">	pid := runtime_procPin() <span class="comment">// 返回当前 P 的 id。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 pinSlow 中，我们会存储 local，然后再存储 localSize，</span></span><br><span class="line">	<span class="comment">// 这里我们以相反的顺序读取。 由于我们禁用了抢占，</span></span><br><span class="line">	<span class="comment">// 因此 GC 不能在两者之间发生。</span></span><br><span class="line">	s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">	l := p.local                              <span class="comment">// load-consume</span></span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;                     <span class="comment">// pid &lt; s，说明当前 P 已经初始化过了。</span></span><br><span class="line">		<span class="keyword">return</span> indexLocal(l, pid), pid <span class="comment">// 返回当前 P 的 poolLocal。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p.pinSlow() <span class="comment">// 如果当前 P 没有初始化过，那么就调用 pinSlow()。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 在互斥锁下重试。</span></span><br><span class="line">	<span class="comment">// 在固定时无法锁定互斥锁。</span></span><br><span class="line">	runtime_procUnpin()       <span class="comment">// 解除当前 P 的绑定。</span></span><br><span class="line">	allPoolsMu.Lock()         <span class="comment">// 加全局锁。</span></span><br><span class="line">	<span class="keyword">defer</span> allPoolsMu.Unlock() <span class="comment">// 解锁。</span></span><br><span class="line">	pid := runtime_procPin()  <span class="comment">// 重新绑定当前 P。</span></span><br><span class="line">	<span class="comment">// 在固定时不会调用 poolCleanup。（无法被抢占，GC 不会发生）</span></span><br><span class="line">	s := p.localSize</span><br><span class="line">	l := p.local</span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123; <span class="comment">// 这其实是一个 double-checking，如果在加锁期间，其他 goroutine 已经初始化过了，就直接返回。</span></span><br><span class="line">		<span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// p.local == nil 说明 pool 还没有初始化过。</span></span><br><span class="line">	<span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123; <span class="comment">// 如果当前 P 没有初始化过，那么就将当前 P 添加到 allPools 中。</span></span><br><span class="line">		allPools = <span class="built_in">append</span>(allPools, p)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当 local 数组为空，或者和当前的 runtime.GOMAXPROCS 不一致时，</span></span><br><span class="line">	<span class="comment">// 将触发重新创建 local 数组，以和 P 的个数保持一致。</span></span><br><span class="line">	<span class="comment">// 如果在 GC 之间更改了 GOMAXPROCS，我们将重新分配数组并丢弃旧数组。</span></span><br><span class="line">	size := runtime.GOMAXPROCS(<span class="number">0</span>)                            <span class="comment">// 获取当前 GOMAXPROCS（也就是 P 的个数）</span></span><br><span class="line">	local := <span class="built_in">make</span>([]poolLocal, size)                         <span class="comment">// 创建一个 poolLocal 数组</span></span><br><span class="line">	atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release // 将当前 P 的 poolLocal 添加到 p.local 中</span></span><br><span class="line">	runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release // 将当前 P 的 poolLocal 添加到 p.localSize 中</span></span><br><span class="line">	<span class="keyword">return</span> &amp;local[pid], pid                                  <span class="comment">// 返回当前 P 关联的 poolLocal，以及当前 P 的 id。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>pinSlow</code> 中比较关键的操作是，它会初始化当前
<code>P</code> 关联的 <code>poolLocal</code>，并将其添加到
<code>allPools</code> 中。 关于 <code>allPools</code>
的作用，可以看下一小节。</p>
<p><code>pinSlow</code> 的流程： 1. 解除当前 <code>P</code> 的绑定。 2.
加全局 <code>Pool</code> 的锁。 3. 重新绑定当前 <code>P</code>。 4.
如果当前 <code>P</code> 的 <code>id</code> 小于
<code>localSize</code>，那么就返回当前 <code>P</code> 的
<code>poolLocal</code>。（典型的 <code>double-checking</code>） 5. 如果
<code>local</code> 还没初始化，那么将当前 <code>P</code> 的
<code>poolLocal</code> 添加到 <code>allPools</code> 中。 6. 初始化
<code>local</code>。最后返回当前 <code>P</code> 的
<code>poolLocal</code>。</p>
<p>对于 <code>local</code>
的初始化，我们可以参考一下下图（我们需要知道的是，切片的底层结构体的第一个字段是一个数组）:</p>
<figure>
<img src="/images/go/sync_pool/pool_13.png" alt="pool_13" />
<figcaption aria-hidden="true">pool_13</figcaption>
</figure>
<p><code>&amp;local[0]</code> 是 <code>[]poolLocal</code>
的首地址，<code>unsafe.Pointer(&amp;local[0])</code> 就是
<code>poolLocal</code> 数组的首地址。</p>
<h4 id="indexlocal-源码剖析">indexLocal 源码剖析</h4>
<p>我们在上面的代码中还可以看到一个 <code>indexLocal</code>
函数，它的作用是返回 <code>poolLocal</code> 数组中的第 <code>i</code>
个元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// l 指向了 poolLocal 数组的首地址，i 是数组的索引。</span></span><br><span class="line"><span class="comment">// 返回了数组中第 i 个元素，其类型是 poolLocal。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexLocal</span><span class="params">(l unsafe.Pointer, i <span class="type">int</span>)</span></span> *poolLocal &#123;</span><br><span class="line">	lp := unsafe.Pointer(<span class="type">uintptr</span>(l) + <span class="type">uintptr</span>(i)*unsafe.Sizeof(poolLocal&#123;&#125;))</span><br><span class="line">	<span class="keyword">return</span> (*poolLocal)(lp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前在看 <code>Pool</code> 结构体的时候，看到过
<code>local</code> 字段，它的类型是
<code>unsafe.Pointer</code>，也就是一个指针。 然后我们再结合一下
<code>indexLocal</code> 的实现，就可以知道 <code>local</code>
字段指向的是一个 <code>poolLocal</code> 数组了。 其中 <code>l</code> 是
<code>poolLocal</code> 数组的首地址，<code>i</code>
是数组的索引，<code>unsafe.Sizeof(poolLocal&#123;&#125;)</code> 是
<code>poolLocal</code> 的大小。</p>
<p>这一小节没看懂可以参考一下我写的另外一篇文章 <a
target="_blank" rel="noopener" href="https://blog.baiguiren.com/2022/11/23/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20unsafe/">《深入理解
go unsafe》</a>。</p>
<h3 id="allpools-的作用">allPools 的作用</h3>
<p><code>allPools</code> 的目的是在 <code>GC</code> 的时候，遍历所有的
<code>Pool</code> 对象，将其中的 <code>victim</code> 替换为
<code>local</code>，然后将 <code>local</code> 设置为 <code>nil</code>。
这样后续的 <code>Get</code> 操作在 <code>local</code>
获取不到的时候，可以从 <code>victim</code> 中获取。一定程度上减少了
<code>GC</code> 后的性能抖动。</p>
<p>在 <code>Pool</code> 中，还定义了下面几个全局变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 保护 allPools 和 oldPools 的互斥锁。</span></span><br><span class="line">	allPoolsMu Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allPools 是所有非空 primary cache 的 pool 的集合。</span></span><br><span class="line">	<span class="comment">// 该集合由 allPoolsMu 和 pinning 保护，或者 STW 保护。</span></span><br><span class="line">	allPools []*Pool</span><br><span class="line"></span><br><span class="line">	<span class="comment">// oldPools 是所有可能非空 victim cache 的 pool 的集合。</span></span><br><span class="line">	oldPools []*Pool</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果我们第一次看这些变量，可能会有点懵，不知道它们的作用是什么。
我们可以再结合一下 <code>poolCleanup</code>
函数的实现，就可以知道它们的作用了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在垃圾收集开始时，这个函数会被调用。</span></span><br><span class="line">	<span class="comment">// 它不能分配并且可能不应该调用任何运行时函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 allPools 中删除 victim 缓存。</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;</span><br><span class="line">		p.victim = <span class="literal">nil</span> <span class="comment">// 作用是让 GC 可以回收 victim 缓存中的对象。</span></span><br><span class="line">		p.victimSize = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 primary 缓存移动到 victim 缓存。</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">		p.victim = p.local</span><br><span class="line">		p.victimSize = p.localSize</span><br><span class="line">		p.local = <span class="literal">nil</span></span><br><span class="line">		p.localSize = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具有非空主缓存的池现在具有非空 victim 缓存，并且没有池具有 primary 缓存。</span></span><br><span class="line">	oldPools, allPools = allPools, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolCleanup</code> 这个函数会在 <code>GC</code>
开始的时候被调用，它的作用是将 <code>local</code> 移动到
<code>victim</code> 中。 同时，将 <code>victim</code> 置为
<code>nil</code>，这样 <code>GC</code> 就可以回收 <code>victim</code>
中的对象了，也就是说要经历两轮 <code>GC</code> <code>local</code>
才会真正地被回收。 也就意味着，<code>GC</code>
的时候，<code>local</code> 其实并没有被回收，而是被移动到了
<code>victim</code> 中。</p>
<p><code>poolCleanup</code> 可以用下图表示，实际上就是使用
<code>local</code> 和 <code>localSize</code> 覆盖 <code>victim</code> 和
<code>victimSize</code>：</p>
<figure>
<img src="/images/go/sync_pool/pool_14.png" alt="pool_14" />
<figcaption aria-hidden="true">pool_14</figcaption>
</figure>
<h3 id="put">Put</h3>
<p><code>Put</code> 的实现比较简单，就是将对象放到 <code>local</code>
中，不需要 <code>Get</code> 那种操作其他 <code>P</code> 绑定的
<code>poolLocal</code> 的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Put 将 x 添加到 Pool 中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x any) &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 获取 poolLocal</span></span><br><span class="line">	l, _ := p.pin() <span class="comment">// 将当前 goroutine 与 P 绑定。获取当前 P 关联的 poolLocal，以及当前 P 的 id。</span></span><br><span class="line">	<span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123; <span class="comment">// 优先放入 private</span></span><br><span class="line">		l.private = x</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 private 已经有值了，就放入 shared</span></span><br><span class="line">		l.shared.pushHead(x) <span class="comment">// 这部分其他 P 也是可以访问的。</span></span><br><span class="line">	&#125;</span><br><span class="line">	runtime_procUnpin() <span class="comment">// 解除当前 P 的绑定。</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Pool</code> <code>Put</code> 的流程： 1. 如果 <code>Put</code>
的值是 <code>nil</code>，则直接返回。 2. 将当前的 <code>goroutine</code>
和 <code>P</code> 绑定，禁止被抢占，返回当前 <code>P</code>
的本地缓存（<code>poolLocal</code>）和 <code>P</code> 的
<code>ID</code>。 3. 如果本地 <code>private</code> 为空，则将
<code>x</code> 放入本地 <code>private</code>。 4. 如果本地
<code>private</code> 不为空，则将 <code>x</code> 放入本地
<code>shared</code> 的头部。 5. 将当前的 <code>goroutine</code> 和
<code>P</code> 解绑，允许被抢占。</p>
<p>这里面的 <code>pin</code> 和
<code>runtime_procUnpin</code>，我们在前文已经介绍过了，这里就不再赘述了。</p>
<h3 id="new">New</h3>
<p>这里说的 <code>New</code> 是 <code>sync.Pool</code> 中的
<code>New</code> 字段，在我们尝试了所有方法都获取不到对象的时候， 会判断
<code>Pool</code> 的 <code>New</code> 属性是否为
<code>nil</code>，如果不为 <code>nil</code>，则会调用 <code>New</code>
方法，创建一个新的对象。</p>
<h2 id="poolchain-和-pooldequeue-源码剖析">poolChain 和 poolDequeue
源码剖析</h2>
<p><code>poolChain</code> 是一个双向链表，它的每一个节点的元素是
<code>poolDequeue</code>。</p>
<p>在上文中，对于 <code>Get</code> 和 <code>Put</code>
的细节，还没有具体展开，因为不了解这些细节也不影响我们理解
<code>Pool</code> 的整体流程。 现在是时候来看看 <code>poolChain</code>
和 <code>poolDequeue</code> 这两个结构体的实现了，会结合起来一起看。</p>
<p><code>poolChain</code> 和 <code>poolDequeue</code>
里面都提供了以下三个方法：</p>
<ul>
<li><code>pushHead</code>：将对象放到队列的头部。</li>
<li><code>popHead</code>：从队列的头部取出一个对象。</li>
<li><code>popTail</code>：从队列的尾部取出一个对象。</li>
</ul>
<p>不一样的是，<code>poolChain</code>
里面的方法会处理链表节点的创建和销毁，而 <code>poolDequeue</code>
里面的方法才是实际从队列存取对象的方法。</p>
<h3 id="pushhead">pushHead</h3>
<p><code>poolChain</code> 的 <code>pushHead</code> 方法的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个元素到队列头部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> pushHead(val any) &#123;</span><br><span class="line">	<span class="comment">// 链表头</span></span><br><span class="line">	d := c.head</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123; <span class="comment">// 链表为空</span></span><br><span class="line">		<span class="comment">// 初始化链表。</span></span><br><span class="line">		<span class="comment">// 新建 poolChainElt，然后 c 的 head 和 tail 都指向这个新建的元素。</span></span><br><span class="line">		<span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// 初始化大小为 8</span></span><br><span class="line">		<span class="comment">// 新建一个节点，类型为 poolChainElt</span></span><br><span class="line">		d = <span class="built_in">new</span>(poolChainElt)</span><br><span class="line">		d.vals = <span class="built_in">make</span>([]eface, initSize)</span><br><span class="line">		<span class="comment">// 将 c 的 head 和 tail 都指向这个新建的元素</span></span><br><span class="line">		c.head = d</span><br><span class="line">		<span class="comment">// 使用原子操作保存 c.tail，因为其他 goroutine 也可能会修改 c.tail。</span></span><br><span class="line">		storePoolChainElt(&amp;c.tail, d)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// poolQueue 还没满的时候可以成功 push，pushHead 会返回 true。</span></span><br><span class="line">	<span class="comment">// poolQueue 满的时候 pushHead 返回 false。</span></span><br><span class="line">	<span class="keyword">if</span> d.pushHead(val) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前 dequeue 已满。分配一个两倍大小的新 dequeue。</span></span><br><span class="line">	newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> newSize &gt;= dequeueLimit &#123; <span class="comment">// 限制单个 dequeue 的最大大小</span></span><br><span class="line">		newSize = dequeueLimit</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新建 poolChainElt，然后 c 的 head 指向这个新建的元素。</span></span><br><span class="line">	<span class="comment">// 同时，d 的 next 指向这个新建的元素。</span></span><br><span class="line">	d2 := &amp;poolChainElt&#123;prev: d&#125; <span class="comment">// 因为是加到队列头，所以 prev 指向 d</span></span><br><span class="line">	d2.vals = <span class="built_in">make</span>([]eface, newSize)</span><br><span class="line">	c.head = d2</span><br><span class="line">	storePoolChainElt(&amp;d.next, d2)</span><br><span class="line">	d2.pushHead(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolChain</code> 的 <code>pushHead</code> 方法的流程：</p>
<ol type="1">
<li>如果链表为空，那么就初始化链表。</li>
<li>如果链表不为空，那么就尝试 <code>pushHead</code>。</li>
<li>如果 <code>pushHead</code> 失败，那么就分配一个两倍大小的新
<code>dequeue</code>。</li>
<li>然后把新 <code>dequeue</code> 放到链表头部。（<code>push</code>
的时候已经锁定了 <code>goroutine</code> 在 <code>P</code>
上，所以这一步是没有并发问题的）</li>
</ol>
<p>在 <code>poolChain</code> 的 <code>pushHead</code>
方法中，唯一需要特别注意的是
<code>storePoolChainElt(&amp;c.tail, d)</code> 这一行代码。 这里使用了
<code>storePoolChainElt</code> 方法，而不是直接使用
<code>c.tail = d</code>。 这是因为 <code>c.tail</code> 是会和其他
<code>goroutine</code> 存在竞争的（其他 <code>goroutine</code>
获取对象的时候可能会修改
<code>tail</code>），因此不能直接赋值，而是使用了原子操作。</p>
<p><code>poolChain</code> 的 <code>pushHead</code>
方法的流程图如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_15.png" alt="pool_15" />
<figcaption aria-hidden="true">pool_15</figcaption>
</figure>
<blockquote>
<p>队列头来说，<code>prev</code> 实际上指向的是 <code>head</code>
的下一个元素，但是又不能叫 <code>next</code>，因为 <code>next</code>
被用来表示 <code>tail</code> 的下一个元素，所以就叫了
<code>prev</code>。我们需要知道 <code>prev</code>、<code>next</code>
本质上都是指向了下一个元素，就看你是从队列头还是队列尾来查找。</p>
</blockquote>
<p>在 <code>poolChain</code> 中，其实实际存储对象的时候并不是在
<code>poolChain</code>，而是在 <code>poolChain</code> 的每一个节点中的
<code>poolDequeue</code> 中。 所以我们再来看看 <code>poolDequeue</code>
中的 <code>pushHead</code> 实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pushHead 在队列的头部添加 val。</span></span><br><span class="line"><span class="comment">// 如果队列已满，则返回 false。</span></span><br><span class="line"><span class="comment">// 它只能由单个生产者调用。（也就是当前 goroutine 绑定的 P）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意：head 指向的是下一个要插入的元素的位置，所以插入的时候，先将 head 指向的位置设置为 val，然后 head++。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pushHead(val any) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 读取 head 和 tail 的值。</span></span><br><span class="line">	ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">	head, tail := d.unpack(ptrs)</span><br><span class="line">	<span class="keyword">if</span> (tail+<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123; <span class="comment">// 队列满了</span></span><br><span class="line">		<span class="comment">// 不能直接 tail == head，因为初始化的时候，head 和 tail 都是 0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 取模意味着，当 head 超过 len(d.vals) 时，会从头开始。也就是一个环。</span></span><br><span class="line">	slot := &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)] <span class="comment">// 获取 head 对应的槽位。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// push 只有当前协程能 push，所以不需要加锁。</span></span><br><span class="line">	<span class="comment">// 但是 popTail 可能会在另一个协程中执行，所以需要判断当前的槽位是否被 popTail 释放了。</span></span><br><span class="line">	<span class="comment">// 因为 popTail 的操作是先 cas 修改 headTail，然后再获取 slot 的值，最后才将 slot 置 0 的。</span></span><br><span class="line">	<span class="comment">// 如果修改了 headTail 之后还没有来得及将 slot 置 0，那么这里就会判断出槽位还没有被释放。</span></span><br><span class="line">	typ := atomic.LoadPointer(&amp;slot.typ) <span class="comment">// 获取槽位的类型</span></span><br><span class="line">	<span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;                      <span class="comment">// 槽位不为空</span></span><br><span class="line">		<span class="comment">// 队列依然是满的</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 typ 已经是 nil，那么这里后续的操作是安全的。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> val == <span class="literal">nil</span> &#123; <span class="comment">// put 进来的值是 nil，使用 dequeueNil 代替</span></span><br><span class="line">		val = dequeueNil(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 val 赋值给槽位</span></span><br><span class="line">	*(*any)(unsafe.Pointer(slot)) = val</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加 head。为什么是 1&lt;&lt;dequeueBits 呢？</span></span><br><span class="line">	<span class="comment">// 因为 head 是高 32 位，所以要左移 32 位</span></span><br><span class="line">	<span class="comment">// 本质上是：head = head + 1</span></span><br><span class="line">	atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolDequeue</code> 的 <code>pushHead</code> 方法的流程：</p>
<p><code>pushHead</code> 的处理流程： 1.
判断队列是否已满，如果已满则返回 <code>false</code>。 2. 获取下一个
<code>push</code> 的位置，先判断这个位置是否可用，如果不可用则返回
<code>false</code>。（可能和 <code>popTail</code> 冲突，如果
<code>popTail</code> 没来得及将其中的值取出来，那么这个槽就还不能使用）
3. 如果可用，则将值放入这个位置，然后将 <code>head</code> 指针加
<code>1</code>。</p>
<p>在 <code>poolDequeue</code>
中，我们看到有一行代码比较奇怪：<code>atomic.LoadUint64(&amp;d.headTail)</code>，这是为了可以原子操作存取
<code>head</code> 和 <code>tail</code>
两个值。这样就可以避免锁的使用了。</p>
<h3 id="pophead">popHead</h3>
<p><code>poolChain</code> 的 <code>popHead</code> 方法的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// popHead 会从链表头部 pop 出一个元素。</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 1. any：pop 出的元素。</span></span><br><span class="line"><span class="comment">// 2. bool：是否成功 pop 出元素。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popHead() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">	d := c.head</span><br><span class="line">	<span class="comment">// d == nil 的情况：</span></span><br><span class="line">	<span class="comment">// 1. 链表为空。</span></span><br><span class="line">	<span class="comment">// 2. 链表只有一个元素，且这个元素已经 pop 完了。（被其他协程 pop 了）</span></span><br><span class="line">	<span class="keyword">for</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 这是因为，在我们拿到 d 之后，还没来得及 pop 的话，其他协程可能已经 pop 了。</span></span><br><span class="line">		<span class="comment">// 所以需要 for 循环。典型的无锁编程。</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// poolQueue 还没空的时候可以成功 pop，popHead 会返回 true。</span></span><br><span class="line">		<span class="keyword">if</span> val, ok := d.popHead(); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> val, ok</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 之前的 dequeue 中可能仍有未消费的元素，因此尝试后退。</span></span><br><span class="line">		d = loadPoolChainElt(&amp;d.prev) <span class="comment">// 获取下一个 poolChainElt</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>prev 虽然从命名上看是前一个，但是实际上是下一个节点。从 head
开始遍历的话，prev 就是下一个节点，从 tail 开始遍历的话，next
就是下一个节点。</p>
</blockquote>
<p><code>poolChain</code> 的 <code>popHead</code> 的处理流程：</p>
<ol type="1">
<li>如果链表为空，那么就返回 <code>false</code>。</li>
<li>如果链表不为空，那么就尝试 <code>popHead</code>。</li>
<li>如果 <code>popHead</code> 失败，那么就尝试从链表下一个 dequeue
<code>popHead</code>。（循环直到最后一个
<code>poolChainElt</code>）</li>
</ol>
<p><code>poolChain</code> 的 <code>popHead</code> 方法的流程图如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_16.png" alt="pool_16" />
<figcaption aria-hidden="true">pool_16</figcaption>
</figure>
<p>在 <code>poolChain</code> 中，实际上调用的是 <code>poolDequeue</code>
的 <code>popHead</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// popHead 删除并返回队列头部的元素。</span></span><br><span class="line"><span class="comment">// 如果队列为空，则返回 false。</span></span><br><span class="line"><span class="comment">// 它只能由单个生产者调用。（也就是当前 goroutine 绑定的 P）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popHead() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// slot 用来保存从队列头部取出的值</span></span><br><span class="line">	<span class="keyword">var</span> slot *eface</span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">// 获取不到槽会继续循环，直到获取到槽或者发现队列为空为止。</span></span><br><span class="line">		ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">		head, tail := d.unpack(ptrs)</span><br><span class="line">		<span class="keyword">if</span> tail == head &#123; <span class="comment">// 队列为空</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 先将 head 减 1，然后再获取槽位。</span></span><br><span class="line">		head--</span><br><span class="line">		ptrs2 := d.pack(head, tail)</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line">			<span class="comment">// 成功获取到槽</span></span><br><span class="line">			slot = &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成功获取到 slot，将 slot 的值取出来</span></span><br><span class="line">	<span class="comment">// head - 1 了，说明这个槽是可以被安全使用的，所以不需要加锁。</span></span><br><span class="line">	<span class="comment">// 因为 popTail 不会影响到 head，所以不会影响到这里。</span></span><br><span class="line">	<span class="comment">// 另外，pushHead 也没有影响，因为在实际使用中，只有一个协程会 pushHead。</span></span><br><span class="line"></span><br><span class="line">	val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line">	<span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">		val = nils</span><br><span class="line">	&#125;</span><br><span class="line">	*slot = eface&#123;&#125; <span class="comment">// 将 slot 置 0</span></span><br><span class="line">	<span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolDequeue</code> 的 <code>popHead</code> 的处理流程：</p>
<ol type="1">
<li>判断队列是否为空，如果为空则返回 <code>false</code>。</li>
<li>尝试将 <code>head</code> 指针减
<code>1</code>，如果失败则进行下一轮尝试（自旋，for +
原子操作是无锁编程中很常见的写法）。</li>
<li>将 <code>head</code> 指针对应的槽位的值取出来，然后将槽位置为
<code>nil</code>。</li>
</ol>
<h3 id="poptail">popTail</h3>
<p><code>poolChain</code> 的 <code>popTail</code> 方法的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从队列尾取出一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popTail() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// 获取链表尾部的 poolChainElt</span></span><br><span class="line">	<span class="comment">// 如果链表为空，返回 nil，false</span></span><br><span class="line">	d := loadPoolChainElt(&amp;c.tail)</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 在我们 popTail 之前获取 next 指针很重要。</span></span><br><span class="line">		<span class="comment">// 一般来说，d 可能暂时为空，但如果 next 在 pop 之前为非 nil，</span></span><br><span class="line">		<span class="comment">// 并且 pop 失败，则 d 永久为空，这是唯一可以安全地将 d 从链中删除的条件。</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 解析：next 非 nil，但是 pop 失败：d 肯定是空的了，这个时候我们可以安全地将 d 从链表中删除。</span></span><br><span class="line">		d2 := loadPoolChainElt(&amp;d.next)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// poolQueue 还没空的时候可以成功 pop，popTail 会返回 true。</span></span><br><span class="line">		<span class="keyword">if</span> val, ok := d.popTail(); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> val, ok</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 队列已经空了</span></span><br><span class="line">		<span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// d 是唯一的 dequeue。它现在是空的，但以后可能会有新的元素 push 进来。</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 链表的尾部已经被消费完了，所以转到下一个 dequeue。</span></span><br><span class="line">		<span class="comment">// 尝试从链表中删除它，这样下一次 pop 就不必再次查看空的 dequeue。</span></span><br><span class="line">		<span class="comment">// （本质：移除空的 tail 元素）</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 开始处理 d2，d2 是 d 的下一个 dequeue。（开始尝试从 d2 中 pop）</span></span><br><span class="line">		<span class="comment">// cas：c.tail 由 d 变为 d2。</span></span><br><span class="line">		<span class="comment">// 如果 cas 成功，说明 d2 是最新的 tail，d 可以被移除。</span></span><br><span class="line">		<span class="comment">// d2 的 prev 指针设置为 nil，这样 gc 可以回收 d。（d2 没有下一个元素了）</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// c.tail(d) 指向下一个 poolChainElt</span></span><br><span class="line">		<span class="comment">// 同时下一个 poolChainElt 的 prev 指针(d)设置为 nil。</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;</span><br><span class="line">			<span class="comment">// 我们赢得了竞争。清除 prev 指针，以便垃圾收集器可以收集空的 dequeue，</span></span><br><span class="line">			<span class="comment">// 以便 popHead 的时候不做多余的查找操作。</span></span><br><span class="line">			storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// d 指向 d2，继续处理下一个 dequeue</span></span><br><span class="line">		d = d2</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolChain</code> 中 <code>popTail</code> 的处理流程：</p>
<ol type="1">
<li>如果链表为空，那么就返回 <code>false</code>。</li>
<li>如果链表不为空，那么就尝试 <code>popTail</code>。</li>
<li>如果 <code>popTail</code> 失败，那么就尝试从链表上一个 dequeue
<code>popTail</code>。（循环直到第一个 <code>poolChainElt</code>）</li>
</ol>
<p><code>poolChain</code> 的 <code>popTail</code> 方法的流程图如下：</p>
<figure>
<img src="/images/go/sync_pool/pool_17.png" alt="pool_17" />
<figcaption aria-hidden="true">pool_17</figcaption>
</figure>
<p>在 <code>popTail</code> 的时候，如果发现 <code>poolChainElt</code>
已经为空了，那么就会从链表中移除它：</p>
<figure>
<img src="/images/go/sync_pool/pool_18.png" alt="pool_18" />
<figcaption aria-hidden="true">pool_18</figcaption>
</figure>
<p><code>poolDequeue</code> 的 <code>popTail</code> 方法的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// popHead 和 popTail 都有取值，然后将槽置空的过程，但是它们的实现是不一样的。</span></span><br><span class="line"><span class="comment">// 在 popHead 中，是直接将槽的值设置为 eface&#123;&#125;，而在 popTail 中，</span></span><br><span class="line"><span class="comment">// 先将 val 设置为 nil，然后将 typ 通过原子操作设置为 nil。</span></span><br><span class="line"><span class="comment">// 这样在 pushHead 的时候就可以安全操作了，只要先使用原子操作判断 typ 是否为 nil 就可以了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// popTail removes and returns the element at the tail of the queue.</span></span><br><span class="line"><span class="comment">// It returns false if the queue is empty. It may be called by any</span></span><br><span class="line"><span class="comment">// number of consumers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// popTail 删除并返回队列尾部的元素。</span></span><br><span class="line"><span class="comment">// 如果队列为空，则返回 false。</span></span><br><span class="line"><span class="comment">// 它可以被任意数量的消费者调用。（如何保证并发安全？原子操作）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// slot 用来保存从队列尾取出来的值</span></span><br><span class="line">	<span class="keyword">var</span> slot *eface</span><br><span class="line">	<span class="comment">// 获取队列尾部的值</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">		head, tail := d.unpack(ptrs)</span><br><span class="line">		<span class="keyword">if</span> tail == head &#123;</span><br><span class="line">			<span class="comment">// Queue is empty.</span></span><br><span class="line">			<span class="comment">// 队列为空，直接返回</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Confirm head and tail (for our speculative check</span></span><br><span class="line">		<span class="comment">// above) and increment tail. If this succeeds, then</span></span><br><span class="line">		<span class="comment">// we own the slot at tail.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 确认 head 和 tail（对于我们上面的推测性检查）并增加 tail。</span></span><br><span class="line">		<span class="comment">// 如果成功，那么我们就拥有 tail 的插槽。</span></span><br><span class="line">		ptrs2 := d.pack(head, tail+<span class="number">1</span>) <span class="comment">// 新的 headTail</span></span><br><span class="line">		<span class="comment">// 如果返回 false，说明从 Load 到 CompareAndSwap 期间，有其他 goroutine 修改了 headTail。</span></span><br><span class="line">		<span class="comment">// 则需要重新 Load，再次尝试（再次执行 for 循环）。</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line">			<span class="comment">// Success.</span></span><br><span class="line">			slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成功获取到 slot，将 slot 的值取出来</span></span><br><span class="line">	<span class="comment">// 问题来了：</span></span><br><span class="line">	<span class="comment">// 在这里 cas 成功的时候，这个 slot 实际上可能是还没有释放的，在这个时候，pushHead 其实不能写入到这个 slot 中。</span></span><br><span class="line">	<span class="comment">// 因此，我们可以在 pushHead 的代码中看到，会先判断 slot.typ 是否为 nil，如果不为 nil，说明 slot 还没有被释放，那么就直接 return 了。</span></span><br><span class="line">	<span class="comment">// 这种情况发生在 poolDequeue 满了的时候。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// We now own slot.</span></span><br><span class="line">	val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line">	<span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123; <span class="comment">// 这是什么情况？非空，但是值等于 dequeueNil(nil) ？</span></span><br><span class="line">		val = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取出值之后，将 slot 置 0。</span></span><br><span class="line">	<span class="comment">// 在 poolDequeue 中，值是允许为 nil 的，但是 pool 的 Put 中判断值为 nil 的时候就直接 return 了。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 告诉 pushHead 我们已经操作完这个插槽。</span></span><br><span class="line">	<span class="comment">// 将插槽归零也很重要，这样我们就不会留下可能使该对象比必要时间更长的引用。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 我们首先写入 val，然后通过原子写入 typ 来发布我们已完成此插槽。</span></span><br><span class="line">	slot.val = <span class="literal">nil</span></span><br><span class="line">	atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>) <span class="comment">// 为什么要用原子操作？因为 pushHead 也会读取这个值，所以需要保证读取的是最新的值。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此时 pushHead 可以操作这个槽了。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poolDequeue</code> 的 <code>popTail</code> 的处理流程：</p>
<ol type="1">
<li>判断队列是否为空，如果为空则返回 <code>false</code>。</li>
<li>尝试将 <code>tail</code> 指针加
<code>1</code>，如果失败则进行下一轮尝试（自旋）。</li>
<li>将 <code>tail</code> 指针对应的槽位的值取出来，然后将槽位置为
<code>nil</code>。</li>
</ol>
<h2 id="sync.pool-设计要点">sync.Pool 设计要点</h2>
<p>在 <code>sync.Pool</code>
中，我们可以看到它有许许多多的编程技巧，为了实现一个高性能的
<code>Pool</code> 要做的东西是非常复杂的，
但是对于我们而言，我们只会用到它暴露出来的两个非常简单的接口
<code>Put</code>、<code>Get</code>，这其实也算是 Go
语言的一种设计哲学吧，
把复杂留给自己，把简单留给用户。但是，我们还是要知道它的实现原理，这样才能更好的使用它。</p>
<p>接下来，我们就再来总结一下 <code>sync.Pool</code>
高性能的一些设计要点：</p>
<ol type="1">
<li><code>noCopy</code> 字段，防止 <code>sync.Pool</code>
被复制。<code>sync.Pool</code>
是不能被复制的，否则会导致一些隐晦的错误。</li>
<li><code>local</code> 字段，用于存储与 <code>P</code> 关联的一个
<code>poolLocal</code> 对象，在多个 <code>goroutine</code>
同时操作的时候，可以减少不同 <code>goroutine</code>
之间的竞争，只有在本地的 <code>poolLocal</code>
中没有找到对象的时候，才会去其他 <code>goroutine</code>
关联的队列中去取。</li>
<li><code>poolDequeue</code> 中 <code>pushHead</code> 跟
<code>popTail</code> 之间会存在 <code>head</code>、<code>tail</code>
指针上的一些竞争，这些竞争问题是通过原子操作来解决的（相比互斥锁效率更高）。使用了原子操作可能就会有失败的时候，这个时候，再次重试就可以了。</li>
<li><code>poolDequeue</code> 中的 <code>head</code>/<code>tail</code>
指针使用一个字段来保存，然后通过原子操作保证
<code>head</code>/<code>tail</code> 的一致性。</li>
<li><code>poolChain</code>
使用链表的方式解决容量问题，并且新增一个元素到链表的时候，容量为上一个元素（<code>poolChain</code>
链表头）的两倍（非常常见的扩容策略）。双向链表，可以接受别的
<code>P</code> 的 <code>popTail</code>
操作，减少竞争的同时可以充分利用多核。</li>
<li><code>pin</code> 保证 <code>P</code> 不会被抢占。如果一个
<code>goroutine</code> 在执行 <code>Put</code> 或者 <code>Get</code>
期间被挂起，有可能下次恢复时，绑定的就不是上次的 <code>P</code>
了。那整个过程就会完全乱掉，因为获取到的 <code>poolLocal</code>
不是之前那个了。使用 <code>pin</code> 可以解决这种并发问题。</li>
<li>自旋操作，因为原子操作失败的时候可能存在竞争，这个时候再尝试一下就可能成功了。（<code>for</code>
+ 原子操作是无锁编程中很常见的一种编程模式，在 <code>sync.Map</code>
中也有很多类似操作）</li>
<li><code>pad</code> 内存对齐，可以避免伪共享。</li>
<li><code>poolDequeue</code>
中存储数据的结构是一个环形队列，是连续的内存，可以充分利用 CPU 的
<code>cache</code>。在访问 <code>poolDequeue</code>
某一项时，其附近的数据项都有可能加载到统一 <code>cache line</code>
中，有利于提升性能。同时它是预先分配内存的，因此其中的数据项可不断复用。</li>
</ol>
<h2 id="总结">总结</h2>
<p>最后，总结一下本文内容：</p>
<ul>
<li><code>sync.Pool</code>
是一个非常有用的工具，它可以帮助我们减少内存的分配和回收（通过复用对象），提升程序的性能。但是，我们要注意它的使用场景，它适合那些没有状态的对象，同时，我们不能对那些从
<code>Pool</code> 中 <code>Get</code> 出来的对象做任何假设。</li>
<li>我们在 <code>Put</code> 或者 <code>Get</code>
之前，可能需要对我们操作的对象重置一下，防止对后续的操作造成影响。</li>
<li><code>Pool</code>
中的对象存储是使用队列的方式，这个队列的实现是一个链表（<code>poolChain</code>），链表的每一个节点都是一个环形队列（<code>poolDequeue</code>）。这个队列支持以下三种操作：
<ul>
<li><code>pushHead</code>：将一个对象放到队列的头部。</li>
<li><code>popHead</code>：将队列的头部的对象取出来。</li>
<li><code>popTail</code>：将队列的尾部的对象取出来。</li>
</ul></li>
<li><code>sync.Pool</code> 的实现中，使用了很多编程技巧，比如
<code>noCopy</code>、<code>pin</code>、<code>pad</code>、原子操作等等，这些技巧都是为了实现一个高性能的
<code>Pool</code>
而做的一些优化，我们可以学习一下，具体参考上一节。</li>
<li><code>sync.Pool</code> 中，<code>Put</code> 和 <code>Get</code>
操作的时候会先将 <code>goroutine</code> 与 <code>P</code>
绑定，然后再去操作 <code>P</code> 关联的
<code>poolLocal</code>，这样可以减少竞争，提升性能。因为每一个
<code>P</code> 都有一个关联的 <code>poolLocal</code>，所以多个
<code>goroutine</code>
操作的时候，可以充分利用多核。在操作完成后，再解除绑定。</li>
<li>考虑到 <code>GC</code> 直接清除 <code>Pool</code> 中的对象会在
<code>GC</code> 后可能会产生性能抖动，所以在 <code>GC</code>
的时候，其实并不会马上清除 <code>Pool</code>
中的对象，而是将这些对象放到 <code>victim</code> 字段中，在
<code>Get</code> 的过程中，如果所有的 <code>poolLocal</code>
中获取不到对象，则会从 <code>victim</code> 中去找。但是再进行
<code>GC</code> 的时候，旧的 <code>victim</code> 会被清除。也就是
<code>Pool</code> 中对象的淘汰会经历两次 <code>GC</code>。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/01/31/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20sync.Cond/" rel="prev" title="深入理解 go sync.Cond">
                  <i class="fa fa-angle-left"></i> 深入理解 go sync.Cond
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/03/25/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" rel="next" title="深入理解 go 原子操作">
                  深入理解 go 原子操作 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">eleven26</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eleven26" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
