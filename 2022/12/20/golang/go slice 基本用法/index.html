<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eleven26.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="slice（切片）是 go 里面非常常用的一种数据结构，它代表了一个变长的序列，序列中的每个元素都有相同的数据类型。 一个 slice 类型一般写作 []T，其中 T 代表 slice 中元素的类型；slice 的语法和数组很像，但是 slice 没有固定长度。 数组和切片的区别 数组有确定的长度，而切片的长度不固定，并且可以自动扩容。 数组的定义 go 中定义数组的方式有如下两种：  指定长度：">
<meta property="og:type" content="article">
<meta property="og:title" content="go slice 基本用法">
<meta property="og:url" content="https://eleven26.github.io/2022/12/20/golang/go%20slice%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/index.html">
<meta property="og:site_name" content="eleven26">
<meta property="og:description" content="slice（切片）是 go 里面非常常用的一种数据结构，它代表了一个变长的序列，序列中的每个元素都有相同的数据类型。 一个 slice 类型一般写作 []T，其中 T 代表 slice 中元素的类型；slice 的语法和数组很像，但是 slice 没有固定长度。 数组和切片的区别 数组有确定的长度，而切片的长度不固定，并且可以自动扩容。 数组的定义 go 中定义数组的方式有如下两种：  指定长度：">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://eleven26.github.io/images/go/slice/slice_1_1.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/slice/slice_2_1.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/slice/slice_3_1.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/slice/slice_3_2.png">
<meta property="article:published_time" content="2022-12-20T09:16:30.000Z">
<meta property="article:modified_time" content="2022-12-26T05:45:21.000Z">
<meta property="article:author" content="eleven26">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eleven26.github.io/images/go/slice/slice_1_1.png">


<link rel="canonical" href="https://eleven26.github.io/2022/12/20/golang/go%20slice%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://eleven26.github.io/2022/12/20/golang/go%20slice%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","path":"2022/12/20/golang/go slice 基本用法/","title":"go slice 基本用法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go slice 基本用法 | eleven26</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">eleven26</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">100</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">346</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">数组和切片的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">数组的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.</span> <span class="nav-text">切片的定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E7%9B%B8%E4%BC%BC%E4%B9%8B%E5%A4%84"><span class="nav-number">2.</span> <span class="nav-text">数组和切片的相似之处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%B1%80%E9%99%90"><span class="nav-number">3.</span> <span class="nav-text">数组的局限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3-slice"><span class="nav-number">4.</span> <span class="nav-text">重新理解 slice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slice-%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">5.</span> <span class="nav-text">slice 的内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87%E5%AE%B9%E9%87%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">6.</span> <span class="nav-text">切片容量存在的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">7.</span> <span class="nav-text">切片常用操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87"><span class="nav-number">7.1.</span> <span class="nav-text">创建切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%80%E5%88%87%E7%89%87%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-number">7.2.</span> <span class="nav-text">往切片中添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87%E5%A4%8D%E5%88%B6"><span class="nav-number">7.3.</span> <span class="nav-text">切片复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%88%87%E7%89%87%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">7.4.</span> <span class="nav-text">从切片删除元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%AE%B9%E9%87%8F%E5%88%B0%E5%BA%95%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="nav-number">8.</span> <span class="nav-text">切片的容量到底是多少？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87%E5%8F%AF%E4%BB%A5%E5%85%B1%E4%BA%AB%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84"><span class="nav-number">9.</span> <span class="nav-text">切片可以共享底层数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%8E%9F%E5%88%87%E7%89%87"><span class="nav-number">10.</span> <span class="nav-text">切片扩容不会影响原切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eleven26</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eleven26" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eleven26" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/12/20/golang/go%20slice%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="go slice 基本用法 | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go slice 基本用法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-20 17:16:30" itemprop="dateCreated datePublished" datetime="2022-12-20T17:16:30+08:00">2022-12-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><code>slice</code>（切片）是 go
里面非常常用的一种数据结构，它代表了一个变长的序列，序列中的每个元素都有相同的数据类型。
一个 <code>slice</code> 类型一般写作 <code>[]T</code>，其中
<code>T</code> 代表 <code>slice</code> 中元素的类型；<code>slice</code>
的语法和数组很像，但是 <code>slice</code> 没有固定长度。</p>
<h2 id="数组和切片的区别">数组和切片的区别</h2>
<p>数组有确定的长度，而切片的长度不固定，并且可以自动扩容。</p>
<h3 id="数组的定义">数组的定义</h3>
<p>go 中定义数组的方式有如下两种：</p>
<ol type="1">
<li>指定长度：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>不指定长度，由编译器推导出数组的长度：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>上面这两种定义方式都定义了一个长度为 3
的数组。正如我们所见，<strong>长度是数组的一部分，定义数组的时候长度已经确定下来了</strong>。</p>
<h3 id="切片的定义">切片的定义</h3>
<p>切片的定义方式跟数组很像，只不过<strong>定义切片的时候不用指定长度</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在上面定义切片的代码中，我们可以看到其实跟数组唯一的区别就是少了个长度。
那其实我们可以<strong>把切片看作是一个无限长度的数组</strong>。
当然，实际上它并不是无限的，它只是在切片容纳不下新的元素的时候，会自动进行扩容，从而可以容纳更多的元素。</p>
<h2 id="数组和切片的相似之处">数组和切片的相似之处</h2>
<p>正如我们上面看到的那样，数组和切片两者其实非常相似，在实际使用中，它们也是有些类似的。</p>
<p>比如，通过下标来访问元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 通过下标访问</span></span><br><span class="line">fmt.Println(arr[<span class="number">1</span>]) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 通过下标访问</span></span><br><span class="line">fmt.Println(s[<span class="number">1</span>]) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="数组的局限">数组的局限</h2>
<p>我们知道了，数组的长度是固定的，这也就意味着如果我们想往数组里面增加一个元素会比较麻烦，
<strong>我们需要新建一个更大的数组，然后将旧的数据复制过去，然后将新的元素写进去</strong>，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 往数组 arr 增加一个元素：4</span></span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 新建一个更大容量的数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">4</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 复制旧数组的数据</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">    arr1[i] = arr[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加入新的元素：4</span></span><br><span class="line">arr1[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">fmt.Println(arr1)</span><br></pre></td></tr></table></figure>
<p>这样一来就非常的繁琐，如果我们使用切片，就可以省去这些步骤：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个长度为 3 的数组</span></span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组创建一个切片</span></span><br><span class="line">s := arr[:]</span><br><span class="line"><span class="comment">// 增加一个元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></table></figure>
<p><strong>因为数组固定长度的缺点，实际使用中切片会使用得更加普遍。</strong></p>
<h2 id="重新理解-slice">重新理解 slice</h2>
<p>在开始之前，我们来看看 <code>slice</code>
这个单词的意思：作为名词，<code>slice</code> 的意思有
<code>片;部分;(切下的食物)薄片;</code>，作为动词，<code>slice</code>
的意思有 <code>切;把…切成(薄)片;</code> 的意思。
从这个角度出发，我们可以把 <code>slice</code> 理解为从某个数组上
<code>切下来的一部分</code>（从这个角度看，<code>slice</code>
这个命名非常的形象）。我们可以看看下图：</p>
<figure>
<img src="/images/go/slice/slice_1_1.png" alt="slice_1_1" />
<figcaption aria-hidden="true">slice_1_1</figcaption>
</figure>
<p>在这个图中，<code>A</code> 是一个保存了数字 <code>1~7</code> 的
<code>slice</code>，<code>B</code> 是从 <code>A</code> 中
<strong>切下来的一部分</strong>，而 <code>B</code> 只包含了
<code>A</code> 中的一部分数据。 我们可以把 <code>B</code> 理解为
<code>A</code> 的一个 <code>视图</code>，<code>B</code> 中的数据是
<code>A</code> 中的数据的一个 <code>引用</code>，而不是 <code>A</code>
中数据的一个 <code>拷贝</code> （也就是说，我们修改 <code>B</code>
的时候，<code>A</code> 中的数据也会被修改，当然会有例外，那就是
<code>B</code> <strong>发生扩容的时候</strong>，再去修改 <code>B</code>
的话就影响不了 <code>A</code> 了）。</p>
<h2 id="slice-的内存布局">slice 的内存布局</h2>
<p>现在假设我们有如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个切片，长度为 3，容量为 7</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></table></figure>
<p>对应的内存布局如下：</p>
<figure>
<img src="/images/go/slice/slice_2_1.png" alt="slice_2_1" />
<figcaption aria-hidden="true">slice_2_1</figcaption>
</figure>
<p>说明：</p>
<ul>
<li><code>slice</code>
底层其实也是数组，但是除了数组之外，还有两个字段记录切片的长度和容量，分别是
<code>len</code> 和 <code>cap</code>。</li>
<li>上图中，<code>slice</code> 中的 <code>array</code>
就是切片的底层数组，因为它的长度不是固定的，所以使用了指针来保存，指向了另外一片内存区域。</li>
<li><code>len</code>
表明了切片的长度，<strong>切片的长度也就是我们可以操作的下标</strong>，上面的切片长度为
<code>3</code>，这也就意味着我们切片可以操作的下标范围是
<code>0~2</code>。超出这个范围的下标会报错。</li>
<li><code>cap</code>
表明了切片的容量，也就是<strong>切片扩容之前可以容纳的元素个数</strong>。</li>
</ul>
<h2 id="切片容量存在的意义">切片容量存在的意义</h2>
<p>对于我们日常开发来说，<code>slice</code>
的容量其实大多数时候不是我们需要关注的点，而且由于容量的存在，也给开发者带来了一定的困惑。
那么容量存在的意义是什么呢？意义就在于避免内存的频繁分配带来的性能下降（<strong>容量也就是提前分配的内存大小</strong>）。</p>
<p>比如，假如我们有一个切片，然后我们知道需要往它里面存放 1w 个元素，
如果我们不指定容量的话，那么切片就会在它存放不下新的元素的时候进行扩容，
这样一来，可能在我们存放这 1w 个元素的时候需要进行多次扩容，
这也就意味着需要进行多次的内存分配。这样就会影响应用的性能。</p>
<p>我们可以通过下面的例子来简单了解一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Benchmark1-20    	100000000	        11.68 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark2-20    	134283985	         7.482 ns/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">100000000</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个例子中，没有给 <code>slice</code>
设置容量，这样它就只会在切片容纳不下新元素的时候才会进行扩容，这样就会需要进行多次扩容。
而第二个例子中，我们先给 <code>slice</code>
设置了一个足够大的容量，那么它就不需要进行频繁扩容了。</p>
<p>最终我们发现，在给切片提前设置容量的情况下，会有一定的性能提升。</p>
<h2 id="切片常用操作">切片常用操作</h2>
<h3 id="创建切片">创建切片</h3>
<p>我们可以从数组或切片生成新的切片：</p>
<blockquote>
<p>注意：生成的切片不包含 <code>end</code>。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target[start:end]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>target</code> 表示目标数组或者切片</li>
<li><code>start</code> 对应目标对象的起始索引（包含）</li>
<li><code>end</code> 对应目标对象的结束索引（不包含）</li>
</ul>
<p>如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s1 := s[<span class="number">1</span>:<span class="number">2</span>]    <span class="comment">// 包含下标 1，不包含下标 2</span></span><br><span class="line">fmt.Println(s1) <span class="comment">// [2]</span></span><br><span class="line"></span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 := arr[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Println(s2) <span class="comment">// [2]</span></span><br></pre></td></tr></table></figure>
<p>在这种初始化方式中，我们可以省略 <code>start</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr[:<span class="number">2</span>]) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>省略 <code>start</code> 的情况下，就是从 <code>target</code>
的第一个元素开始。</p>
<p>我们也可以省略 <code>end</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr[<span class="number">1</span>:]) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
<p>省略 <code>end</code> 的情况下，就是从 <code>start</code>
索引处的元素开始直到 <code>target</code> 的最后一个元素处。</p>
<p>除此之外，我们还可以指定新的切片的容量，通过如下这种方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target[start:end:<span class="built_in">cap</span>]</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">s := arr[<span class="number">1</span>:<span class="number">4</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// [2 3 4] 3 4</span></span><br></pre></td></tr></table></figure>
<h3 id="往切片中添加元素">往切片中添加元素</h3>
<p>我们前面说过了，如果我们想往数组里面增加元素，那么我们必须开辟新的内存，将旧的数组复制过去，然后才能将新的元素加入进去。</p>
<p>但是切片就相对简单，我们可以使用 <code>append</code>
这个内置函数来往切片中加入新的元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>) <span class="comment">// 追加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 追加多个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;...) <span class="comment">// 追加一个切片</span></span><br></pre></td></tr></table></figure>
<h3 id="切片复制">切片复制</h3>
<p>go 有一个内置函数 <code>copy</code>
可以将一个切片的内容复制到另外一个切片中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(dst, src []<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>第一个参数 <code>dst</code> 是目标切片，第二个参数 <code>src</code>
是源切片，调用 <code>copy</code> 的时候会把 <code>src</code>
的内容复制到 <code>dst</code> 中。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> b []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 的容量为 0，容纳不下任何元素</span></span><br><span class="line"><span class="built_in">copy</span>(a, b)</span><br><span class="line">fmt.Println(a) <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">3</span>) <span class="comment">// 给 a 分配内存</span></span><br><span class="line"><span class="built_in">copy</span>(a, b)</span><br><span class="line">fmt.Println(a) <span class="comment">// [1 2 3]</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果 <code>dst</code> 的长度比 <code>src</code>
的长度小，那么只会截取 <code>src</code> 的前面一部分。</p>
<h3 id="从切片删除元素">从切片删除元素</h3>
<p>虽然我们往切片追加元素的操作挺方便的，但是要从切片删除元素就相对麻烦一些了。go
语言本身没有提供从切片删除元素的方法。
如果我们要删除切片中的元素，只有构建出一个新的切片：</p>
<figure>
<img src="/images/go/slice/slice_3_1.png" alt="slice_3_1" />
<figcaption aria-hidden="true">slice_3_1</figcaption>
</figure>
<p>对应代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;</span><br><span class="line">    a[i] = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b []<span class="type">int</span></span><br><span class="line">b = <span class="built_in">append</span>(b, a[:<span class="number">2</span>]...) <span class="comment">// [1 2]</span></span><br><span class="line">b = <span class="built_in">append</span>(b, a[<span class="number">5</span>:]...) <span class="comment">// [1 2 6 7]</span></span><br><span class="line">fmt.Println(b) <span class="comment">// [1 2 6 7]</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们想从 <code>a</code> 中删除 <code>3、4、5</code>
这三个元素，也就是下标 <code>2~4</code> 的元素，
我们的做法是，新建了一个新的切片，然后将 <code>3</code>
前面的元素加入到这个新的切片中， 再将 <code>5</code>
后面的元素加入到这个新切片中。</p>
<p>最终得到的切片就是删除了 <code>3、4、5</code>
三个元素之后的切片了。</p>
<h2 id="切片的容量到底是多少">切片的容量到底是多少？</h2>
<p>假设我们有如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;</span><br><span class="line">    a[i] = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">s1 := a[:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// [1 2 3] 3 7</span></span><br><span class="line">fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line"></span><br><span class="line">s2 := a[<span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line"><span class="comment">// [5 6] 2 3</span></span><br><span class="line">fmt.Println(s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br></pre></td></tr></table></figure>
<p><code>s1</code> 和 <code>s2</code> 可以用下图表示：</p>
<figure>
<img src="/images/go/slice/slice_3_2.png" alt="slice_3_2" />
<figcaption aria-hidden="true">slice_3_2</figcaption>
</figure>
<ul>
<li><code>s1</code> 只能访问 <code>array</code>
的前三个元素，<code>s2</code> 只能访问 <code>5</code> 和 <code>6</code>
这两个元素。</li>
<li><code>s1</code> 的容量是 7（底层数组的长度）</li>
<li><code>s2</code> 的容量是 3，从 <code>5</code>
所在的索引处直到底层数组的末尾。</li>
</ul>
<p>对于 <code>s1</code> 和
<code>s2</code>，我们都没有指定它的容量，但是我们打印发现它们都有容量，
其实在切片中，我们从切片中生成一个新的切片的时候，如果我们不指定容量，
那新切片的容量就是 <code>s[start:end]</code> 中的 <code>start</code>
直到底层数组的最后一个元素的长度。</p>
<h2 id="切片可以共享底层数组">切片可以共享底层数组</h2>
<p>切片最需要注意的点是，当我们从一个切片中创建新的切片的时候，两者会共享同一个底层数组，
如上图的那样，<code>s1</code> 和 <code>s2</code>
都引用了同一个底层的数组不同的索引， <code>s1</code> 引用了底层数组的
<code>0~2</code> 下标范围，<code>s2</code> 引用了底层数组
<code>4~5</code> 下标范围。</p>
<p>这意味着，当我们修改 <code>s1</code> 或 <code>s2</code>
的时候，原来的切片 <code>a</code> 也会发生改变：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;</span><br><span class="line">    a[i] = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">s1 := a[:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// [1 2 3]</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line">s1[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// [1 100 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="comment">// [1 100 3]</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>s1</code> 这个切片引用了和 <code>a</code>
一样的底层数组， 然后在我们修改 <code>s1</code> 的时候，<code>a</code>
也发生了改变。</p>
<h2 id="切片扩容不会影响原切片">切片扩容不会影响原切片</h2>
<p>上一小节我们说了，切片可以共享底层数组。但是<strong>如果切片扩容的话，那就是一个全新的切片了</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// [1 2 3] 3 3</span></span><br><span class="line">fmt.Println(a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 容纳不下新的元素了，会进行扩容</span></span><br><span class="line">b := <span class="built_in">append</span>(a, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [1 2 3 4] 4 6</span></span><br><span class="line">fmt.Println(b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// [1 2 3]</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="comment">// [1 100 3 4]</span></span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>a</code> 是一个长度和容量都是 <code>3</code>
的切片，这也就意味着，这个切片已经满了。
在这种情况下，<strong>我们再往其中追加元素的时候，就会进行扩容，生成一个新的切片</strong>。
因此，我们可以看到，我们修改了 <code>b</code> 的时候，并没有影响到
<code>a</code>。</p>
<p>下面的例子就不一样了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度为 2，容量为 3</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"><span class="comment">// [1 2] 2 3</span></span><br><span class="line">fmt.Println(a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 还可以容纳新的元素，不用扩容</span></span><br><span class="line">b := <span class="built_in">append</span>(a, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [1 2 4] 3 3</span></span><br><span class="line">fmt.Println(b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// [1 100]</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="comment">// [1 100 4]</span></span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure>
<p>在后面这个例子中，我们只是简单地改了一下 <code>a</code>
初始化的方式，改成了只放入两个元素，但是容量还是 <code>3</code>，
在这种情况下，<code>a</code> 可以再容纳一个元素，这样在
<code>b := append(a, 4)</code> 的时候，创建的 <code>b</code>
底层的数组其实跟 <code>a</code> 的底层数组依然是一样的。</p>
<p>所以，<strong>我们需要尤其注意代码中作为切片的函数参数，如果我们希望在被调函数中修改了切片之后，在
caller 里面也能看到效果的话，最好是传递指针</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(s *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	*s = <span class="built_in">append</span>(*s, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSlice</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="comment">// [1 2 3] 3 3</span></span><br><span class="line">	fmt.Println(a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line">	test1(a)</span><br><span class="line">	<span class="comment">// [1 2 3] 3 3</span></span><br><span class="line">	fmt.Println(a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="comment">// [1 2 3] 3 3</span></span><br><span class="line">	fmt.Println(b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">	test2(&amp;b)</span><br><span class="line">	<span class="comment">// [1 2 3 4] 4 6</span></span><br><span class="line">	fmt.Println(b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>test1</code> 接收的是值参数，所以在
<code>test1</code> 中切片发生扩容的时候，<code>TestSlice</code> 里面的
<code>a</code> 还是没有发生改变。 而 <code>test2</code>
接收的是指针参数，所以在 <code>test2</code>
中发生切片扩容的时候，<code>TestSlice</code> 里面的 <code>b</code>
也发生了改变。</p>
<h2 id="总结">总结</h2>
<ul>
<li>数组跟切片的使用上有点类似，但是数组代表的是有固定长度的数据序列，而切片代表的是没有固定长度的数据序列。</li>
<li>数组的长度是类型的一部分，有两种定义数组的方式：<code>[2]int&#123;1, 2&#125;</code>、<code>[...]int&#123;1, 2&#125;</code>。</li>
<li>数组跟切片都可以通过下标来访问其中的元素，可以访问的下标范围都是
<code>0 ~ len(x)-1</code>，<code>x</code> 表示的是数组或者切片。</li>
<li>数组无法追加新的元素，切片可以追加任意数量的元素。</li>
<li><code>slice</code> 的数据结构里面包含了：<code>array</code>
底层数组指针、<code>len</code> 切片长度、<code>cap</code>
切片容量。</li>
<li>创建切片的时候，指定一个合适的容量可以减少内存分配的次数，从而在一定程度上提高程序性能。</li>
<li>我们可以从数组或者切片创建一个新的切片：<code>array[1:3]</code> 或者
<code>slice[1:3]</code>。</li>
<li>使用 <code>append</code> 内置函数可以往切片中添加新的元素。</li>
<li>使用 <code>copy</code>
内置函数可以将一个切片的内容复制到另外一个切片中。</li>
<li>切片删除元素没有好的办法，只能截取被删除元素前后的数据，然后复制到一个新的切片中。</li>
<li>假设我们通过 <code>slice[start:end]</code>
的方式从切片中创建一个新的切片，那么这个新的切片的容量是
<code>cap(slice) - start</code>，也就是，从 <code>start</code>
到底层数组最后一个元素的长度。</li>
<li>使用切片的时候需要注意：切片之间会共享底层数组，其中一个切片修改了切片的元素的时候，也会反映到其他切片上。</li>
<li>函数调用的时候，如果被调函数内发生扩容，调用者是无法知道的。如果我们不想错过在被调函数内切片的变化，我们可以传递指针作为参数。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/12/16/golang/go%20map%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" rel="prev" title="go map 设计与实现">
                  <i class="fa fa-angle-left"></i> go map 设计与实现
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/12/21/golang/go%20slice%20%E6%89%A9%E5%AE%B9%E5%AE%9E%E7%8E%B0/" rel="next" title="go slice 扩容实现">
                  go slice 扩容实现 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">eleven26</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eleven26" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
