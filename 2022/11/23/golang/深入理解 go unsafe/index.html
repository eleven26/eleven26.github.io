<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eleven26.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学过 C 的朋友应该知道，有一种类型是指针类型，指针类型存储的是一个内存地址，通过这个内存地址可以找到它指向的变量。 go 虽然是一种高级语言，但是也还是给开发者提供了指针的类型 unsafe.Pointer，我们可以通过它来直接读写变量的内存。 正因为如此，如果我们操作不当，极有可能会导致程序崩溃。今天就来了解一下 unsafe 里所能提供的关于指针的一些功能， 以及使用 unsafe.Poin">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解 go unsafe">
<meta property="og:url" content="https://eleven26.github.io/2022/11/23/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20unsafe/index.html">
<meta property="og:site_name" content="eleven26">
<meta property="og:description" content="学过 C 的朋友应该知道，有一种类型是指针类型，指针类型存储的是一个内存地址，通过这个内存地址可以找到它指向的变量。 go 虽然是一种高级语言，但是也还是给开发者提供了指针的类型 unsafe.Pointer，我们可以通过它来直接读写变量的内存。 正因为如此，如果我们操作不当，极有可能会导致程序崩溃。今天就来了解一下 unsafe 里所能提供的关于指针的一些功能， 以及使用 unsafe.Poin">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/memory_0.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/memory_1.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/memory_2.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/pattern_1.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/pattern_1_2.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/pattern_1_3.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/pattern_1_4.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/pattern_2.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/pattern_3.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/pattern_3_2.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/pattern_3_3.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/pattern_4.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/bytes_0.png">
<meta property="og:image" content="https://eleven26.github.io/images/go/unsafe/bytes_1.png">
<meta property="article:published_time" content="2022-11-23T12:08:30.000Z">
<meta property="article:modified_time" content="2022-11-28T08:37:53.000Z">
<meta property="article:author" content="eleven26">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eleven26.github.io/images/go/unsafe/memory_0.png">


<link rel="canonical" href="https://eleven26.github.io/2022/11/23/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20unsafe/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://eleven26.github.io/2022/11/23/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20unsafe/","path":"2022/11/23/golang/深入理解 go unsafe/","title":"深入理解 go unsafe"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>深入理解 go unsafe | eleven26</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">eleven26</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">100</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">346</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">内存里面的二进制数据表示什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">2.</span> <span class="nav-text">内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-number">2.1.</span> <span class="nav-text">变量在内存中是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-number">2.2.</span> <span class="nav-text">结构体在内存中是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84"><span class="nav-number">2.3.</span> <span class="nav-text">指针在内存中是怎么存储的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%9C%9F%E7%9A%84%E6%98%AF%E6%88%91%E4%BB%AC%E4%B8%8A%E9%9D%A2%E8%AF%B4%E7%9A%84%E9%82%A3%E6%A0%B7%E5%90%97"><span class="nav-number">2.4.</span> <span class="nav-text">结构体的内存布局真的是我们上面说的那样吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uintptr-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">3.</span> <span class="nav-text">uintptr 是什么意思？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unsafe-%E5%8C%85%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">unsafe 包定义的三个新类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#arbitrarytype"><span class="nav-number">4.1.</span> <span class="nav-text">ArbitraryType</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#integertype"><span class="nav-number">4.2.</span> <span class="nav-text">IntegerType</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pointer"><span class="nav-number">4.3.</span> <span class="nav-text">Pointer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unsafe-%E5%8C%85%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">unsafe 包计算内存的三个方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sizeof"><span class="nav-number">5.1.</span> <span class="nav-text">Sizeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#offsetof-%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">Offsetof 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alignof-%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">Alignof 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unsafe.pointer-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">6.</span> <span class="nav-text">unsafe.Pointer 是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unsafe.pointer-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">7.</span> <span class="nav-text">unsafe.Pointer 类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88"><span class="nav-number">8.</span> <span class="nav-text">如何正确地使用指针？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86-t1-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%8C%87%E5%90%91-t2-%E7%9A%84-pointer"><span class="nav-number">8.1.</span> <span class="nav-text">1. 将 *T1
转换为指向 *T2 的 Pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86-pointer-%E8%BD%AC%E6%8D%A2%E4%B8%BA-uintptr%E4%BD%86%E4%B8%8D%E8%BD%AC%E6%8D%A2%E5%9B%9E-pointer"><span class="nav-number">8.2.</span> <span class="nav-text">2. 将
Pointer 转换为 uintptr（但不转换回
Pointer）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%B0%86-pointer-%E8%BD%AC%E6%8D%A2%E4%B8%BA-uintptr-%E5%B9%B6%E8%BD%AC%E6%8D%A2%E5%9B%9E%E5%8E%BB"><span class="nav-number">8.3.</span> <span class="nav-text">3.
使用算术运算将 Pointer 转换为 uintptr
并转换回去</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-syscall.syscall-%E6%97%B6%E5%B0%86%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2%E4%B8%BA-uintptr"><span class="nav-number">8.4.</span> <span class="nav-text">4. 调用
syscall.Syscall 时将指针转换为 uintptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86-reflect.value.pointer-%E6%88%96-reflect.value.unsafeaddr-%E7%9A%84%E7%BB%93%E6%9E%9C%E4%BB%8E-uintptr-%E8%BD%AC%E6%8D%A2%E4%B8%BA-pointer"><span class="nav-number">8.5.</span> <span class="nav-text">5.
将 reflect.Value.Pointer 或
reflect.Value.UnsafeAddr 的结果从 uintptr
转换为 Pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86-reflect.sliceheader-%E6%88%96-reflect.stringheader-%E7%9A%84-data-%E5%AD%97%E6%AE%B5%E8%B7%9F-pointer-%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="nav-number">8.6.</span> <span class="nav-text">6.
将 reflect.SliceHeader 或 reflect.StringHeader
的 Data 字段跟 Pointer 互相转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#add-%E5%87%BD%E6%95%B0"><span class="nav-number">9.</span> <span class="nav-text">Add 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slice-%E5%87%BD%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">Slice 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%BE%88%E5%B8%B8%E8%A7%81%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">11.</span> <span class="nav-text">一个很常见的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">12.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eleven26</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eleven26" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eleven26" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/11/23/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20unsafe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="深入理解 go unsafe | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解 go unsafe
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-23 20:08:30" itemprop="dateCreated datePublished" datetime="2022-11-23T20:08:30+08:00">2022-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>学过 C
的朋友应该知道，有一种类型是指针类型，指针类型存储的是一个内存地址，通过这个内存地址可以找到它指向的变量。
go 虽然是一种高级语言，但是也还是给开发者提供了指针的类型
<code>unsafe.Pointer</code>，我们可以通过它来直接读写变量的内存。
正因为如此，如果我们操作不当，极有可能会导致程序崩溃。今天就来了解一下
<code>unsafe</code> 里所能提供的关于指针的一些功能， 以及使用
<code>unsafe.Pointer</code> 的一些注意事项。</p>
<h2
id="内存里面的二进制数据表示什么">内存里面的二进制数据表示什么？</h2>
<p>我们知道，计算机存储数据的时候是以二进制的方式存储的，当然，内存里面存储的数据也是二进制的。二进制的
01 本身其实并没有什么特殊的含义。</p>
<p>它们的具体含义完全取决于我们怎么去理解它们，比如
<code>0010 0000</code>，如果我们将其看作是一个十进制数字，那么它就是
32， 如果我们将其看作是字符，那么他就是一个空格（具体可参考 ASCII
码表）。</p>
<p>对应到编程语言层面，其实我们的变量存储在内存里面也是 01
表示的二进制，这些二进制数表示是什么类型都是语言层面的事，
更准确来说，是编译器来处理的，我们写代码的时候将变量声明为整数，那么我们取出来的时候也会表示成一个整数。</p>
<p><strong>这跟本文有什么关系呢？我们下面会讲到很多关于类型转换的内容，如果我们理解了这一节说的内容，下面的内容会更容易理解</strong></p>
<p><strong>在我们做类型转换的时候，实际上底层的二进制表示是没有变的，变的只是我们所看到的表面的东西。</strong></p>
<h2 id="内存布局">内存布局</h2>
<p>有点想直接开始讲 <code>unsafe</code> 里的 <code>Pointer</code>
的，但是如果读者对计算机内存怎么存储变量不太熟悉的话，
看起来可能会比较费解，所以在文章开头会花比较大的篇幅来讲述计算机是怎么存储数据的，
相信读完会再阅读后面的内容（比如指针的算术运算、通过指针修改结构体字段）会没有那么多障碍。</p>
<h3 id="变量在内存中是怎样的">变量在内存中是怎样的？</h3>
<p>我们先来看一段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int8</span> = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="type">int16</span> = <span class="number">2</span></span><br><span class="line">	<span class="comment">// unsafe.Sizeof() 可以获取存储变量需要的内存大小，单位为字节</span></span><br><span class="line">	<span class="comment">// 输出：1 2</span></span><br><span class="line">	<span class="comment">// int8 意味着，用 8 位，也就是一个字节来存储整型数据</span></span><br><span class="line">	<span class="comment">// int16 意味着，用 16 位，也就是两个字节来存储整型数据</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(a), unsafe.Sizeof(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中我们定义了两个变量，占用一个字节的 <code>a</code>
和占用两个字节的 <code>b</code>，在内存中它们大概如下图：</p>
<p><img src="/images/go/unsafe/memory_0.png" /></p>
<p>我们可以看到，在图中，<code>a</code> 存储在低地址，占用一个字节，而
<code>b</code> 存储在 <code>a</code> 相邻的地方，占用两个字节。</p>
<h3 id="结构体在内存中是怎样的">结构体在内存中是怎样的？</h3>
<p>我们再来看看结构体在内存中的存储：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line">	<span class="comment">// 输出：2 1 1</span></span><br><span class="line">	<span class="comment">// 意味着 p 占用两个字节，</span></span><br><span class="line">	<span class="comment">// 其中 age 占用一个字节，score 占用一个字节</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(p), unsafe.Sizeof(p.age), unsafe.Sizeof(p.score))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，我们定义了一个 <code>Person</code> 结构体，其中两个字段
<code>age</code> 和 <code>score</code> 都是 <code>int8</code>
类型，都是只占用一个字节的，它的内存布局大概如下图：</p>
<p><img src="/images/go/unsafe/memory_1.png" /></p>
<p>我们可以看到，在内存中，结构体字段是占用了内存中连续的一段存储空间的，具体来说是占用了连续的两个字节。</p>
<h3 id="指针在内存中是怎么存储的">指针在内存中是怎么存储的？</h3>
<p>在下面的代码中，我们定义了一个 <code>a</code> 变量，大小为 1
字节，然后我们定义了一个指向 <code>a</code> 的指针 <code>p</code>：</p>
<p>需要先说明的是，下面有两个操作符，一个是
<code>&amp;</code>，这个是取地址的操作符，<code>var p = &amp;a</code>
意味着，取得 <code>a</code> 的内存地址，将其存储在变量 <code>p</code>
中， 另一个操作符是
<code>*</code>，这个操作符的意思是解指针，<code>*p</code> 就是通过
<code>p</code> 的地址取得 <code>p</code> 指向的内容（也就是
<code>a</code>）然后进行操作。 <code>*p = 4</code> 意味着，将
<code>p</code> 指向的 <code>a</code> 修改为 4。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int8</span> = <span class="number">3</span></span><br><span class="line">	<span class="comment">// ... 其他变量</span></span><br><span class="line">	<span class="keyword">var</span> p = &amp;a</span><br><span class="line">	fmt.Println(unsafe.Sizeof(p))</span><br><span class="line">	fmt.Println(*p) <span class="comment">// 3</span></span><br><span class="line">	*p = <span class="number">4</span></span><br><span class="line">	fmt.Println(a) <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/go/unsafe/memory_2.png" /></p>
<p>需要注意的是，这里面不再是一个单元格一个字节了，<code>p</code>（指针变量）是要占用
8 个字节的（这个跟机器有关，我的是 64 位的 CPU，所以是 8 个字节）。</p>
<blockquote>
<p>从这个图，我们可以得知，指针实际上存储的是一个内存地址，通过这个地址我们可以找到它实际存储的内容。</p>
</blockquote>
<h3
id="结构体的内存布局真的是我们上面说的那样吗">结构体的内存布局真的是我们上面说的那样吗？</h3>
<p>上面我们说了，下面这个结构体占用了两个字节，结构体里面的一个字段占用一个字节：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再来看看下面这个结构体，它会占用多少字节呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int16</span> <span class="comment">// 类型由 int8 改为了 int16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许我们这个时候已经算好了 <code>1 + 2 = 3</code>，3
个字节不是吗？说实话，真的不是，它会占用 4 个字节，
这可能会有点反常理，但是这跟计算机的体系结构有着密切的关系，先看具体的运行结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line">	<span class="comment">// 输出：4 1 2</span></span><br><span class="line">	<span class="comment">// 意味着 p 占用 4 个字节，</span></span><br><span class="line">	<span class="comment">// 其中 age 占用 2 个字节，score 占用 2 个字节</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(p), unsafe.Sizeof(p.age), unsafe.Sizeof(p.score))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会这样呢？因为 CPU
运行的时候，需要从内存读取数据，而从内存取数据的过程是按字读取的，如果我们数据的内存没有对齐，
则可能会导致 CPU
本来一次可以读取完的数据现在需要多次读取，这样就会造成效率的下降。</p>
<p>关于内存对齐，是一个比较庞大的话题，这里不展开了，我们需要明确的是，go
编译器会对我们的结构体字段进行内存对齐。</p>
<blockquote>
<p>内存对我们的影响就是，它可能会导致结构体所占用的空间比它字段类型所需要的空间大（所以我们做指针的算术运算的时候需要非常注意），
具体大多少其实我们其实不需要知道，因为有方法可以知道，哪就是
<code>unsafe.Offsetof</code>，下面会说到。</p>
</blockquote>
<h2 id="uintptr-是什么意思">uintptr 是什么意思？</h2>
<p>在开始下文之前，还是得啰嗦一句，<code>uintptr</code> 这种命名方式是 C
语言里面的一种类型命名的惯例， <code>u</code>
前缀表示是无符号数（unsigned），<code>ptr</code>
是指针（pointer）的缩写，这个 <code>uintptr</code>
按这个命名惯例解析的话，就是一个指向无符号整数的指针。</p>
<p>另外，还有另外一种命名惯例，就是在整型类型的后面加上一个表示占用 bit
数的数字，（1字节=8bit） 比如 <code>int8</code> 表示一个占用 8
位的整数，只可以存储 1 个字节的数据，然后 <code>int64</code>
表示的是一个 8 字节数（64位）。</p>
<h2 id="unsafe-包定义的三个新类型">unsafe 包定义的三个新类型</h2>
<h3 id="arbitrarytype">ArbitraryType</h3>
<p><code>type ArbitraryType int</code>，这个类型实际上是一个
<code>int</code> 类型，但是从名字上我们可以看到，它被命名为任意类型，
也就是说，他会被我们用来表示任意的类型，具体怎么用，是下面说的
<code>unsafe.Pointer</code> 用的。</p>
<h3 id="integertype">IntegerType</h3>
<p><code>type IntegerType int</code>，它表示的是一个任意的整数，在
<code>unsafe</code> 包中它被用来作为表示切片或者指针加减的长度。</p>
<h3 id="pointer">Pointer</h3>
<p><code>type Pointer *ArbitraryType</code>，这个就是我们上一节提到的指针了，它可以指向任何类型的数据（<code>*ArbitraryType</code>）。</p>
<blockquote>
<p>内存地址实际上就是计算机内存的编号，是一个整数，所以我们才可以使用
<code>int</code> 来表示指针。</p>
</blockquote>
<h2 id="unsafe-包计算内存的三个方法">unsafe 包计算内存的三个方法</h2>
<p>这几个方法在我们对内存进行操作的时候会非常有帮助，因为根据这几个方法，我们才可以得知底层数据类型的实际大小。</p>
<h3 id="sizeof">Sizeof</h3>
<p>计算 <code>x</code>
所需要的内存大小（单位为字节），如果其中包含了引用类型，<code>Sizeof</code>
不会计算引用指向的内容的大小。</p>
<p>有几种常见的情况（没有涵盖全部情况）：</p>
<ul>
<li>基本类型，如
<code>int8</code>、<code>int</code>，<code>Sizeof</code>
返回的是这个类型本身的大小，如 <code>unsafe.Sizeof(int8(x))</code> 为
1，因为 <code>int8</code> 只占用一个字节。</li>
<li>引用类型，如 <code>var x *int</code>，<code>Sizeof(x)</code> 会返回
8（在我的机器上，不同机器可能不一样），另外就算引用指向了一个复合类型，比如结构体，返回的还是
8（因为变量本身存储的只是内存地址）。</li>
<li>结构体类型，如果是结构体，那么 <code>Sizeof</code>
返回的大小包含了用于内存对齐的内存（所以可能会比结构体底层类型所需要的实际大小要大）</li>
<li>切片，<code>Sizeof</code> 返回的是
24（返回的是切片这个类型所需要占用空间的大小，我们需要知道，切片底层是
<code>slice</code> 结构体，里面三个字段分别是
<code>array unsafe.Pointer</code>、<code>len int</code> 和
<code>cap int</code>，这三个字段所需要的大小为 24）</li>
<li>字符串，跟切片类似，<code>Sizeof</code> 会返回
16，因为字符串底层是一个用来存储字符串内容的 <code>unsafe.Pointer</code>
指针和一个表示长度的 <code>int</code>，所以是 16。</li>
</ul>
<blockquote>
<p>这个方法返回的大小跟机器密切相关，但一般开发者的电脑都是 64
位的，调用这个函数的值应该跟我的机器上得到的一样。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> School <span class="keyword">struct</span> &#123;</span><br><span class="line">	students []Person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int8</span></span><br><span class="line">	<span class="keyword">var</span> y <span class="type">int</span></span><br><span class="line">	<span class="comment">// 1 8</span></span><br><span class="line">	<span class="comment">// int8 占用 1 个字节，int 占用 8 个字节</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(x), unsafe.Sizeof(y))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">	<span class="comment">// 8</span></span><br><span class="line">	<span class="comment">// 指针变量占用 8 个字节</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(p))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> person Person</span><br><span class="line">	<span class="comment">// 4</span></span><br><span class="line">	<span class="comment">// age 内存对齐需要 2 个字节</span></span><br><span class="line">	<span class="comment">// score 也需要两个字节</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(person))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> school School</span><br><span class="line">	<span class="comment">// 24</span></span><br><span class="line">	<span class="comment">// 只有一个切片字段，切片需要 24 个字节</span></span><br><span class="line">	<span class="comment">// 不管这个切片里面有多少数据，school 所需要占用的内存空间都是 24 字节</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(school))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">	<span class="comment">// 16</span></span><br><span class="line">	<span class="comment">// 字符串底层是一个 unsafe.Pointer 和一个 int</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="offsetof-方法">Offsetof 方法</h3>
<p>这个方法用于计算结构体字段的内存地址相对于结构体内存地址的偏移。具体来说就是，我们可以通过
<code>&amp;</code>（取地址）操作符获取结构体地址。</p>
<blockquote>
<p>实际上，结构体地址就是结构体中第一个字段的地址。</p>
</blockquote>
<p>拿到了结构体的地址之后，我们可以通过 <code>Offsetof</code>
方法来获取结构体其他字段的偏移量，下面是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> person Person</span><br><span class="line">	<span class="comment">// 0 2</span></span><br><span class="line">	<span class="comment">// person.age 是第一个字段，所以是 0</span></span><br><span class="line">	<span class="comment">// person.score 是第二个字段，因为需要内存对齐，实际上 age 占用了 2 个字节，</span></span><br><span class="line">	<span class="comment">// 因此 unsafe.Offsetof(person.score) 是 2，也就是说从第二个字节开始才是 person.score</span></span><br><span class="line">	fmt.Println(unsafe.Offsetof(person.age), unsafe.Offsetof(person.score))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们上面也说了，编译器会对结构体做一些内存对齐的操作，这会导致结构体底层字段占用的内存大小会比实际需要的大小要大。
因此，我们在取结构体字段地址的时候，最好是通过结构体地址加上
<code>unsafe.Offsetof(x.y)</code> 拿到的地址来操作。如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age   <span class="type">int8</span></span><br><span class="line">	score <span class="type">int16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> person = Person&#123;</span><br><span class="line">		age:   <span class="number">10</span>,</span><br><span class="line">		score: <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// &#123;10 20&#125;</span></span><br><span class="line">	fmt.Println(person)</span><br><span class="line">	<span class="comment">// 取得 score 字段的指针</span></span><br><span class="line">	<span class="comment">// 通过结构体地址，加上 score 字段的偏移量，得到 score 字段的地址</span></span><br><span class="line">	score := (*<span class="type">int16</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;person)) + unsafe.Offsetof(person.score)))</span><br><span class="line">	*score = <span class="number">30</span></span><br><span class="line">	<span class="comment">// &#123;10 30&#125;</span></span><br><span class="line">	fmt.Println(person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子看起来有点复杂，但是没关系，后面会详细展开的，这里主要要说明的是：</p>
<p>我们通过 <code>unsafe.Pointer</code>
来操作结构体底层字段的时候，我们是通过 <code>unsafe.Offsetof</code>
来获取结构体字段地址偏移量的，
因为我们看到的类型大小并不是内存实际占用的大小，通过
<code>Offsetof</code> 拿到的结果是已经将内存对齐等因素考虑在内的了。
（如果我们错误的认为 <code>age</code> 只占用一个字节，然后将
<code>unsafe.Offsetof(person.score)</code> 替换为 1，那么我们就修改不了
score 字段了）</p>
<h3 id="alignof-方法">Alignof 方法</h3>
<p>这个方法用以获取某一个类型的对齐系数，就是对齐一个类型的时候需要多少个字节。
这个对开发者而言意义不是非常大，go 里面只有 <code>WaitGroup</code>
用到了一下，
没有看到其他地方有用到这个方法，所以本文不展开了，有兴趣的自行了解。</p>
<h2 id="unsafe.pointer-是什么">unsafe.Pointer 是什么？</h2>
<p>让我们再来回顾一下，<code>Pointer</code> 的定义是
<code>type Pointer *ArbitraryType</code>，也就是一个指向任意类型的指针类型。
首先它是指针类型，所以我们初始化 <code>unsafe.Pointer</code>
的时候，需要通过 <code>&amp;</code>
操作符来将变量的地址传递进去。我们可以将其想象为指针类型的包装类型。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">	<span class="comment">// 打印出 a 的地址：0xc0000240a8</span></span><br><span class="line">	fmt.Println(unsafe.Pointer(&amp;a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unsafe.pointer-类型转换">unsafe.Pointer 类型转换</h2>
<p>在使用 <code>unsafe.Pointer</code>
的时候，往往需要另一个类型来配合，那就是 <code>uintptr</code>，这个
<code>uintptr</code> 在文档里面的描述是： <code>uintptr</code>
是一种整数类型，其大小足以容纳<strong>任何指针</strong>的位模式。这里的关键是
"任何指针"，
也就是说，<strong>它设计出来是被用来存储指针的，而且其大小保证能存储下任何指针。</strong></p>
<p>而我们知道 <code>unsafe.Pointer</code> 也是表示指针，那么
<code>uintptr</code> 跟 <code>unsafe.Pointer</code> 有什么区别呢？</p>
<p><strong>只需要记住最关键的一点，<code>uintptr</code>
是内存地址的整数表示，而且可以进行算术运算，而
<code>unsafe.Pointer</code>
除了可以表示一个内存地址之外，还能保证其指向的内存不会被垃圾回收器回收，但是
<code>uintptr</code>
这个地址不能保证其指向的内存不被垃圾回收器回收。</strong></p>
<p>我们先来看看与 <code>unsafe.Pointer</code>
相关的几种类型转换，这在我们下文几乎所有地方都会用到：</p>
<ul>
<li>任何类型的指针值都能转换为 <code>unsafe.Pointer</code></li>
<li><code>unsafe.Pointer</code> 可以转换为一个指向任何类型的指针值</li>
<li><code>unsafe.Pointer</code> 可以转换为 <code>uintptr</code></li>
<li><code>uintptr</code> 可以转换为 <code>unsafe.Pointer</code></li>
</ul>
<p>例子（下面这个例子中输出的地址都是变量 <code>a</code>
所在的内存地址，都是一样的地址）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> p = &amp;a</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. int 类型指针转换为 unsafe.Pointer</span></span><br><span class="line">	fmt.Println(unsafe.Pointer(p)) <span class="comment">// 0xc0000240a8</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. unsafe.Pointer 转换为普通类型的指针</span></span><br><span class="line">	pointer := unsafe.Pointer(&amp;a)</span><br><span class="line">	<span class="keyword">var</span> pp *<span class="type">int</span> = (*<span class="type">int</span>)(pointer) <span class="comment">// 0xc0000240a8</span></span><br><span class="line">	fmt.Println(pp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. unsafe.Pointer 可以转换为 uintptr</span></span><br><span class="line">	<span class="keyword">var</span> p1 = <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, p1) <span class="comment">// c0000240a8，没有 0x 前缀</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. uintptr 可以转换为 unsafe.Pointer</span></span><br><span class="line">	p2 := unsafe.Pointer(p1)</span><br><span class="line">	fmt.Println(p2) <span class="comment">// 0xc0000240a8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何正确地使用指针">如何正确地使用指针？</h2>
<p>指针允许我们忽略类型系统而对任意内存进行读写，这是非常危险的，所以我们在使用指针的时候要格外的小心。</p>
<p>我们使用 <code>Pointer</code>
的模式有以下几种，如果我们不是按照以下模式来使用 <code>Pointer</code>
的话，那使用的方式很可能是无效的，
或者在将来变得无效，但就算是下面的几种使用模式，也有需要注意的地方。</p>
<p>运行 <code>go vet</code> 可以帮助查找不符合这些模式的
<code>Pointer</code> 的用法，但 <code>go vet</code>
没有警告也并不能保证代码有效。</p>
<p>以下我们就来详细学习一下使用 <code>Pointer</code>
的几种正确的模式：</p>
<h3 id="将-t1-转换为指向-t2-的-pointer">1. 将 <code>*T1</code>
转换为指向 <code>*T2</code> 的 <code>Pointer</code></h3>
<p>前提条件：</p>
<ul>
<li><code>T2</code> 类型所需要的大小不大于 <code>T1</code>
类型的大小。（大小大的类型转换为占用空间更小的类型）</li>
<li><code>T1</code> 和 <code>T2</code> 的内存布局一样。</li>
</ul>
<blockquote>
<p>这是因为如果直接将占用空间小的类型转换为占用空间更大的类型的话，多出来的部分是不确定的内容，当然我们也可以通过
<code>unsafe.Pointer</code> 来修改这部分内容。</p>
</blockquote>
<p>这种转换允许将一种类型的数据重新解释为另外一种数据类型。下面是一个例子（为了方便演示用了
<code>int32</code> 和 <code>int8</code> 类型）：</p>
<blockquote>
<p>在这个例子中，<code>int8</code> 类型不大于 <code>int32</code>
类型，而且它们的内存布局是一样的，所以可以转换。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int32</span> = <span class="number">2</span></span><br><span class="line">	<span class="comment">// p 是 *int8 类型，由 *int32 转换而来</span></span><br><span class="line">	<span class="keyword">var</span> p = (*<span class="type">int8</span>)(unsafe.Pointer(&amp;a))</span><br><span class="line">	<span class="keyword">var</span> b <span class="type">int8</span> = *p</span><br><span class="line">	fmt.Println(b) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>unsafe.Pointer(&amp;a)</code> 是指向 <code>a</code> 的
<code>unsafe.Pointer</code>（本质上是指向 <code>int32</code>
的指针），<code>(*int8)</code> 表示类型转换，将这个
<code>unsafe.Pointer</code> 转换为 <code>(*int8)</code> 类型。</p>
<p>觉得代码不好理解的可以看下图：</p>
<p><img src="/images/go/unsafe/pattern_1.png" /></p>
<p>在上图，我们实际上是创建了一个指向了 <code>a</code> 最低位那 1
字节的指针，然后取出了这个字节里面存储的内容，将其存入了 <code>b</code>
中。</p>
<p>上面提到有一个比较重要的地方，那就是：转换的时候是占用空间大的类型，转换为占用空间小的类型，比如
<code>int32</code> 转 <code>int8</code> 就是符合这个条件的，
那么如果我们将一个小的类型转换为大的类型会发生什么呢？我们来看看下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">	b <span class="type">int8</span></span><br><span class="line">	c <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = A&#123;<span class="number">1</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> b = B&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 大转小</span></span><br><span class="line">	<span class="keyword">var</span> pa = (*A)(unsafe.Pointer(&amp;b))</span><br><span class="line">	fmt.Println(*pa) <span class="comment">// &#123;2&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 错误示例：小转大（危险，A 里面 a 后面的内存其实是未知的）</span></span><br><span class="line">	<span class="keyword">var</span> pb = (*B)(unsafe.Pointer(&amp;a))</span><br><span class="line">	fmt.Println(*pb) <span class="comment">// &#123;1 2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大转小：<code>*B</code> 转换为 <code>*A</code>
的具体转换过程可以表示为下图：</p>
<p><img src="/images/go/unsafe/pattern_1_2.png" /></p>
<p>在这个过程中，其实 <code>a</code> 和 <code>b</code>
都没有改变，本质上我们只是创建了一个 <code>A</code> 类型的指针，
这个指针指向变量 <code>b</code> 的地址（但是 <code>*pa</code> 会被看作是
<code>A</code> 类型），所以 <code>pa</code> 实际上是跟 <code>b</code>
共享了内存。 我们可以尝试修改 <code>(*pa).a = 3</code>，我们就会发现
<code>b.b</code> 也变成了 3。</p>
<p>也就是说，最终的内存布局是下图这样的：</p>
<p><img src="/images/go/unsafe/pattern_1_3.png" /></p>
<p>小转大：<code>*A</code> 转换为 <code>*B</code>
的具体转换过程可以表示为下图：</p>
<p><img src="/images/go/unsafe/pattern_1_4.png" /></p>
<p><strong>注意：这是错误的用法。(当然也不是完全不行)</strong></p>
<p>在 <code>*A</code> 转换为 <code>*B</code> 的过程中，因为
<code>B</code> 需要 2 个字节空间，所以我们拿到的 <code>pb</code>
实际上是包含了 <code>a</code> 后面的 1 个字节，
<strong>但是这个字节本来是属于 <code>b</code> 变量的</strong>，这个时候
<code>b</code> 和 <code>*pb</code> 都引用了第 2
个字节，这样依赖它们在修改这个字节的时候，
会相互影响，这可能不是我们想要的结果，而且这种操作非常危险。</p>
<h3 id="将-pointer-转换为-uintptr但不转换回-pointer">2. 将
<code>Pointer</code> 转换为 <code>uintptr</code>（但不转换回
<code>Pointer</code>）</h3>
<p>将 <code>Pointer</code> 转换为 <code>uintptr</code> 会得到
<code>Pointer</code> 指向的内存地址，是一个整数。这种
<code>uintptr</code> 的通常用途是打印它。</p>
<p>但是，<strong>将 <code>uintptr</code> 转换回 <code>Pointer</code>
通常无效</strong>。 <code>uintptr</code>
是一个整数，而不是一个引用。将指针转换为 <code>uintptr</code>
会创建一个没有指针语义的整数值。 即使 <code>uintptr</code>
持有某个对象的地址，如果该对象移动，垃圾收集器也不会更新该
<code>uintotr</code> 的值， 也不会阻止该对象被回收。</p>
<p>如下面这种，我们取得了变量的地址
<code>p</code>，然后做了一些其他操作，最后再从这个地址里面读取数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> p = <span class="type">uintptr</span>(unsafe.Pointer(&amp;a))</span><br><span class="line">	<span class="comment">// ... 其他代码</span></span><br><span class="line">	<span class="comment">// 下面这种转换是危险的，因为有可能 p 指向的对象已经被垃圾回收器回收</span></span><br><span class="line">	fmt.Println(*(*<span class="type">int</span>)(unsafe.Pointer(p)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体如下图：</p>
<p><img src="/images/go/unsafe/pattern_2.png" /></p>
<p>只有下面的模式中转换 <code>uintptr</code> 到 <code>Pointer</code>
是有效的。</p>
<h3 id="使用算术运算将-pointer-转换为-uintptr-并转换回去">3.
使用算术运算将 <code>Pointer</code> 转换为 <code>uintptr</code>
并转换回去</h3>
<p>如果 <code>p</code> 指向一个已分配的对象，我们可以将 <code>p</code>
转换为 <code>uintptr</code> 然后加上一个偏移量，再转换回
<code>Pointer</code>。如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = unsafe.Pointer(<span class="type">uintptr</span>(p) + offset)</span><br></pre></td></tr></table></figure>
<p>这种模式最常见的用法是访问结构体或者数组元素中的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于 f := unsafe.Pointer(&amp;s.f)</span></span><br><span class="line">f := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 e := unsafe.Pointer(&amp;x[i])</span></span><br><span class="line">e := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;x)) + i*unsafe.Sizeof(x[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<p>对于第一个例子，完整代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">	d <span class="type">int8</span></span><br><span class="line">	f <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s = S&#123;</span><br><span class="line">		d: <span class="number">1</span>,</span><br><span class="line">		f: <span class="number">2</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	f := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))</span><br><span class="line">	fmt.Println(*(*<span class="type">int8</span>)(f)) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的内存布局如下图（<code>s</code> 的两个字段都是 1 字节，所以图中
<code>d</code> 和 <code>f</code> 都是 1 字节）：</p>
<p><img src="/images/go/unsafe/pattern_3.png" /></p>
<p>详细说明一下：</p>
<blockquote>
<p>第一小节我们说过了，结构体字段的内存布局是连续的。上面没有说的是，其实数组的内存布局也是连续的。这对理解下面的内容很有帮助。</p>
</blockquote>
<ul>
<li><code>&amp;s</code> 取得了结构体 <code>s</code> 的地址</li>
<li><code>unsafe.Pointer(&amp;s)</code> 转换为 <code>Pointer</code>
对象，这个指针对象指向的是结构体 <code>s</code></li>
<li><code>uintptr(unsafe.Pointer(&amp;s))</code> 取得
<code>Pointer</code> 对象的内存地址（整数）</li>
<li><code>unsafe.Offsetof(s.f)</code> 取得了 <code>f</code>
字段的内存偏移地址（相对地址，相对于 <code>s</code> 的地址）</li>
<li><code>uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f)</code>
就是 <code>s.f</code> 的实际内存地址了（绝对地址）</li>
<li>最后转换回 <code>unsafe.Pointer</code> 对象，这个对象指向的地址是
<code>s.f</code> 的地址</li>
</ul>
<p>最终 <code>f</code> 指向的地址是 <code>s.f</code>，然后我们可以通过
<code>(*int8)(f)</code> 将 <code>unsafe.Pointer</code> 转换为
<code>*int8</code> 类型指针，最后通过 <code>*</code>
操作符取得这个指针指向的值。</p>
<p>对于第二个例子，完整代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x = [<span class="number">3</span>]<span class="type">int8</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	e := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;x)) + <span class="number">2</span>*unsafe.Sizeof(x[<span class="number">0</span>]))</span><br><span class="line">	fmt.Println(*(*<span class="type">int8</span>)(e)) <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的内存布局如下图，<code>e</code> 指向了数组的第 3 个元素（下标从
0 开始算的）：</p>
<p><img src="/images/go/unsafe/pattern_3_2.png" /></p>
<blockquote>
<p>代码中的 2 可以是其他任何有效的数组下标。</p>
</blockquote>
<ul>
<li><code>&amp;s</code> 取得了数组 <code>x</code> 的地址</li>
<li><code>unsafe.Pointer(&amp;x)</code> 转换为 <code>Pointer</code>
对象，这个指针对象指向的是数组 <code>x</code></li>
<li><code>uintptr(unsafe.Pointer(&amp;x))</code> 取得
<code>Pointer</code> 对象的内存地址（也就是 <code>0xab</code>）</li>
<li><code>unsafe.Sizeof(x[0])</code> 是数组 <code>x</code>
里面每一个元素所需要的内存大小，乘以 <code>2</code> 表示是元素
<code>x[2]</code> 的地址偏移量（相对地址，相对于 <code>x[0]</code>
的地址）</li>
<li><code>uintptr(unsafe.Pointer(&amp;x)) + 2*unsafe.Sizeof(x[0])</code>
表示的是数组元素 <code>x[2]</code> 的实际内存地址（绝对地址）</li>
<li>最后转换回 <code>unsafe.Pointer</code> 对象，这个对象指向的地址是
<code>x[2]</code> 的地址（也就是 <code>0xab + 2</code>）。</li>
</ul>
<p>最终，我们可以通过 <code>(*int8)</code> 将 <code>e</code> 转换为
<code>*int8</code> 类型的指针，最后通过 <code>*</code>
操作符获取其指向的内容，也就是 6。</p>
<p>以这种方式对指针进行加减偏移量的运算都是有效的。(em...这里说的是写在同一行的这种方式)。这种情况下使用
<code>&amp;^</code> 这两个操作符也是有效的（通常用于内存对齐）。
在所有情况下，得到的结果必须指向原始分配的对象。</p>
<p>不像 C
语言，将指针加上一个超出其原始分配的内存区域的偏移量是无效的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效: end 指向了分配的空间以外的区域</span></span><br><span class="line"><span class="keyword">var</span> s thing</span><br><span class="line">end = unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Sizeof(s))</span><br></pre></td></tr></table></figure>
<p><img src="/images/go/unsafe/pattern_3_3.png" /></p>
<blockquote>
<p>下面对切片的这种操作也跟上图类似。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效: end 指向了分配的空间以外的区域</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">end = unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>])) + <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>
<p>这是因为，内存的地址范围是
<code>[start, end)</code>，是不包含终点的那个地址的，上面的
<code>end</code> 都指向了地址的边界，这是无效的。
当然，除了边界上，边界以外都是无效的。（<code>end</code>
指向的内存不是属于那个变量的）</p>
<p>注意：两个转换(<code>Pointer</code> =&gt; <code>uintptr</code>,
<code>uintptr</code> =&gt;
<code>Pointer</code>)必须出现在同一个表达式中，只有中间的算术运算：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效: uintptr 在转换回 Pointer 之前不能存储在变量中</span></span><br><span class="line"><span class="comment">// 原因上面也说过了，就是 p 指向的内容可能会被垃圾回收器回收。</span></span><br><span class="line">u := <span class="type">uintptr</span>(p)</span><br><span class="line">p = unsafe.Pointer(u + offset)</span><br></pre></td></tr></table></figure>
<p>注意：指针必须指向已分配的对象，因此它不能是 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效: nil 指针转换</span></span><br><span class="line">u := unsafe.Pointer(<span class="literal">nil</span>)</span><br><span class="line">p := unsafe.Pointer(<span class="type">uintptr</span>(u) + offset)</span><br></pre></td></tr></table></figure>
<h3 id="调用-syscall.syscall-时将指针转换为-uintptr">4. 调用
<code>syscall.Syscall</code> 时将指针转换为 <code>uintptr</code></h3>
<p>觉得文字太啰嗦可以直接看图：</p>
<p><img src="/images/go/unsafe/pattern_4.png" /></p>
<p><code>syscall</code> 包中的 <code>Syscall</code> 函数将其
<code>uintptr</code>
参数直接传递给操作系统，然后操作系统可以根据调用的细节将其中一些参数重新解释为指针。
也就是说，系统调用实现隐式地将某些参数从 <code>uintptr</code>
转换回指针。</p>
<p>如果必须将指针参数转换为 <code>uintptr</code>
以用作参数，则该转换必须出现在调用表达式本身中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall.Syscall(SYS_READ, <span class="type">uintptr</span>(fd), <span class="type">uintptr</span>(unsafe.Pointer(p)), <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>
<p>编译器通过安排被引用的分配对象（如果有的话）被保留，并且在调用完成之前不移动，来处理在调用程序集中实现的函数的参数列表中转换为
<code>uintptr</code> 的指针，
即使仅从类型来看，在调用期间似乎不再需要对象。</p>
<p>为了使编译器识别该模式，转换必须出现在参数列表中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效：在系统调用期间隐式转换回指针之前，</span></span><br><span class="line"><span class="comment">// uintptr 不能存储在变量中。</span></span><br><span class="line">u := <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">syscall.Syscall(SYS_READ, <span class="type">uintptr</span>(fd), u, <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>
<h3
id="将-reflect.value.pointer-或-reflect.value.unsafeaddr-的结果从-uintptr-转换为-pointer">5.
将 <code>reflect.Value.Pointer</code> 或
<code>reflect.Value.UnsafeAddr</code> 的结果从 <code>uintptr</code>
转换为 <code>Pointer</code></h3>
<p><code>reflect.Value</code> 的 <code>Pointer</code> 和
<code>UnsafeAddr</code> 方法返回类型 <code>uintptr</code> 而不是
<code>unsafe.Pointer</code>， 从而防止调用者在未导入 <code>unsafe</code>
包的情况下将结果更改为任意类型。（这是为了防止开发者对
<code>Pointer</code> 的误操作。）
然而，<strong>这也意味着这个返回的结果是脆弱的，我们必须在调用之后立即转换为
<code>Pointer</code></strong>（如果我们确切的需要一个
<code>Pointer</code>）：</p>
<blockquote>
<p>其实就是为了让开发者明确自己知道在干啥，要不然写出了 bug
都不知道。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在调用了 reflect.Value 的 Pointer 方法后，</span></span><br><span class="line"><span class="comment">// 立即转换为 unsafe.Pointer。</span></span><br><span class="line">p := (*<span class="type">int</span>)(unsafe.Pointer(reflect.ValueOf(<span class="built_in">new</span>(<span class="type">int</span>)).Pointer()))</span><br></pre></td></tr></table></figure>
<p>与上述情况一样，在转换之前存储结果是无效的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效: uintptr 在转换回 Pointer 之前不能保存在变量中</span></span><br><span class="line">u := reflect.ValueOf(<span class="built_in">new</span>(<span class="type">int</span>)).Pointer() <span class="comment">// uintptr 保存到了 u 中</span></span><br><span class="line">p := (*<span class="type">int</span>)(unsafe.Pointer(u))</span><br></pre></td></tr></table></figure>
<p>原因上面也说了，因为 <code>u</code>
指向的内存是不受保护的，可能会被垃圾回收器收集。</p>
<h3
id="将-reflect.sliceheader-或-reflect.stringheader-的-data-字段跟-pointer-互相转换">6.
将 <code>reflect.SliceHeader</code> 或 <code>reflect.StringHeader</code>
的 <code>Data</code> 字段跟 <code>Pointer</code> 互相转换</h3>
<p>与前面的情况一样，反射数据结构 <code>SliceHeader</code> 和
<code>StringHeader</code> 将字段 <code>Data</code> 声明为
<code>uintptr</code>， 以防止调用者在不首先导入 <code>unsafe</code>
的情况下将结果更改为任意类型。 然而，这意味着 <code>SliceHeader</code>
和 <code>StringHeader</code>
仅在解析实际切片或字符串值的内容时有效。</p>
<p>我们先来看看这两个结构体的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SliceHeader 是切片的运行时表示（内存布局跟切片一致）</span></span><br><span class="line"><span class="comment">// 它不能安全或可移植地使用，其表示形式可能会在以后的版本中更改。</span></span><br><span class="line"><span class="comment">// 此外，Data 字段不足以保证它引用的数据不会被垃圾回收器收集，</span></span><br><span class="line"><span class="comment">// 因此程序必须保留一个指向底层数据的单独的、正确类型的指针。</span></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">	Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringHeader 字符串的运行时表示（内存布局跟字符串一致）</span></span><br><span class="line"><span class="comment">// ... 其他注意事项跟 SliceHeader 一样</span></span><br><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span></span><br><span class="line">    Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串的内容修改为 p 指向的内容</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">hdr.Data = <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">hdr.Len = n</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种转换是有效的，因为 SliceHeader 的内存布局和 StringHeader
的内存布局一致，并且 SliceHeader 所占用的内存空间比 StringHeader
所占用内存空间大，也就是说，这是一种大小更大的类型转换为大小更小的类型，这会丢失
SliceHeader 的一部分数据，
但是丢失的那部分对我们程序正常运行是没有任何影响的。</p>
</blockquote>
<p>在这个用法中，<code>hdr.Data</code>
实际上是引用字符串头中的基础指针的另一种方式，而不是 uintptr 变量本身。
（我们这里也是使用了 <code>uintptr</code> 表达式，而不是一个存储了
<code>uintptr</code> 类型的变量）</p>
<p>通常来说，<code>reflect.SliceHeader</code> 和
<code>reflect.StringHeader</code> 通常用在指向实际切片或者字符串的
<code>*reflect.SliceHeader</code> 和
<code>*reflect.StringHeader</code>，<strong>永远不会被当作普通结构体使用</strong>。
程序不应该声明或者分配这些结构体类型的变量，下面的写法是有风险的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效: 直接声明的 Header 不会将 Data 作为引用</span></span><br><span class="line"><span class="keyword">var</span> hdr reflect.StringHeader</span><br><span class="line">hdr.Data = <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">hdr.Len = n</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;hdr)) <span class="comment">// p 可能已经丢失</span></span><br></pre></td></tr></table></figure>
<h2 id="add-函数">Add 函数</h2>
<p>函数原型是：<code>func Add(ptr Pointer, len IntegerType) Pointer</code></p>
<p>这个函数的作用是，可以将 <code>unsafe.Pointer</code>
类型加上一个偏移量得到一个指向新地址的 <code>unsafe.Pointer</code>。
简单点来说，就是对 <code>unsafe.Pointer</code>
做算术运算的，上面我们说过 <code>unsafe.Pointer</code>
是不能直接进行算术运算的， 因此需要先转换为 <code>uintptr</code>
然后再进行算术运算，算完再转换回 <code>unsafe.Pointer</code>
类型，所以会很繁琐。 有了 <code>Add</code>
方法，我们可以写得简单一些，不用做 <code>uintptr</code> 的转换。</p>
<p>有了
<code>Add</code>，我们可以简化一下上面那个通过数组指针加偏移量的例子，示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x = [<span class="number">3</span>]<span class="type">int8</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	<span class="comment">//e := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;x)) + 2*unsafe.Sizeof(x[0]))</span></span><br><span class="line">	e := unsafe.Add(unsafe.Pointer(&amp;x), <span class="number">2</span> * unsafe.Sizeof(x[<span class="number">0</span>]))</span><br><span class="line">	fmt.Println(*(*<span class="type">int8</span>)(e)) <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们先是通过 <code>unsafe.Pointer(&amp;x)</code>
获取到了一个指向 <code>x</code> 的 <code>unsafe.Pointer</code> 对象，
然后通过 <code>unsafe.Add</code> 加上了 2 个 <code>int8</code>
类型大小的偏移量，最终得到的是一个指向 <code>x[2]</code> 的
<code>unsafe.Pointer</code>。</p>
<blockquote>
<p><code>Add</code> 方法可以简化我们对指针的一些操作。</p>
</blockquote>
<h2 id="slice-函数">Slice 函数</h2>
<p><code>Slice</code>
函数的原型是：<code>func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType</code></p>
<p>函数 <code>Slice</code> 返回一个切片，其底层数组以 <code>ptr</code>
开头，长度和容量为 <code>len</code>。</p>
<p><code>unsafe.Slice(ptr, len)</code> 等价于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*[<span class="built_in">len</span>]ArbitraryType)(unsafe.Pointer(ptr))[:]</span><br></pre></td></tr></table></figure>
<p>除了这个，作为一种特殊情况，如果 <code>ptr</code> 为
<code>nil</code>，<code>len</code> 为零，则 <code>Slice</code> 返回
<code>nil</code>。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x = [<span class="number">6</span>]<span class="type">int8</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="comment">// 这里取了数组第一个元素 x[1] 的地址，</span></span><br><span class="line">	<span class="comment">// 从这个地址开始取了 3 个元素作为新的切片底层数组，</span></span><br><span class="line">	<span class="comment">// 返回这个新的切片</span></span><br><span class="line">	s := unsafe.Slice(&amp;x[<span class="number">1</span>], <span class="number">3</span>)</span><br><span class="line">	fmt.Println(s) <span class="comment">// [5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要非常注意的是，第一个参数实际上隐含传递了该地址对应的类型信息，上面用了
<code>&amp;x[1]</code>，传递的类型实际上是 <code>int8</code>。</p>
</blockquote>
<p>如果我们按照下面这样写，得到的结果就是错误的，因为它隐式传递的类型是
<code>[6]int8</code>（这是一个数组），而不是 <code>int8</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x = [<span class="number">6</span>]<span class="type">int8</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="comment">// unsafe.Slice 第一个参数接收到的类型是 [6]int，</span></span><br><span class="line">	<span class="comment">// 所以最终返回了一个切片，这个切片有三个元素，</span></span><br><span class="line">	<span class="comment">// 每一个元素都是长度为 6 数据类型为 int8 的数组。</span></span><br><span class="line">	<span class="comment">// 也即形如 [[6]int8, [6]int8, [6]int8] 的切片</span></span><br><span class="line">	s := unsafe.Slice(&amp;x, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// [[4 5 6 7 8 9] [91 91 52 32 53 32] [54 32 4 5 6 7]]</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样显然不是我们想要的结果，因为它读取到了一部分未知的内存，如果我们修改这部分内存，可能会造成程序崩溃。</p>
<h2 id="一个很常见的用法">一个很常见的用法</h2>
<p>在实际应用中，很多框架为了提高性能，在做 <code>[]byte</code> 和
<code>string</code> 的切换的时候，往往会使用 <code>unsafe.Pointer</code>
来实现（比如 <code>gin</code> 框架）：</p>
<p>下面这个例子实现了 <code>[]byte</code> 到 <code>string</code>
的转换，而且避免了内存分配。这是因为，切片和字符串的内存布局是一致的，只不过切片比字符串占用
的空间多了一点，还有一个 <code>cap</code>
容量字段，用来表示切片的容量是多少。具体我们可以再看看上面的
<code>reflect.SliceHeader</code> 和 <code>reflect.StringHeader</code>，
在下面这个字节切片到字符串的转换过程中，是从占用空间更大的类型转换为占用空间更小的类型，所以是安全的，丢失的那个
<code>cap</code> 对我们程序正常运行无影响。</p>
<p>先看看 <code>[]byte</code> 和 <code>string</code>
的类型底层定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	str unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片，比 string 的结构体多了一个 cap 字段，但是前面的两个字段是一样的</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>[]byte</code> 转字符串的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BytesToString</span><span class="params">(b []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 将 b 解析为字符串</span></span><br><span class="line">	<span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个操作如下图：</p>
<p><img src="/images/go/unsafe/bytes_0.png" /></p>
<p>在这个转换过程中，其实只是将 <code>b</code> 表示的类型转由
<code>[]byte</code> 转换为了 <code>string</code>，之所以可以这么转，
是因为 <code>[]byte</code> 的内存布局跟 <code>string</code>
的内存布局是一样的，
但是由于字符串实际占用空间比切片类型要小（不包括其底层指针指向的内容），
所以在转换过程中，<code>cap</code> 字段丢失了，但是 <code>strin</code>
也不需要这个字段，所以对程序运行没影响。</p>
<blockquote>
<p>同时字符串长度是按照字节计算的，所以字节切片和字符串的 len
字段是一样的，不需要做额外处理。</p>
</blockquote>
<p>字符串转 <code>[]byte</code> 的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringToBytes</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *(*[]<span class="type">byte</span>)(unsafe.Pointer(</span><br><span class="line">		<span class="comment">// 定义匿名结构体变量，内存布局跟 []byte 一致，</span></span><br><span class="line">		<span class="comment">// 这样就可以转换为 []byte 了。</span></span><br><span class="line">		&amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="type">string</span></span><br><span class="line">			Cap <span class="type">int</span></span><br><span class="line">		&#125;&#123;s, <span class="built_in">len</span>(s)&#125;,</span><br><span class="line">	))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个操作如下图：</p>
<p><img src="/images/go/unsafe/bytes_1.png" /></p>
<p>这个过程只是需要分配很小一部分内存就可以完成了，效率比 go
自带的转换高。</p>
<blockquote>
<p>go 里面字符串是不可变的，但 go
为了维持字符串不可变的特性，在字符串和字节切片之间转换一般都是通过数据拷贝的方式实现的。
因为这样就不会影响到原来的字符串或者字节切片了，但是这样做的性能会非常低。
具体可参考 <code>slicebytetostring</code> 和
<code>stringtoslicebyte</code> 函数，这两个函数位于
<code>runtime/string.go</code> 中。</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>本文主要讲了如下内容：</p>
<ul>
<li>内存布局：结构体的字段存储是占用了连续的一段内存，而且结构体可能会占用比实际需要空间更大的内存，因为需要对齐内存。</li>
<li>指针存储了指向变量的地址，对这个地址使用 <code>*</code>
操作符可以获取这个地址指向的内容。</li>
<li><code>uintptr</code> 是 C 里面的一种命名惯例，<code>u</code>
前缀的意思是 <code>unsigned</code>，<code>int</code> 表示是
<code>int</code> 类型，<code>ptr</code>
表示这个类型是用来表示指针的。</li>
<li><code>unsafe</code> 定义的 <code>Pointer</code>
类型是一种可以指向任何类型的指针，<code>ArbitraryType</code>
可用于表示任意类型。</li>
<li>我们通过 <code>unsafe.Pointer</code> 修改结构体字段的时候，要使用
<code>unsafe.Offsetof</code> 获取结构体的偏移量。</li>
<li>通过 <code>unsafe.Sizeof</code>
可以获得某一种类型所需要的内存空间大小（其中包括了用于内存对齐的内存）。</li>
<li><code>unsafe.Pointer</code> 与 <code>uintptr</code>
之间的类型转换。</li>
<li>几种使用 <code>unsafe.Pointer</code> 的模式：
<ul>
<li><code>*T1</code> 到 <code>*T2</code> 的转换</li>
<li><code>unsafe.Pointer</code> 转换为 <code>uintptr</code></li>
<li>使用算术运算将 <code>unsafe.Pointer</code> 转换为
<code>uintptr</code> 并转换回去（需要注意不能使用中间变量来保存
<code>uintptr(unsafe.Pointer(p))</code>）</li>
<li>调用 <code>syscall.Syscall</code> 时将指针转换为
<code>uintptr</code></li>
<li>将 <code>reflect.Value</code> 的 <code>Pointer</code> 和
<code>UnsafeAddr</code> 的结果从 <code>uintptr</code> 转换为
<code>unsafe.Pointer</code></li>
<li>将 <code>reflect.SliceHeader</code> 或
<code>reflect.StringHeader</code> 的 <code>Data</code> 字段跟
<code>Pointer</code> 互相转换</li>
</ul></li>
<li><code>Add</code> 函数可以简化指针的算术运算，不用来回转换类型（比如
<code>unsafe.Pointer</code> 转换为 <code>uintptr</code>，然后再转换为
<code>unsafe.Pointer</code>）。</li>
<li><code>Slice</code> 函数可以获取指针指向内存的一部分。</li>
<li>最后介绍了 <code>string</code> 和 <code>[]byte</code> 之间通过
<code>unsafe.Pointer</code> 实现高效转换的方法。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/11/20/golang/go%20Context%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" rel="prev" title="go Context 设计与实现">
                  <i class="fa fa-angle-left"></i> go Context 设计与实现
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/11/26/golang/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20go%20chan/" rel="next" title="深入理解 go chan">
                  深入理解 go chan <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">eleven26</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eleven26" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
