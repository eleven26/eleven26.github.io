<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eleven26.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="tcpdump 是一个命令行的网络流量分析工具，功能非常强大，一般我们用来抓 TCP 的包。  非常重要：如果 tcpdump 没有输出，尝试加上 -i any 选项。  tcpdump 核心参数图解  tcpdump 参数的组成部分： 1. option 可选参数 2. proto 类过滤器：根据协议进行过滤，可识别的关键词有：tcp, udp 等 3. type 类过滤器：可识别的关键词有：h">
<meta property="og:type" content="article">
<meta property="og:title" content="tcpdump 用法">
<meta property="og:url" content="https://eleven26.github.io/2022/07/06/linux/tcpdump%20%E7%94%A8%E6%B3%95/index.html">
<meta property="og:site_name" content="eleven26">
<meta property="og:description" content="tcpdump 是一个命令行的网络流量分析工具，功能非常强大，一般我们用来抓 TCP 的包。  非常重要：如果 tcpdump 没有输出，尝试加上 -i any 选项。  tcpdump 核心参数图解  tcpdump 参数的组成部分： 1. option 可选参数 2. proto 类过滤器：根据协议进行过滤，可识别的关键词有：tcp, udp 等 3. type 类过滤器：可识别的关键词有：h">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://eleven26.github.io/images/linux/tcpdump/args.png">
<meta property="og:image" content="https://eleven26.github.io/images/linux/tcpdump/header.png">
<meta property="article:published_time" content="2022-07-06T11:20:00.000Z">
<meta property="article:modified_time" content="2022-07-07T03:59:09.000Z">
<meta property="article:author" content="eleven26">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eleven26.github.io/images/linux/tcpdump/args.png">


<link rel="canonical" href="https://eleven26.github.io/2022/07/06/linux/tcpdump%20%E7%94%A8%E6%B3%95/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://eleven26.github.io/2022/07/06/linux/tcpdump%20%E7%94%A8%E6%B3%95/","path":"2022/07/06/linux/tcpdump 用法/","title":"tcpdump 用法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>tcpdump 用法 | eleven26</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">eleven26</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">100</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">346</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcpdump-%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E5%9B%BE%E8%A7%A3"><span class="nav-number">1.</span> <span class="nav-text">tcpdump 核心参数图解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3-tcpdump-%E7%9A%84%E8%BE%93%E5%87%BA"><span class="nav-number">2.</span> <span class="nav-text">理解 tcpdump 的输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">输出内容结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#flags-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">2.1.1.</span> <span class="nav-text">Flags 标识符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99"><span class="nav-number">3.</span> <span class="nav-text">常规过滤规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-ip-%E5%9C%B0%E5%9D%80%E8%BF%87%E6%BB%A4host"><span class="nav-number">3.1.</span> <span class="nav-text">基于 IP 地址过滤：host</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%BD%91%E6%AE%B5%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4net"><span class="nav-number">3.2.</span> <span class="nav-text">基于网段进行过滤：net</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4port"><span class="nav-number">3.3.</span> <span class="nav-text">基于端口进行过滤：port</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4proto"><span class="nav-number">3.4.</span> <span class="nav-text">基于协议进行过滤：proto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Eip%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="nav-number">3.5.</span> <span class="nav-text">基于IP协议版本进行过滤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">可选参数解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%8D%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%E6%8F%90%E5%8D%87%E9%80%9F%E5%BA%A6"><span class="nav-number">4.1.</span> <span class="nav-text">设置不解析域名提升速度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6"><span class="nav-number">4.2.</span> <span class="nav-text">过滤结果输出到文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%8C%85%E6%95%B0%E6%8D%AE"><span class="nav-number">4.3.</span> <span class="nav-text">从文件中读取包数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9%E7%9A%84%E8%BE%93%E5%87%BA"><span class="nav-number">4.4.</span> <span class="nav-text">控制详细内容的输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%97%B6%E9%97%B4%E7%9A%84%E6%98%BE%E7%A4%BA"><span class="nav-number">4.5.</span> <span class="nav-text">控制时间的显示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%A4%B4%E9%83%A8"><span class="nav-number">4.6.</span> <span class="nav-text">显示数据包的头部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E6%8C%87%E5%AE%9A%E7%BD%91%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">4.7.</span> <span class="nav-text">过滤指定网卡的数据包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E7%89%B9%E5%AE%9A%E6%B5%81%E5%90%91%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">4.8.</span> <span class="nav-text">过滤特定流向的数据包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%82%E6%95%B0"><span class="nav-number">4.9.</span> <span class="nav-text">其他常用的一些参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">4.10.</span> <span class="nav-text">对输出内容进行控制的参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99%E7%BB%84%E5%90%88"><span class="nav-number">5.</span> <span class="nav-text">过滤规则组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99"><span class="nav-number">6.</span> <span class="nav-text">特殊过滤规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE-tcpflags-%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="nav-number">6.1.</span> <span class="nav-text">根据 tcpflags 进行过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8C%85%E5%A4%A7%E5%B0%8F%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="nav-number">6.2.</span> <span class="nav-text">基于包大小进行过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE-mac-%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="nav-number">6.3.</span> <span class="nav-text">根据 mac 地址进行过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E9%80%9A%E8%BF%87%E6%8C%87%E5%AE%9A%E7%BD%91%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">6.4.</span> <span class="nav-text">过滤通过指定网关的数据包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%B9%BF%E6%92%AD%E5%A4%9A%E6%92%AD%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">6.5.</span> <span class="nav-text">过滤广播&#x2F;多播数据包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="nav-number">7.</span> <span class="nav-text">抓包实战应用例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8F%96-http-%E7%9A%84-useragent"><span class="nav-number">7.1.</span> <span class="nav-text">提取 HTTP 的 UserAgent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%93%E5%8F%96-http-get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82"><span class="nav-number">7.2.</span> <span class="nav-text">抓取 HTTP GET 和 POST 请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E5%87%BA%E5%8F%91%E5%8C%85%E6%95%B0%E9%87%8F%E6%9C%80%E5%A4%9A%E7%9A%84-ip"><span class="nav-number">7.3.</span> <span class="nav-text">找出发包数量最多的 IP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%93%E5%8F%96-dns-%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94"><span class="nav-number">7.4.</span> <span class="nav-text">抓取 DNS 请求和响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E5%89%B2-pcap-%E6%96%87%E4%BB%B6"><span class="nav-number">7.5.</span> <span class="nav-text">切割 pcap 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8F%96-http-post-%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81"><span class="nav-number">7.6.</span> <span class="nav-text">提取 HTTP POST 请求中的密码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8F%96-http-%E8%AF%B7%E6%B1%82%E7%9A%84-url"><span class="nav-number">7.7.</span> <span class="nav-text">提取 HTTP 请求的 URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%93%E5%8F%96-http-%E6%9C%89%E6%95%88%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">7.8.</span> <span class="nav-text">抓取 HTTP 有效数据包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%90%88-wireshark-%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90"><span class="nav-number">7.9.</span> <span class="nav-text">结合 Wireshark 进行分析</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eleven26</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eleven26" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eleven26" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2022/07/06/linux/tcpdump%20%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="tcpdump 用法 | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          tcpdump 用法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-07-06 19:20:00" itemprop="dateCreated datePublished" datetime="2022-07-06T19:20:00+08:00">2022-07-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>tcpdump 是一个命令行的网络流量分析工具，功能非常强大，一般我们用来抓
TCP 的包。</p>
<blockquote>
<p>非常重要：如果 tcpdump 没有输出，尝试加上 <code>-i any</code>
选项。</p>
</blockquote>
<h2 id="tcpdump-核心参数图解">tcpdump 核心参数图解</h2>
<p><img src="/images/linux/tcpdump/args.png" /></p>
<p>tcpdump 参数的组成部分： 1. <code>option</code> 可选参数 2.
<code>proto</code> 类过滤器：根据协议进行过滤，可识别的关键词有：tcp,
udp 等 3. <code>type</code> 类过滤器：可识别的关键词有：host, net, port,
portrange 4. <code>direction</code>
类过滤器：根据数据流向进行过滤，可识别的关键词有：src,
dst，你可以使用逻辑运算符进行组合，如 <code>src or dst</code></p>
<h2 id="理解-tcpdump-的输出">理解 tcpdump 的输出</h2>
<h3 id="输出内容结构">输出内容结构</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21:26:49.013621 IP 172.20.20.1.15605 &gt; 172.20.20.2.5920: Flags [P.], seq 49:97, ack 106048, win 4723, length 48</span><br></pre></td></tr></table></figure>
<ul>
<li>第一列：时分秒毫秒 <code>21:26:49.013621</code></li>
<li>第二列：网络协议 IP</li>
<li>第三列：发送方的 ip地址+端口号，其中 172.20.20.1 是 ip，而 15605
是端口号</li>
<li>第四列：箭头 &gt;，表示数据流向</li>
<li>第五列：接收方的 ip地址+端口号，其中 172.20.20.2 是 ip，而 5920
是端口号</li>
<li>第六列：冒号</li>
<li>第七列： 数据包内容，包括 Flags 标识符，seq 号，ack 号，win
窗口，数据长度，其中 [P.] 表示 PUSH 标志位为 1</li>
</ul>
<h4 id="flags-标识符">Flags 标识符</h4>
<ul>
<li><code>[S]</code>：SYN（开始连接）</li>
<li><code>[P]</code>：PSH（推送数据）</li>
<li><code>[F]</code>：FIN（结束连接）</li>
<li><code>[R]</code>：RST（重置连接）</li>
<li><code>[.]</code>：没有
Flag（意思是除上面四种类型外的其他情况，有可能是 ACK 也有可能是
URG）</li>
</ul>
<h2 id="常规过滤规则">常规过滤规则</h2>
<h3 id="基于-ip-地址过滤host">基于 IP 地址过滤：host</h3>
<p>使用 <code>host</code> 就可以指定 host ip 进行过滤：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 192.168.10.100</span><br></pre></td></tr></table></figure>
<p>数据包的 ip 可以再细分为源 ip 和目标 ip 两种：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据源 ip 进行过滤</span></span><br><span class="line">tcpdump -i eth2 src 192.168.10.100</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据目标 ip 进行过滤</span></span><br><span class="line">tdpcump -i eth2 dst 192.168.10.200</span><br></pre></td></tr></table></figure>
<h3 id="基于网段进行过滤net">基于网段进行过滤：net</h3>
<p>若你的 ip 范围是一个网段，可以直接这样指定：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump net 192.168.10.0/24</span><br></pre></td></tr></table></figure>
<p>网段统一可以再细分为源网段和目标网段：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据源网段进行过滤</span></span><br><span class="line">tcpdump src net 192.168</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据目标网段进行过滤</span></span><br><span class="line">tcpdump dst net 192.168</span><br></pre></td></tr></table></figure>
<h3 id="基于端口进行过滤port">基于端口进行过滤：port</h3>
<p>使用 <code>port</code> 就可以指定特定端口进行过滤：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump port 8888</span><br></pre></td></tr></table></figure>
<p>端口同样可以再细分为源端口，目标端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据源端口进行过滤</span></span><br><span class="line">tcpdump src port 8888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据目标端口进行过滤</span></span><br><span class="line">tcpdump dst port 8888</span><br></pre></td></tr></table></figure>
<p>如果你想同时指定两个端口你可以这样写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump port 80 or port 8888</span><br></pre></td></tr></table></figure>
<p>但也可以简写成这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump port 80 or 8888</span><br></pre></td></tr></table></figure>
<p>如果你想抓取的不再是一两个端口，而是一个范围，一个一个指定就非常麻烦了，此时你可以这样指定一个端口段：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump portrange 8000-8080</span><br><span class="line">tcpdump src portrange 8000-8080</span><br><span class="line">tcpdump dst portrange 8000-8080</span><br></pre></td></tr></table></figure>
<p>对于一些常见协议的默认端口，我们还可以直接使用协议名，而不用具体的端口号：</p>
<p>比如 http == 80, https == 443 等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump tcp port http</span><br></pre></td></tr></table></figure>
<h3 id="基于协议进行过滤proto">基于协议进行过滤：proto</h3>
<p>常见的网络协议有 tcp，udp，icmp，http，ip，ipv6 等。</p>
<p>若你只想查看 icmp 的包，可以直接这样写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump icmp</span><br></pre></td></tr></table></figure>
<p>protocol
可选值：ip，ip6，arp，rarp，atalk，aarp，decnet，sca，lat，mopdl，moprc，iso，stp，ipx，or
netbeui</p>
<h3 id="基于ip协议版本进行过滤">基于IP协议版本进行过滤</h3>
<p>当你想查看 tcp 的包，你也许会这样子写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump tcp</span><br></pre></td></tr></table></figure>
<p>这样子写也没问题，就是不够精准，为什么这么说呢？</p>
<p>ip 根据版本的不同，可以再细分为 IPv4 和 IPv6 两种，如果你只指定了
tcp，这两种其实都会包含在内。</p>
<p>那有什么办法，能够将 IPv4 和 IPv6 区分开来呢？</p>
<p>很简单，如果是 IPv4 的 tcp 包，就这样写（数字 6 表示的是 tcp 在 ip
报文中的编号。）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;ip proto tcp&#x27;</span><br><span class="line">tcpdump ip proto 6</span><br><span class="line">tcpdump &#x27;ip protochain tcp&#x27;</span><br><span class="line">tcpdump ip protochain 6</span><br></pre></td></tr></table></figure>
<p>而如果是 IPv6 的 tcp 包，就这样写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;ip6 proto tcp&#x27;</span><br><span class="line">tcpdump ip6 proto 6</span><br><span class="line">tcpdump &#x27;ip6 protochain tcp&#x27;</span><br><span class="line">tcpdump ip6 prorochain 6</span><br></pre></td></tr></table></figure>
<p>关于上面这几个命令示例，有两点需要注意：</p>
<ol type="1">
<li>跟在 proto 和 protochain 后面的如果是 tcp, udp, icmp
，那么过滤器需要用引号包含，这是因为 tcp,udp, icmp 是 tcpdump
的关键字。</li>
<li>跟在ip 和 ip6 关键字后面的 proto 和 protochain
是两个新面孔，看起来用法类似，它们是否等价，又有什么区别呢？</li>
</ol>
<p>proto 后面跟的 <protocol> 的关键词是固定的，只能是 ip, ip6, arp,
rarp, atalk, aarp, decnet, sca, lat, mopdl, moprc, iso, stp, ipx, or
netbeui 这里面的其中一个。</p>
<p>而 protochain 后面跟的 protocol
要求就没有那么严格，它可以是任意词，只要 tcpdump 的 IP 报文头部里的
protocol 字段为 <protocol> 就能匹配上。</p>
<p>理论上来讲，下面两种写法效果是一样的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;ip &amp;&amp; tcp&#x27;</span><br><span class="line">tcpdump &#x27;ip proto tcp&#x27;</span><br></pre></td></tr></table></figure>
<p>同样的，这两种写法也是一样的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;ip6 &amp;&amp; tcp&#x27;</span><br><span class="line">tcpdump &#x27;ip6 proto tcp&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="可选参数解析">可选参数解析</h2>
<h3 id="设置不解析域名提升速度">设置不解析域名提升速度</h3>
<ul>
<li><code>-n</code> 不把 ip 转化成域名，直接显示 ip，避免执行 DNS
lookups 的过程，速度会快很多。</li>
<li><code>-nn</code> 不把协议和端口号转化成名字，速度也会快很多</li>
<li><code>-N</code> 不打印出 host
的域名部分。比如，如果设置了此选项，tcpdump 将会打印 'nic' 而不是
'nic.ddn.mil'</li>
</ul>
<h3 id="过滤结果输出到文件">过滤结果输出到文件</h3>
<p>使用 tcpdump
工具抓到包后，往往需要再借助其他的工具进行分析，比如常见的
wireshark。</p>
<p>而要使用 wireshark，我们得将 tcpdump
抓到的包数据生成到文件中，最后再使用 wireshark 打开它即可。</p>
<p>使用 <code>-w</code> 参数后接一个以 <code>.pcap</code>
后缀命名的文件名，就可以将 tcpdump 抓到的数据保存到文件中。（可以使用
wireshark 分析这个文件，也可以使用 tcpdump 读取）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump icmp -w icmp.pcap</span><br></pre></td></tr></table></figure>
<h3 id="从文件中读取包数据">从文件中读取包数据</h3>
<p>使用 <code>-w</code> 是写入数据到文件，而使用 <code>-r</code>
是从文件中读取数据。</p>
<p>读取后，我们照样可以使用上述的过滤器语法进行过滤分析。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -r all.pcap</span><br></pre></td></tr></table></figure>
<p>读取之后过滤：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -r all.pcap src host 192.168.2.11</span><br></pre></td></tr></table></figure>
<h3 id="控制详细内容的输出">控制详细内容的输出</h3>
<ul>
<li><code>-v</code> 产生详细的输出。比如包的 TTL，id
标识，数据包长度，以及 IP
包的一些选项。同时它还会打开一些附加的包完整性检测，比如对 IP 和 ICMP
包头部的校验和。</li>
<li><code>-vv</code> 产生比-v更详细的输出.
比如NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码。</li>
<li><code>-vvv</code> 产生比-vv更详细的输出。比如 telent 时所使用的SB,
SE 选项将会被打印,
如果telnet同时使用的是图形界面，其相应的图形选项将会以16进制的方式打印出来</li>
</ul>
<h3 id="控制时间的显示">控制时间的显示</h3>
<ul>
<li><code>-t</code> 在每行的输出中不输出时间</li>
<li><code>-tt</code> 在每行的输出中会输出时间戳</li>
<li><code>-ttt</code> 输出每两行打印的时间间隔（以毫秒为单位）</li>
<li><code>-tttt</code>
在每行打印的时间戳之前添加日期的打印（此种选项，输出的时间最为直观）</li>
</ul>
<h3 id="显示数据包的头部">显示数据包的头部</h3>
<ul>
<li><code>-x</code> 以 16
进制的形式打印每个包的头部数据（但不包括数据链路层的头部）</li>
<li><code>-xx</code> 以 16
进制的形式打印每个包的头部数据（包括数据链路层的头部）</li>
<li><code>-X</code> 以 16 进制和 ASCII
码形式打印出每个包的数据（但不包括连接层的头部），这在分析一些新协议的数据包很方便。</li>
<li><code>-XX</code> 以 16 进制和 ASCII
码形式打印出每个包的数据（包括连接层的头部），这在分析一些新协议的数据包很方便</li>
</ul>
<h3 id="过滤指定网卡的数据包">过滤指定网卡的数据包</h3>
<ul>
<li><code>-i</code> 指定要过滤的网卡接口，如果要查看所有网卡，可以
<code>-i any</code></li>
</ul>
<h3 id="过滤特定流向的数据包">过滤特定流向的数据包</h3>
<ul>
<li><code>-Q</code>
选择是入方向还是出方向的数据包，可选项有：in，out，inout。也可以使用
<code>--direction=[direction]</code> 这种写法</li>
</ul>
<h3 id="其他常用的一些参数">其他常用的一些参数</h3>
<ul>
<li><code>-A</code> 以 ASCII
码方式显示每一个数据包（不显示链路层头部信息）。在抓取包含网页数据的数据包时，可方便查看数据。</li>
<li><code>-l</code>
基于行的输出，便于你保存查看，或者交给其他工具分析</li>
<li><code>-q</code>
简洁地打印输出。即打印很少的协议相关的信息，从而输出行都比较简短</li>
<li><code>-c</code> 捕获 count 个包 tcpdump 就退出</li>
<li><code>-s</code> tcpdump 默认只会截取前 <code>96</code>
字节的内容，要想截取所有的报文内容，可以使用
<code>-s number</code>，<code>number</code>
就是你要截取的报文子节数，如果是 0 的话，表示截取报文全部内容。</li>
<li><code>-S</code> 使用绝对序列号，而不是相对序列号</li>
<li><code>-C</code> file-size，tcpdump
在把原始数据包直接保存到文件中之前，检查此文件大小是否超过
file-size。如果超过了，将关闭文件，另创一个文件继续用于原始数据包的记录。新创建的文件名与
-w 选项指定的文件名一致，但文件名后多了一个* 数字。该数字会从 1
开始随着新创建文件的增多而增加。file-size
的单位是百万子节（nt：这里指1,000,000个字节,并非1,048,576个字节,
后者是以1024字节为1k, 1024k字节为1M计算所得, 即1M=1024 ＊ 1024 ＝
1,048,576）</li>
<li><code>-F</code> 使用 file
文件作为过滤条件表达式的输入，此时命令行上的输入将被忽略。</li>
</ul>
<h3 id="对输出内容进行控制的参数">对输出内容进行控制的参数</h3>
<ul>
<li><code>-D</code> 显示所有可用的网络接口的列表（跟 netstat -i
类似）</li>
<li><code>-e</code>
每行的打印输出中将包括数据包的数据链路层头部信息</li>
<li><code>-E</code> 揭秘 IPSEC 数据</li>
<li><code>-L</code> 列出指定网络接口所支持的数据链路层的类型后退出</li>
<li><code>-Z</code> 后接用户名，在抓包时会受到权限的控制。如果以 root
用户启动 tcpdump，tcpdump 将会有超级用户权限</li>
<li><code>-d</code> 打印出易读的包匹配码</li>
<li><code>-dd</code> 以 C 语言的形式打印出包匹配码</li>
<li><code>-ddd</code> 以十进制的形式打印出包匹配码</li>
</ul>
<h2 id="过滤规则组合">过滤规则组合</h2>
<p>有编程基础的同学，对于下面三个逻辑运算符应该不陌生了吧。</p>
<ul>
<li><code>and</code> 所有的条件都要满足，也可以表示为
<code>&amp;&amp;</code></li>
<li><code>or</code> 只要有一个条件满足就可以，也可以表示为
<code>||</code></li>
<li><code>not</code> 取反，也可以使用 <code>|</code></li>
</ul>
<p>举个例子，我想需要抓取一个来自 <code>10.5.2.3</code>，发往任意主机的
3389 端口的包。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump src 10.5.2.3 and dst port 3389</span><br></pre></td></tr></table></figure>
<p>当你在使用多个过滤器进行组合时，有可能需要用到括号，而括号在 shell
中是特殊符号，因此你需要使用引号将其包含。例子如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;src 10.0.2.4 and (dst port 3389 or 22)&#x27;</span><br></pre></td></tr></table></figure>
<p>而在单个过滤器里，常常会判断一条件是否成立，这时候，就要使用下面两个符号：</p>
<ul>
<li><code>=</code> 判断二者相等</li>
<li><code>==</code> 判断二者相等</li>
<li><code>!=</code> 判断二者不相等</li>
</ul>
<p>当你使用这两个符号时，tcpdump
还提供了一些关键字的接口来方便我们进行判断，比如：</p>
<ul>
<li>if：表示网卡接口名</li>
<li>proc：表示进程名</li>
<li>pid：表示进程 id</li>
<li>svc：表示 service class</li>
<li>dir：表示方向，in 和 out</li>
<li>eproc：表示 effictive processes name</li>
<li>epid：表示 effictive process ID</li>
</ul>
<p>比如我现在要过滤来自进程名为 nc 发出的流经 en0
网卡的数据包，或者不流经 en0 的入方向数据包，可以这样子写。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &quot;(if=en0 and proc=nc) || (if != en0 and dir = in)&quot;</span><br></pre></td></tr></table></figure>
<h2 id="特殊过滤规则">特殊过滤规则</h2>
<h3 id="根据-tcpflags-进行过滤">根据 tcpflags 进行过滤</h3>
<p><img src="/images/linux/tcpdump/header.png" /></p>
<p>tcpdump 支持我们根据数据包的标志位进行过滤：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proto [ expr:size ]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>proto</code>
可以是熟知的协议之一（如ip，arp，udp，icmp，ipv6）</li>
<li><code>expr</code>
可以是数值，也可以是一个表达式，表示与指定的协议头开始处的子节偏移量。</li>
<li><code>size</code> 是可选的，表示从子节偏移量开始取的子节数量</li>
</ul>
<ol type="1">
<li>tcpflags 可以理解为一个别名常量，相当于
13，它代表着与指定的协议头开头相关的子节偏移量，也就是标志位，所以
<code>tcp[tcpflags]</code> 等价于 <code>tcp[13]</code>就是 tcp 报文的第
13 个字节。</li>
<li>tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg
这些同样可以理解为别名常量，分别代表 1，2，4，8，16，32，64。（就是
000001，000010 ... 这些二进制数）</li>
</ol>
<p>由于数字不好记忆，所以一般使用这样的 “别名常量” 表示。</p>
<p>因此当下面这个表达式成立时，就代表这个包是一个 syn 包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp[tcpflags] == tcp-syn</span><br></pre></td></tr></table></figure>
<p>要抓取特定数据包，方法有很多种。</p>
<p>下面以最常见的 syn 包为例，演示一下如何用 tcpdump 抓取到 syn
包，而其他的类型的包也是同样的道理。</p>
<p>据我总结，主要有三种写法：</p>
<ol type="1">
<li>使用数字表示偏移量：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 &quot;tcp[13] &amp; 2 != 0&quot;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用别名常量表示偏移量：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 &quot;tcp[tcpflags] &amp; tcp-syn != 0&quot;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用混合写法</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 &quot;tcp[tcpflags] &amp; 2 != 0&quot;</span><br><span class="line">tcpdump -i eth0 &quot;tcp[13] &amp; tcp-syn != 0&quot;</span><br></pre></td></tr></table></figure>
<p>如果我想同时捕获多种类型的包呢，比如 syn 或 ack 包</p>
<ol type="1">
<li>第一种写法</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 &#x27;tcp[13] == 2 or tcp[13] == 16&#x27;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>第二种写法</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 &#x27;tcp[tcpflags] == tcp-syn or tcp[tcpflags] == tcp-ack&#x27;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>第三种写法</li>
</ol>
<blockquote>
<p>捕获的是 tcp and ack</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 &quot;tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0&quot;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>第四种写法：注意这里是单个等号，而不是像上面一样两个等号，18
(syn+ack) = 2 (syn) + 16(ack)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 &#x27;tcp[13] = 18&#x27;</span><br><span class="line">tcpdump -i eth0 &#x27;tcp[tcpflags] = 18&#x27;</span><br></pre></td></tr></table></figure>
<p>tcp 中有类似 tcp-syn 的别名常量，其他协议也是有的，比如 icmp
协议，可以使用的别名常量有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">icmp-echoreply, icmp-unreach, icmp-sourcequench, </span><br><span class="line">icmp-redirect, icmp-echo, icmp-routeradvert,</span><br><span class="line">icmp-routersolicit, icmp-timx-ceed, icmp-paramprob, </span><br><span class="line">icmp-tstamp, icmp-tstampreply,icmp-ireq, </span><br><span class="line">icmp-ireqreply, icmp-maskreq, icmp-maskreply</span><br></pre></td></tr></table></figure>
<h3 id="基于包大小进行过滤">基于包大小进行过滤</h3>
<p>若你想查看指定大小的数据包，也是可以的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump less 32</span><br><span class="line">tcpdump greater 64</span><br><span class="line">tcpdump &lt;= 128</span><br></pre></td></tr></table></figure>
<h3 id="根据-mac-地址进行过滤">根据 mac 地址进行过滤</h3>
<p>例子如下，其中 ehost 是记录在 /etc/ethers 里的 name</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump ether host [ehost]</span><br><span class="line">tcpdump ether dst [ehost]</span><br><span class="line">tcpdump ether src [ehost]</span><br></pre></td></tr></table></figure>
<h3 id="过滤通过指定网关的数据包">过滤通过指定网关的数据包</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump gateway [host]</span><br></pre></td></tr></table></figure>
<h3 id="过滤广播多播数据包">过滤广播/多播数据包</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tcpdump ether broadcast</span><br><span class="line">tcpdump ether multicast</span><br><span class="line"></span><br><span class="line">tcpdump ip broadcast</span><br><span class="line">tcpdump ip multicast</span><br><span class="line"></span><br><span class="line">tcpdump ip6 multicast</span><br></pre></td></tr></table></figure>
<h2 id="抓包实战应用例子">抓包实战应用例子</h2>
<h3 id="提取-http-的-useragent">提取 HTTP 的 UserAgent</h3>
<p>从 HTTP 请求头提取 HTTP 的User-Agent：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn -A -s1500 -l | grep &quot;User-Agent:&quot;</span><br></pre></td></tr></table></figure>
<p>通过 <code>egrep</code> 可以同时提取 User-Agent 和 主机名（或其他
HTTP 头）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn -A -s1500 -l | egrep &quot;User-Agent:|Host:&quot;</span><br></pre></td></tr></table></figure>
<h3 id="抓取-http-get-和-post-请求">抓取 HTTP GET 和 POST 请求</h3>
<p>抓取 HTTP GET 请求包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -s 0 -A -vv <span class="string">&#x27;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -vvAls0 | grep <span class="string">&#x27;GET&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>抓取 HTTP POST 请求包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -s 0 -A -vv <span class="string">&#x27;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x504f5354&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -vvAls0 | grep <span class="string">&#x27;POST&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>注意：该方法不能保证抓取到 HTTP POST 有效数据流量，因为一个 POST
请求会被分割为多个 TCP 数据包。</p>
<h3 id="找出发包数量最多的-ip">找出发包数量最多的 IP</h3>
<p>找出一段时间内发包最多的 IP，或者从一堆报文中找出发包最多的
IP，可以使用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nnn -t -c 200 | cut -f 1,2,3,4 -d &#x27;.&#x27; | sort | uniq -c | sort -nr | head -n 20</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cut -f 1,2,3,4 -d '.'</code>: 以 .
为分隔符，打印出每行的前四列。即 IP 地址。</li>
<li><code>sort | uniq -c</code>: 排序并计数</li>
<li><code>sort -nr</code>: 按照数值大小逆向排序</li>
</ul>
<h3 id="抓取-dns-请求和响应">抓取 DNS 请求和响应</h3>
<p>DNS 的默认端口是 53，因此可以通过端口进行过滤：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any -s0 port 53</span><br></pre></td></tr></table></figure>
<h3 id="切割-pcap-文件">切割 pcap 文件</h3>
<p>当抓取大量数据并写入文件时，可以自动切割为多个大小相同的文件。例如，下面的命令表示每
3600 秒创建一个新文件
<code>capture-(hour).pcap</code>，每个文件大小不超过
<code>200*1000000</code> 字节：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump  -w /tmp/capture-%H.pcap -G 3600 -C 200</span><br></pre></td></tr></table></figure>
<p>这些文件的命名为 <code>capture-&#123;1-24&#125;.pcap</code>，24
小时之后，之前的文件就会被覆盖。</p>
<h3 id="提取-http-post-请求中的密码">提取 HTTP POST 请求中的密码</h3>
<p>从 HTTP POST 请求中提取密码和主机名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -s 0 -A -n -l | egrep -i &quot;POST /|pwd=|passwd=|password=|Host:&quot;</span><br></pre></td></tr></table></figure>
<h3 id="提取-http-请求的-url">提取 HTTP 请求的 URL</h3>
<p>提取 HTTP 请求的主机名和路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -s 0 -v -n -l | egrep -i &quot;POST /|GET /|Host:&quot;</span><br></pre></td></tr></table></figure>
<h3 id="抓取-http-有效数据包">抓取 HTTP 有效数据包</h3>
<p>抓取 80 端口的 HTTP 有效数据包，排除 TCP 连接建立过程的数据包（SYN /
FIN / ACK）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="结合-wireshark-进行分析">结合 Wireshark 进行分析</h3>
<p>通常 Wireshark（或 tshark）比 tcpdump
更容易分析应用层协议。一般的做法是在远程服务器上先使用 tcpdump
抓取数据并写入文件，然后再将文件拷贝到本地工作站上用 Wireshark
分析。</p>
<p>还有一种更高效的方法，可以通过 ssh 连接将抓取到的数据实时发送给
Wireshark 进行分析。以 MacOS 系统为例，可以通过 brew cask install
wireshark 来安装，然后通过下面的命令来分析：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@remotesystem &#x27;tcpdump -s0 -c 1000 -nn -w - not port 22&#x27; | /Applications/Wireshark.app/Contents/MacOS/Wireshark -k -i -</span><br></pre></td></tr></table></figure>
<p>例如，如果想分析 DNS 协议，可以使用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@remotesystem &#x27;tcpdump -s0 -c 1000 -nn -w - port 53&#x27; | /Applications/Wireshark.app/Contents/MacOS/Wireshark -k -i -</span><br></pre></td></tr></table></figure>
<p>-c 选项用来限制抓取数据的大小。如果不限制大小，就只能通过 ctrl-c
来停止抓取，这样一来不仅关闭了 tcpdump，也关闭了 wireshark。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"><i class="fa fa-tag"></i> linux</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/06/linux/netstat%20%E7%94%A8%E6%B3%95/" rel="prev" title="netstat 用法">
                  <i class="fa fa-angle-left"></i> netstat 用法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/10/golang/gin%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E7%9A%84struct%20tag/" rel="next" title="gin表单验证struct tag">
                  gin表单验证struct tag <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">eleven26</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eleven26" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
