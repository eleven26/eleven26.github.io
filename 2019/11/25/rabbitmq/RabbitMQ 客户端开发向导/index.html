<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eleven26.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="连接 RabbitMQ 下面的代码用来在给定的参数（IP 地址、端口号、用户名、密码等）下连接 RabbitMQ： 12345678ConnectionFactory factory &#x3D; new ConnectionFactory();factory.setUsername(USERNAME);factory.setPassword(PASSSWORD);factory.setVirtualHos">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ 客户端开发向导">
<meta property="og:url" content="https://eleven26.github.io/2019/11/25/rabbitmq/RabbitMQ%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E5%90%91%E5%AF%BC/index.html">
<meta property="og:site_name" content="eleven26">
<meta property="og:description" content="连接 RabbitMQ 下面的代码用来在给定的参数（IP 地址、端口号、用户名、密码等）下连接 RabbitMQ： 12345678ConnectionFactory factory &#x3D; new ConnectionFactory();factory.setUsername(USERNAME);factory.setPassword(PASSSWORD);factory.setVirtualHos">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://eleven26.github.io/images/rabbitmq/10.png">
<meta property="og:image" content="https://eleven26.github.io/images/rabbitmq/11.png">
<meta property="article:published_time" content="2019-11-25T08:35:00.000Z">
<meta property="article:modified_time" content="2022-06-15T09:19:00.000Z">
<meta property="article:author" content="eleven26">
<meta property="article:tag" content="RabbitMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eleven26.github.io/images/rabbitmq/10.png">


<link rel="canonical" href="https://eleven26.github.io/2019/11/25/rabbitmq/RabbitMQ%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E5%90%91%E5%AF%BC/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://eleven26.github.io/2019/11/25/rabbitmq/RabbitMQ%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E5%90%91%E5%AF%BC/","path":"2019/11/25/rabbitmq/RabbitMQ 客户端开发向导/","title":"RabbitMQ 客户端开发向导"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>RabbitMQ 客户端开发向导 | eleven26</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">eleven26</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">100</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">346</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5-rabbitmq"><span class="nav-number">1.</span> <span class="nav-text">连接 RabbitMQ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%A4%E6%8D%A2%E5%99%A8%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">使用交换器和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exchangedeclare-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.1.</span> <span class="nav-text">exchangeDeclare 方法详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queuedeclare-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.2.</span> <span class="nav-text">queueDeclare 方法详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queuebind-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.3.</span> <span class="nav-text">queueBind 方法详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exchangebind-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.4.</span> <span class="nav-text">exchangeBind 方法详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E5%88%9B%E5%BB%BA"><span class="nav-number">2.5.</span> <span class="nav-text">何时创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-number">3.</span> <span class="nav-text">发送消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="nav-number">4.</span> <span class="nav-text">消费消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">推模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">拉模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E7%A1%AE%E8%AE%A4%E4%B8%8E%E6%8B%92%E7%BB%9D"><span class="nav-number">5.</span> <span class="nav-text">消费者的确认与拒绝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.</span> <span class="nav-text">关闭连接</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eleven26</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eleven26" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eleven26" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eleven26.github.io/2019/11/25/rabbitmq/RabbitMQ%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E5%90%91%E5%AF%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eleven26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eleven26">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="RabbitMQ 客户端开发向导 | eleven26">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RabbitMQ 客户端开发向导
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-11-25 16:35:00" itemprop="dateCreated datePublished" datetime="2019-11-25T16:35:00+08:00">2019-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="连接-rabbitmq">连接 RabbitMQ</h2>
<p>下面的代码用来在给定的参数（IP 地址、端口号、用户名、密码等）下连接
RabbitMQ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">factory.setUsername(USERNAME);</span><br><span class="line">factory.setPassword(PASSSWORD);</span><br><span class="line">factory.setVirtualHost(virtualHost);</span><br><span class="line">factory.setHost(IP_ADDRESS);</span><br><span class="line">factory.setPort(PORT);</span><br><span class="line"></span><br><span class="line">Connection connection = factory.newConnection();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">factory.setUri(&quot;amqp://guest:guest@localhost:5672/virtualHost&quot;);</span><br><span class="line">Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">// Connection 接口被用来创建一个 Channel</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line">// 在创建 channel 之后，channel 可以用来发送或者接收消息了</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意要点: Connection 可以用来创建多个 Channel 实例，但是 Channel
实例不能在线程间共享， 应用程序应该为每一个线程开辟一个
Channel。某些情况下 Channel
的操作可以并发运行，但是在其它情况下会导致在网络上
出现错误的通信帧交替，同时也会影响发送方确认（publisher
confirm）机制的运行， 所以多线程间共享 Channel 实例是非线程安全的。</p>
</blockquote>
<p>Channel 或者 Connection 中有个 isOpen
方法可以用来检测其是否已处于开启状态。 但并不推荐在生产环境的代码上使用
isOpen 方法，这个方法的返回值依赖于 shutdownCause
的存在，有可能会产生竞争。</p>
<p>isOpen 方法的源码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean isOpen() &#123;</span><br><span class="line">    synchronized(this.monitor) &#123;</span><br><span class="line">        return this.shutdownCause == null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误地使用 isOpen 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void brokenMethod(Channel channel)</span><br><span class="line">&#123;</span><br><span class="line">    if (channel.isOpen()) &#123;</span><br><span class="line">        // The following code depends on the channel being in open state.</span><br><span class="line">        // However there is a possibility of the change in the channel state</span><br><span class="line">        // between isOpen() and basicQos(1) call</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下，在调用 createXXX 或者 newXXX 方法之后，我们可以简单地认为
Connection 或者 Channel 已经成功地处于开启状态， 而不会在代码中使用
isOpen 这个检测方法。如果在使用 Channel
的时候其已经处于关闭状态，那么程序会抛出一个
<code>com.rabbitmq.client.ShutdownSignalException</code>，
我们只需要捕获这个异常即可。当然同时也要试着捕获
<code>IOException</code> 或者 <code>SocketException</code>，以防
Connection 意外关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void validMethod(Channel channel)</span><br><span class="line">&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // ...</span><br><span class="line">        // channel.basicQos(1);</span><br><span class="line">    &#125; catch (ShutdownSignalException e) &#123;</span><br><span class="line">        // possibly check if channel was closed</span><br><span class="line">        // by the time we started action and reasons for</span><br><span class="line">        // closing it</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        // check why connection was closed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用交换器和队列">使用交换器和队列</h2>
<p>交换器和队列是 AMQP 中 high-level
层面的构建模块，应用程序需要确保在使用它们的时候就已经存在了，在使用之前需要先声明（declare）它们。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(exchangeName, &quot;direct&quot;, true);</span><br><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br></pre></td></tr></table></figure>
<p>上面创建了一个持久化的、非自动删除的、绑定类型为 direct
的交换器，同时也创建了一个非持久化的、拍他的、自动删除的队列（此队列的名称由
RabbitMQ 自动生成）。 这里交换器和队列也都没有设置特殊的参数。</p>
<p>上面的代码也展示了如何将路由键将队列和交换器绑定起来。上面声明的队列具备如下特性:
只对当前应用中同一个 Connection 层面可用，同一个 Connection 的不同
Channel 可共用，并且也会在应用连接断开的时候自动删除。</p>
<p>如果要在应用中共享一个队列，可以做如下声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(exchangeName, &quot;direct&quot;, true);</span><br><span class="line">channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br></pre></td></tr></table></figure>
<p>这里的队列被声明为持久化的，非排他的、非自动删除的，并且也被分配另一个确定的已知的名称（由客户端分配而非
RabbitMQ 自动生成）。</p>
<p>注意：Channel 的 API 方法都是可以重载的，比如
exchangeDeclare、queueDeclare。
根据参数不用，可以有不同的重载形式，根据自身的需要进行调用。</p>
<p>生产者和消费者都可以声明一个交换器或者队列。
如果尝试声明一个已经存在的交换器或者队列，只要声明的参数完全匹配现存的交换器或者队列，
RabbitMQ
就可以什么都不做，并成功返回。如果声明的参数不匹配则会抛出异常。</p>
<h3 id="exchangedeclare-方法详解">exchangeDeclare 方法详解</h3>
<p>exchangeDeclare
方法有多个重载方法，这些重载方法都是由下面这个方法中缺省的某些参数构成的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exchange.DeclareOk exchangeDeclare(String exchange,</span><br><span class="line">    String type, boolean durable,</span><br><span class="line">    boolean autoDelete, boolean internal,</span><br><span class="line">    Map&lt;String, Object&gt; arguments) throws IOException;</span><br></pre></td></tr></table></figure>
<p>这个方法的返回值是
Exchange.DeclareOk，用来标识成功声明了一个交换器。</p>
<p>各个参数详细说明如下所述：</p>
<ul>
<li><p>exchange：交换器的名称</p></li>
<li><p>type：交换器的类型，常见的如 fanout、direct、topic</p></li>
<li><p>durable：设置是否持久化。durable 设置为 true
表示持久化，反之是非持久化。持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。</p></li>
<li><p>autoDelete：设置是否自动删除。autoDelete 设置为 true
则表示自动删除。自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后
所有与这个交换器绑定的队列或者交换器与此解绑。注意不能错误地把这个参数理解为："当与此交换器连接的客户端都断开时，RabbitMQ
会自动删除本交换器"</p></li>
<li><p>internal：设置是否是内置的。如果设置为
true，则表示是内置的交换器，客户端程序无法直接发送消息到此交换器中，只能通过交换器路由到交换器这种方式。</p></li>
<li><p>arguments：其它一些结构化参数，比如 alternate-exchange。</p></li>
</ul>
<p>exchangeDeclare 的其它重载方法如下：</p>
<ol type="1">
<li><p><code>Exchange.DeclareOk exchangeDeclare(String exchange, String type) throws IOException;</code></p></li>
<li><p><code>Exchange.DeclareOk exchangeDeclare(String exchange, String type, boolean durable) throws IOException;</code></p></li>
<li><p><code>Exchange.DeclareOk exchangeDeclare(String exchange, String type, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments) throws IOException;</code></p></li>
</ol>
<p>与此对应的，将第二个参数 <code>String type</code> 换成
<code>BuiltinExchangeType type</code> 对应的几个重载方法：</p>
<ol type="1">
<li><p><code>Exchange.DeclareOk exchangeDeclare(String exchange, BuiltinExchangeType type) throws IOException;</code></p></li>
<li><p><code>Exchange.DeclareOk exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable) throws IOException;</code></p></li>
<li><p><code>Exchange.DeclareOk exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable, Map&lt;String, Object&gt; arguments) throws IOException;</code></p></li>
</ol>
<p>与 exchangeDeclare 师出同门的还有几个方法，比如 exchangeDeclareNoWait
方法，具体定义如下（当然也有 BuiltinExchangeType 版）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void exchangeDeclareNoWait(String exchange,</span><br><span class="line">                            String type,</span><br><span class="line">                            boolean durable,</span><br><span class="line">                            boolean autoDelete,</span><br><span class="line">                            boolean internal,</span><br><span class="line">                            Map&lt;String, Object&gt; arguments) throws IOException;</span><br></pre></td></tr></table></figure>
<p>这个 <code>exchangeDeclareNoWait</code> 比
<code>exchangeDeclare</code> 多设置了一个 nowait 参数，这个 nowait
参数指的是 AMQP 中 <code>Exchange.Declare</code> 命令的参数，
意思是不需要服务器返回，注意这个方法的返回值是 void，而普通的
exchangeDeclare 方法的返回值是
<code>Exchange.DeclareOk</code>，意思是在客户端声明了一个交换器之后，
需要等待服务器的返回（服务器会返回 <code>Exchange.Declare-Ok</code> 这个
AMQP 命令）。</p>
<p>针对 "<code>exchangeDeclareNoWait</code> 不需要服务器返回任何值"
这一点，考虑这样一种情况，在声明完一个交换器之后（实际服务器还未完成交换器的创建），
那么此时客户端紧接着使用这个交换器，必然会发生异常。如果没有特殊的缘由和应用场景，并不建议使用这个方法。</p>
<p>这里还有师出同门的另一个方法
<code>exchangeDeclarePassive</code>，这个方法的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exchange.DeclareOk exchangeDeclarePassive(String name) throws IOException;</span><br></pre></td></tr></table></figure>
<p>这个方法在实际应用过程中还是非常有用的，它主要用来检测相应的交换器是否存在。如果存在则正常返回；如果不存在则抛出异常：404
channel exception，同时 Channel 也会被关闭。</p>
<p>有声明创建交换器的方法，当然也有删除交换器的方法，相应的方法如下：</p>
<ol type="1">
<li><p><code>Exchange.DeleteOk exchangeDelete(String exchange) throws IOException;</code></p></li>
<li><p><code>void exchangeDeleteNoWait(String exchange, boolean ifUnused) throws IOException;</code></p></li>
<li><p><code>Exchange.DeleteOk exchangeDelete(String exchange, boolean ifUnUsed) throws IOException;</code></p></li>
</ol>
<p>其中 exchange 表示交换器的名称，而 ifUnused
用来设置是否在交换器没有被使用的情况下删除。 如果 ifUnused 设置为
true，则只有在此交换器没有被使用的情况下才会被删除；如果设置为
false，则无论如何这个交换器都要被删除。</p>
<h3 id="queuedeclare-方法详解">queueDeclare 方法详解</h3>
<p>queueDeclare 相对于 exchangeDeclare
方法而言，重载的个数就少很多，它只有两个重载方法：</p>
<ol type="1">
<li><p><code>Queue.DeclareOk queueDeclare() throws IOException;</code></p></li>
<li><p><code>Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) throws IOException;</code></p></li>
</ol>
<p>不带任何参数的 queueDeclare 方法默认创建一个由 RabbitMQ
命名的（也称为匿名队列）、排他的、自动删除的、非持久化的队列。</p>
<p>方法的参数详细说明如下所述：</p>
<ul>
<li><p>queue：队列的名称</p></li>
<li><p>durable：设置是否持久化。为 true
则设置队列为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。</p></li>
<li><p>exclusive：设置是否排他。为 true
则设置队列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。
这里需要注意三点：排他队列是基于连接（Connection）可见的，同一个连接的不同信道（Channel）是可以同时访问同一连接创建的排他队列：
"首次"
是指如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列，这个与普通队列不同：即使该队列是持久化的，
一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和读取消息的应用场景。</p></li>
<li><p>autoDelete：设置是否自动删除。为 true
则设置为自动删除。自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者
都断开时，才会自动删除。不能把这个参数错误地理解为："当连接到此队列的所有客户端断开时，这个队列自动删除"。因为生产者客户端创建这个队列，
或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。</p></li>
<li><p>arguments：设置队列的其它一些参数，如
<code>x-message-ttl</code>、<code>x-expires</code>、<code>x-max-length</code>、<code>x-max-priority</code>
等</p></li>
</ul>
<blockquote>
<p>注意要点：生产者和消费者都能够使用 <code>queueDeclare</code>
来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。
必须先取消订阅，然后将信道设置为 "传输" 模式，之后才能声明队列。</p>
</blockquote>
<p>对应于 <code>exchangeDeclareNoWait</code> 方法，这里也有一个
<code>queueDeclareNoWait</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void queueDeclareNoWait(String queue, boolean durable, boolean exclusive,</span><br><span class="line">    boolean autoDelete, Map&lt;String, Object&gt; arguments) throws IOException;</span><br></pre></td></tr></table></figure>
<p>方法的返回值也是
void，表示不需要服务端的任何返回。同样也需要注意，在调用完
<code>queueDeclareNoWait</code>
之后，紧接着使用声明的队列时有可能会发生异常情况。</p>
<p>同样这里还有一个 <code>queueDeclarePassive</code>
的方法，也比较常用。这个方法用来检测相应的队列是否存在。
如果存在则正常返回，如果不存在则抛出异常：404 channel exception，同时
Channel 也会被关闭。方法定义如下：</p>
<p><code>Queue.DeclareOk queueDeclarePassive(String queue) throws IOException;</code></p>
<p>与交换器对应，关于队列也有删除的相应方法：</p>
<ol type="1">
<li><p><code>Queue.DeleteOk queueDelete(String queue) throws IOException;</code></p></li>
<li><p><code>Queue.DeleteOk queueDelete(String queue, boolean ifUnused, boolean ifEmpty) throws IOException;</code></p></li>
<li><p><code>void queueDeleteNoWait(String queue, boolean ifUnused, boolean ifEmpty) throws IOException;</code></p></li>
</ol>
<p>其中 queue 表示队列的名称，ifEmpty 设置为 true
表示在队列为空的情况下才能够删除。</p>
<p>与队列相关的还有一个有意思的方法 - queuePurge，区别于
queueDelete，这个方法用来清空队列中的内容，而不删除队列本身，具体定义如下：</p>
<p><code>Queue.PurgeOk queuePurge(String queue) throws IOException;</code></p>
<h3 id="queuebind-方法详解">queueBind 方法详解</h3>
<p>将队列和交换器绑定的方法如下，可以与前两节中的方法定义进行类比。</p>
<ol type="1">
<li><p><code>Queue.BindOk queueBind(String queue, String exchange, String routingKey) throws IOException;</code></p></li>
<li><p><code>Queue.BindOk queueBind(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments) throws IOException;</code></p></li>
<li><p><code>void queueBindNoWait(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments) throws IOException;</code></p></li>
</ol>
<p>方法中涉及的参数详解。</p>
<ul>
<li><p>queue：队列名称</p></li>
<li><p>exchange：交换器名称</p></li>
<li><p>routingKey：用来绑定队列和交换器的路由键</p></li>
<li><p>arguments：定义绑定的一些参数</p></li>
</ul>
<p>不仅可以将队列和交换器绑定起来，也可以将已经被绑定的队列和交换器进行解绑。具体方法可以参考如下：</p>
<ol type="1">
<li><p><code>Queue.UnbindOk queueUnbind(String queue, String exchange, String routingKey) throws IOException;</code></p></li>
<li><p><code>Queue.UnbindOk queueUnbind(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments) throws IOException;</code></p></li>
</ol>
<h3 id="exchangebind-方法详解">exchangeBind 方法详解</h3>
<p>我们不仅可以将交换器与队列绑定，也可以将交换器与交换器绑定，后者和前者的用法如出一辙，相应的方法如下：</p>
<ol type="1">
<li><p><code>Exchange.BindOk exchangeBind(String destination, String source, String routingKey) throws IOException;</code></p></li>
<li><p><code>Exchange.BindOk exchangeBind(String destination, String source, String routingKey, Map&lt;String, Object&gt; arguments) throws IOException;</code></p></li>
<li><p><code>void exchangeBind(String destination, String source, String routingKey, Map&lt;String, Object&gt; arguments) throws IOException;</code></p></li>
</ol>
<p>绑定之后，消息从 source 交换器转发到 destination
交换器，某种程度上来说 destination 交换器可以看作一个队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(&quot;source&quot;, &quot;direct&quot;, false, true, null);</span><br><span class="line">channel.exchangeDeclare(&quot;destination&quot;, &quot;fanout&quot;, false, true, null);</span><br><span class="line">channel.exchangeBind(&quot;destination&quot;, &quot;source&quot;, &quot;exKey&quot;);</span><br><span class="line">channel.queueDeclare(&quot;queue&quot;, false, false, true, null);</span><br><span class="line">channel.queueBind(&quot;queue&quot;, &quot;destination&quot;, &quot;&quot;);</span><br><span class="line">channel.basicPublish(&quot;source&quot;, &quot;exKey&quot;, null, &quot;exToExDemo&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<p>生产者发送消息至交换器 source 中，交换器 source
根据路由键找到与其匹配的另一个交换器 destination，并把消息转发到
destination 中， 进而存储在 destination 绑定的队列 queue 中。</p>
<figure>
<img src="/images/rabbitmq/10.png" alt="10" />
<figcaption aria-hidden="true">10</figcaption>
</figure>
<h3 id="何时创建">何时创建</h3>
<p>RabbitMQ
的消息存储在队列中，交换器的使用并不真正耗费服务器的性能，而队列会。如果要衡量
RabbitMQ 当前的 QPS 只需看队列的即可。
在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值，以便在固定硬件资源的情况下进行合理有效的分配。</p>
<p>根据 RabbitMQ
官方建议，生产者和消费者都应该尝试创建（这里指声明操作）队列。
这是一个很好的建议，但不适用于所有的情况。如果业务本身在架构之初已经充分地预估了队列地使用情况，
完全可以在业务程序上线之前在服务器上创建好，这样业务程序也可以免去声明地过程，直接使用即可。</p>
<p>预先创建好资源还有一个好处是，可以确保交换器和队列之间正确地绑定匹配。
很多时候，由于人为因素、代码缺陷等，发送消息地交换器并没有绑定任何队列，那么消息将会丢失；
或者交换器绑定了某个队列，但是发送消息的时候路由键无法与现存的队列匹配，那么消息也会丢失。
当然可以配合 mandatory 参数或者备份交换器来提高程序的健壮性。</p>
<p>与此同时，预估好队列的使用情况非常重要，如果在后期运行过程中超过预期的阈值，可以根据实际情况对当前集群进行扩容或者将相应的队列
迁移到其他集群。迁移的过程也可以对业务程序完全透明。此种方法也更有利于开发和运维分工，便于相应的资源管理。</p>
<p>如果集群资源充足，而即将使用的队列所占用的资源又在可控的范围之内，为了增加业务程序的灵活性，也完全可以在业务程序中声明队列。</p>
<h2 id="发送消息">发送消息</h2>
<p>如果要发送一个消息，可以使用 Channel 类的 basicPublish
方法，比如发送一条内容为 "Hello World!" 的消息，参考如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] messageBodyBytes = &quot;Hello, World!&quot;.getBytes();</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, null, messageBodyBytes);</span><br></pre></td></tr></table></figure>
<p>为了更好地控制发送，可以使用 mandatory
这个参数，或者可以发送一些特定属性的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_LPAIN,</span><br><span class="line">        messageBodyBytes);</span><br></pre></td></tr></table></figure>
<p>上面这行代码发送了一条消息，这条消息的投递模式（delivery mode）设置为
2，即消息会被持久化（即存入磁盘）在服务器中。
同时这条消息的优先级（priority）设置为 1，content-type 为
"text/plain"。可以自己设定消息的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(exchangeName, routingKey,</span><br><span class="line">        new AMQP.BasicProperties.Builder()</span><br><span class="line">        .contentType(&quot;text/plain&quot;)</span><br><span class="line">        .deliveryMode(2)</span><br><span class="line">        .priority(1)</span><br><span class="line">        .userId(&quot;hidden&quot;)</span><br><span class="line">        .build(),</span><br><span class="line">        messageBodyBytes);</span><br></pre></td></tr></table></figure>
<p>也可以发送一条带有 headers 的消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;();</span><br><span class="line">headers.put(&quot;location&quot;, &quot;here&quot;);</span><br><span class="line">headers.put(&quot;time&quot;, &quot;today&quot;);</span><br><span class="line">channel.basicPublish(exchangeName, routingKey,</span><br><span class="line">    new AMQP.BaiscProperties.Builder()</span><br><span class="line">    .builder(headers)</span><br><span class="line">    .build(),</span><br><span class="line">    messageBodyBytes);</span><br></pre></td></tr></table></figure>
<p>还可以发送一条带有过期时间（expiration）的消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(exchangeName, routingKey,</span><br><span class="line">    new AMQP.BasicProperties.Builder()</span><br><span class="line">    .expiration(&quot;60000&quot;)</span><br><span class="line">    .build()</span><br><span class="line">    .messageBodyBytes);</span><br></pre></td></tr></table></figure>
<p>对于 basicPublish 而言，有几个重载方法：</p>
<ol type="1">
<li><p><code>void basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) throws IOException;</code></p></li>
<li><p><code>void basicPublish(String exchange, String routingKey, boolean mandatory, BasicProperties props, byte[] body) throws IOException;</code></p></li>
<li><p><code>void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body) throws IOException;</code></p></li>
</ol>
<p>对应的具体参数解释如下所述。</p>
<ul>
<li><p>exchange：交换器名称，指明消息发送到哪个交换器中。如果设置为空字符串，则消息会被发送到
RabbitMQ 默认的交换器中。</p></li>
<li><p>routingKey：路由键，交换器根据路由键将消息存储到相应的队列之中。</p></li>
<li><p>props：消息的基本属性集，其包含 14 个属性成员，分别有
contentType、contentEncoding、headers(Map&lt;String, Object&gt;)、
deliveryMode、priority、correlationId、replyTo、expiration、messageId、timestamp、type、userId、appId、clusterId。</p></li>
<li><p>byte[] body：消息体（payload），真正需要发送的消息。</p></li>
</ul>
<h2 id="消费消息">消费消息</h2>
<p>RabbitMQ 的消费模式分两种：推（push）和拉（pull）模式。推模式采用
Basic.Consume 进行消费，而拉模式是调用 Basic.Get 进行消费。</p>
<h3 id="推模式">推模式</h3>
<p>在推模式中，可以通过持续订阅的方式来消费消息，使用到的相关类有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import com.rabbitmq.client.Consumer;</span><br><span class="line">import com.rabbitmq.client.DefaultConsumer;</span><br></pre></td></tr></table></figure>
<p>接收消息一般通过实现 Consumer 接口或者继承 DefaultConsumer
类来实现。当调用与 Consumer 相关的 API
方法时，不同的订阅采用不同的消费者标签（consumerTag）
来区分彼此，在同一个 Channel
中的消费者也需要通过唯一的消费者标签以作区分，关键消费者代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">boolean autoAck = false;</span><br><span class="line">channel.basicQos(64);</span><br><span class="line">channel.basicConsume(queueName, autoAck, &quot;myConsumerTag&quot;,</span><br><span class="line">    new DefaultConsumer(channel) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">            String routingKey = envolope.getRoutineKey();</span><br><span class="line">            String contentType = properties.getContentType();</span><br><span class="line">            long deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">            // (process the message components here...)</span><br><span class="line">            channel.basicAck(deliveryTag, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>注意，上面代码中显式地设置 autoAck 为
false，然后在接收到消息之后进行显式 ack 操作（channel.basicAck），
对于消费者来说这个设置是非常必要的，可以防止消息不必要地丢失。</p>
<p>Channel 类中 basicConsume 方法有如下几种形式：</p>
<ol type="1">
<li><p><code>String basicConsume(String queue, Consumer callback) throws IOException;</code></p></li>
<li><p><code>String basicConsume(String queue, boolean autoAck, Consumer ballback) throws IOException;</code></p></li>
<li><p><code>String basicConsume(String queue, boolean autoAck, Map&lt;String, Object&gt; arguments, Consumer callback) throws IOException;</code></p></li>
<li><p><code>String basicConsume(string queue, boolean autoAck, String consumerTag, Consumer callback) throws IOException;</code></p></li>
<li><p><code>String basicConsume(String queue, boolean autoAck, String consumerTag, boolean noLocal, boolean exclusive, Map&lt;String, Object&gt; arguments, Consumer callback) throws IOException;</code></p></li>
</ol>
<p>其对应地参数说明如下所述：</p>
<ul>
<li><p>queue：队列地名称</p></li>
<li><p>autoAck：设置是否自动确认。建议设置成
false，即不自动确认</p></li>
<li><p>consumerTag：消费者标签，用来区分多个消费者</p></li>
<li><p>noLocal：设置为 true 则表示不能将同一个 Connection
中生产者传送给这个 Connection 中的消费者</p></li>
<li><p>exclusive：设置是否排他</p></li>
<li><p>arguments：设置消费者的其它参数</p></li>
<li><p>callback：设置消费者的回调函数。用来处理 RabbitMQ
推送过来的消息，比如
DefaultConsumer，使用时需要重写（override）其中的方法。</p></li>
</ul>
<p>对于消费者客户端来说重写 handleDelivery
方法是十分方便的。更复杂的消费者客户端会重写更多的方法，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void handleConsumeOk(String consumerTag);</span><br><span class="line">void handleCancelOk(String consumerTag);</span><br><span class="line">void handleCancel(String consumerTag) throws IOException;</span><br><span class="line">void handleShutdownSignal(String consumerTag, ShutdownSignalException sig);</span><br><span class="line">void handleRecoverOk(String consumerTag);</span><br></pre></td></tr></table></figure>
<p>比如 <code>handleShutdownSignal</code> 方法，当 Channel 或者
Connection 关闭的时候会调用。 再者，<code>handleConsumeOk</code>
方法会在其他方法之前调用，返回消费者标签。</p>
<p>重写 <code>handleCancelOk</code> 和 <code>handleCancel</code>
方法，这样消费端可以在显式地或者隐式地取消订阅的时候调用。 也可以通过
<code>channel.basicCancel</code> 方法来显式地取消一个消费者的订阅：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicCancel(consumerTag);</span><br></pre></td></tr></table></figure>
<p>注意上面这行代码会首先触发 <code>handleConsumerOk</code>
方法，之后触发 <code>handleDelivery</code> 方法，最后才触发
<code>handleCancelOk</code> 方法。</p>
<p>生产者一样，消费者客户端同样需要考虑线程安全的问题。
消费者客户端的这些 callback 会被分配到与 Channel
不同的线程池上，这意味着消费者客户端可以安全地调用这些阻塞方法， 比如
<code>channel.queueDeclare</code>、<code>channel.basicCancel</code>
等。</p>
<p>每个 Channel 都有自己独立的线程。最常用的做法是一个 Channel
对应一个消费者，也就是意味着消费者彼此之间没有任何关联。
当然也可以在一个 Channel 中维持多个消费者，但是要注意一个问题，如果
Channel 中的一个消费者一直在运行，那么其他 消费者的 callback 会被
"耽搁"。</p>
<h3 id="拉模式">拉模式</h3>
<p>通过 <code>channel.basicGet</code> 方法可以单条地获取消息，其返回值是
<code>GetResponse</code>。<code>Channel</code> 类的
<code>basicGet</code> 方法没有其他重载方法，只有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetResponse basicGet(String queue, boolean autoAck) throws IOException;</span><br></pre></td></tr></table></figure>
<p>其中 queue 代表队列的名称，如果设置 autoAck 为
false，那么同样需要调用 channel.basicAck 来确认消息已被成功接收。</p>
<p>拉模式关键代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = channel.basicGet(QUEUE_NAME, false);</span><br><span class="line">System.out.println(new String(response.getBody()));</span><br><span class="line">channel.basicAck(response,getEnvelope().getDeliveryTag(), false);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Basic.Consume</code>
将信道（channel）置为接收模式，直到取消队列的订阅为止。在接收模式期间，RabbitMQ
会不断地推送消息给消费者， 当然推送消息的个数还是会受到
<code>Basic.Qos</code>
的限制。如果只想从队列获得单条消息而不是持续订阅，建议还是使用
<code>Basic.Get</code> 进行消费。 但是不能将 <code>Basic.Get</code>
放在一个循环里来代替 <code>Basic.Consume</code>，这样做会严重影响
RabbitMQ 的性能。 如果要实现高吞吐量，消费者理应使用
<code>Basic.Consume</code> 方法。</p>
</blockquote>
<figure>
<img src="/images/rabbitmq/11.png" alt="11" />
<figcaption aria-hidden="true">11</figcaption>
</figure>
<h2 id="消费者的确认与拒绝">消费者的确认与拒绝</h2>
<p>为了保证消息从队列可靠地达到消费者，RabbitMQ
提供了消息确认机制（message acknowledgement）。
消费者在订阅队列时，可以指定 autoAck，当 autoAck 等于 false 时，RabbitMQ
会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移去消息。 当
autoAck 为 true 时，RabbitMQ
会自动地把发送出去的消息置为确认，然后从内存（或磁盘）中删除，而不管消费者是否真正地消费了这些消息。</p>
<p>采用消息确认机制后，只要设置 autoAck 参数为
false，消费者就有足够的时间处理消息，不用担心处理消息过程中消费者挂掉后消息丢失的问题，
因为 RabbitMQ 会一直等到持有消息直到消费者显式调用
<code>Basic.Ack</code> 命令为止。</p>
<p>当 autoAck 参数置为 false，对于 RabbitMQ
服务端而言，队列中的消息分成两个部分：
一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者确认信号的消息。
如果 RabbitMQ
一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开连接，则
RabbitMQ 会安排该消息重新进入队列，
等待下一个消费者，当然也有可能还是原来的那个消费者。</p>
<p>RabbitMQ
不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开，
这么设计的原因是 RabbitMQ 允许消费者消费一条消息的时间可以很久很久。</p>
<p>RabbitMQ 的 Web 管理平台上可以看到当前队列中的 "Ready" 状态和
"Unacknowledged" 状态的消息数，分别对应上文中的
等待投递给消费者的消息数和已经投递给消费者但是未收到确认信号的消息数。</p>
<p>在消费者收到消息后，如果想明确拒绝当前的消息而不是确认，可以使用
<code>Basic.Reject</code> 这个命令， 消费者客户端可以调用与其对应的
<code>channel.basicReject</code> 方法来告诉 RabbitMQ 拒绝这个消息。</p>
<p>Channel 类中的 basicReject 方法定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void basicReject(long deliveryTag, boolean requeue) throws IOException;</span><br></pre></td></tr></table></figure>
<p>其中 deliveryTag 可以看作消息的编号，它是一个 64 位的长整型。 如果
requeue 为 true，则 RabbitMQ
会重新将这条消息存入队列，以便可以发给下一个订阅的消费者； 如果 requeue
为 false，则 RabbitMQ
立即把消息从队列中删除，而不是把它发送给新的消费者。</p>
<p>Basic.Reject
命令一次只能拒绝一条消息，如果想要批量拒绝消息，则可以使用 Basic.Nack
这个命令。 消费者客户端可以调用 channel.basicNack
方法来实现，方法定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void basicNack(long deliveryTag, boolean multiple, boolean requeue) throws IOException;</span><br></pre></td></tr></table></figure>
<p>其中 deliveryTag 和 requeue 的含义可以参考 basicReject 方法。
multiple 参数设置为 false 则表示拒绝编号为 deliveryTag
的这一条消息，这时候 basicNack 和 basicReject 方法一样； multiple 设置为
true 则表示拒绝 deliveryTag 编号之前所有未被当前消费者确认的消息。</p>
<blockquote>
<p>将 <code>channel.basicReject</code> 或者 <code>channel.Nack</code>
中的 requeue 设置为 false，可以启用 "死信队列" 的功能。
死信队列可以通过检测被拒绝或者未送达的消息的消息来追踪问题。</p>
</blockquote>
<p>对应 requeue，AMQP 中还有一个命令 <code>Basic.Recover</code>
具备可重入队列的特性。其对应的客户端方法为：</p>
<ol type="1">
<li><p><code>Basic.RecoverOk basicRecover() throws IOException;</code></p></li>
<li><p><code>Basic.RecoverOk basicRecover(boolean requeue) throws IOException;</code></p></li>
</ol>
<p>这个 <code>channel.basicRecover</code> 方法用来请求 RabbitMQ
重新发送还未被确认的消息。 如果 requeue 参数设置为
true，则未被确认的消息会被重新加入到队列中，这样对于同一条消息来说，可能会被分配给与之前不同的消费者。
如果 requeue 参数设置为
false，那么同一条消息会被分配给与之前相同的消费者。
默认情况下，如果不设置 requeue 这个参数，相当于
<code>channel.basicRecover(true)</code>，即 requeue 默认为 true。</p>
<h2 id="关闭连接">关闭连接</h2>
<p>在应用程序使用完之后，需要关闭连接，释放资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
<p>显式地关闭 Channel 是个好习惯，但这不是必须但，在 Connection
关闭的时候，Channel 也会自动关闭。</p>
<p>AMQP 协议中的 Connection 和 Channel
采用同样的方式来管理网络失败、内部错误和显式地关闭连接。Connection 和
Channel 所具备的生命周期如下所述。</p>
<ul>
<li><p>Open：开启状态，代表当前对象可以使用</p></li>
<li><p>Closing：正在关闭状态。当前对象被显式地通知关闭方法（shutdown），这样就产生了一个关闭请求让其内部对象进行相应的操作，并等待这些关闭操作的完成。</p></li>
<li><p>Closed：已经关闭的状态。当前对象已经接收到所有的内部对象已完成关闭动作的通知，并且其也关闭了自身。</p></li>
</ul>
<p>Connection 和 Channel 中，与关闭相关的方法有
<code>addShutdownListener(ShutdownListener listener)</code> 和
<code>removeShutdownListener(ShutdownListener listener)</code>。 当
Connection 或者 Channel 的状态转变为 Closed 的时候会调用
ShutdownListener。而且如果将一个 ShutdownListener 注册到一个已经处于
Closed 状态的对象时，会立刻调用 ShutdownListener。</p>
<p>getCloseReason 方法可以让你知道对象关闭的原因；isOpen
方法检测对象当前是否处于开启状态；close(int closeCode, String
closeMessage) 方法显式地通知当前对象执行关闭操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import com.rabbitmq.client.ShutdownSignalException;</span><br><span class="line">import com.rabbitmq.client.ShutdownListener;</span><br><span class="line"></span><br><span class="line">connection.addShutdownListener(new ShutdownListener() &#123;</span><br><span class="line">    public void shutdownCompleted(ShutdownSignalException cause)</span><br><span class="line">    &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当触发 ShutdownListener 的时候，就可以获取到
ShutdownSignalException，这个 ShutdownSignalException 包含了关闭的原因，
这里原因也可以通过调用前面所提及的 getCloseReason获取。</p>
<p>ShutdownSignalException 提供了多个方法来分析关闭的原因。 isHardError
方法可以知道是 Connection 的还是 Channel 的错误；getReason 方法可以获取
cause 相关的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void shutdownCompleted(ShutdownSignalException cause)</span><br><span class="line">&#123;</span><br><span class="line">    if (cause.isHardError()) &#123;</span><br><span class="line">        Connection conn = (Connection) cause.getReference();</span><br><span class="line">        if (!cause.isInitiatedByApplication()) &#123;</span><br><span class="line">            Method reason = cause.getReason();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Channel ch = (Channel)cause.getReference();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RabbitMQ/" rel="tag"><i class="fa fa-tag"></i> RabbitMQ</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/11/24/rabbitmq/AMQP%20%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/" rel="prev" title="AMQP 协议介绍">
                  <i class="fa fa-angle-left"></i> AMQP 协议介绍
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/11/26/rabbitmq/RabbitMQ%20%E8%BF%9B%E9%98%B6/" rel="next" title="RabbitMQ 进阶">
                  RabbitMQ 进阶 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">eleven26</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eleven26" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
